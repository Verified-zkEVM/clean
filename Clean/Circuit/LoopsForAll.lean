/-
This file proves some properties about `forM`, `mapM`, and `foldlM` monad loops when used in a `Circuit`,
typically leveraging a `ConstantLawfulCircuits` assumption on the loop body.

The end result are loop methods `Circuit.{mapFinRange, map, forEach, foldl}` that simplify
under `circuit_norm` in every way we need them to.
-/
import Clean.Circuit.Constant
import Clean.Utils.Misc
variable {n m : ℕ} {F : Type} [Field F] {α β : Type}

lemma Vector.forM_toList (xs : Vector α n) {m : Type → Type} [Monad m] (body : α → m Unit) :
    xs.forM body = forM xs.toList body := by
  rw [Vector.forM_eq_forM, Vector.forM_mk, List.forM_toArray, List.forM_eq_forM]

lemma Vector.mapM_toList (xs : Vector α n) {m : Type → Type} [monad: Monad m] [LawfulMonad m] (body : α → m β) :
    (fun v => v.toArray.toList) <$> (xs.mapM body) = xs.toList.mapM body := by
  rw [←Array.toList_mapM, ←Vector.toArray_mapM, Functor.map_map]

lemma Vector.foldlM_toList (xs : Vector α n) {m : Type → Type} [Monad m] (body : β → α → m β) (init : β) :
    xs.foldlM body init = xs.toList.foldlM body init := by
  rw [Vector.foldlM_mk, List.foldlM_toArray]

namespace Circuit

-- helper lemma to characterize `forAll` statements on the operations generated by loops
lemma forAll_flatten (xs : Vector α m) {circuit : α → Circuit F β} (constant : ConstantCircuits circuit)
  {prop : Operations.Condition F} :
  Operations.forAll n prop (List.ofFn fun (i : Fin m) => (circuit xs[i.val]).operations (n + i * constant.local_length)).flatten
    ↔ ∀ (i : Fin m), (circuit xs[i.val]).forAll prop (n + i * constant.local_length) := by
  induction m generalizing n
  case zero => simp [Operations.forAll]
  case succ m ih =>
    rw [List.ofFn_succ, List.flatten_cons, Operations.forAll_append, Fin.forall_fin_succ, Circuit.forAll_def]
    simp only [Fin.val_zero, zero_mul, add_zero, Fin.val_succ]
    specialize ih (n := n + constant.local_length) (xs := xs.drop 1)
    simp only [Vector.drop_eq_cast_extract, Nat.add_one_sub_one, Vector.getElem_cast,
      Vector.getElem_extract] at ih
    have : ((circuit xs[0]).operations n).local_length + n = n + constant.local_length := by
      rw [←constant.local_length_eq (xs[0]) n]; ac_rfl
    rw [this]
    ring_nf at ih ⊢
    rw [ih]

-- helper lemma to do induction on (List.ofFn ...).flatten terms
private lemma ofFn_flatten_cons {circuit : α → Circuit F β} (constant : ConstantCircuits circuit) (x : α) (xs : Vector α m) (n : ℕ) :
  (List.ofFn fun i => (circuit (Vector.cons x xs)[i.val]).operations (n + i * constant.local_length)).flatten
    = (circuit x).operations n ++ (List.ofFn fun i => (circuit xs[i.val]).operations (n + constant.local_length + i * constant.local_length)).flatten := by
  simp +arith [Vector.cons, add_mul]

namespace ForM
variable {circuit : α → Circuit F Unit} (xs : Vector α m) (constant : ConstantCircuits circuit) (n : ℕ)

theorem local_length_eq : (xs.forM circuit).local_length n = m * constant.local_length := by
  set k := constant.local_length
  induction xs using Vector.induct generalizing n
  case nil => ac_rfl
  case cons x xs ih =>
    rw [Vector.forM_toList, Vector.cons, List.forM_cons, ←Vector.forM_toList,
      bind_local_length_eq, ih, constant.local_length_eq]
    ring

theorem output_eq : (xs.forM circuit).output n = () := rfl

theorem operations_eq :
  (xs.forM circuit).operations n =
    (List.ofFn fun (i : Fin m) => (circuit xs[i.val]).operations (n + i * constant.local_length)).flatten := by
  induction xs using Vector.induct generalizing n
  case nil => rfl
  case cons x xs ih =>
    rw [ofFn_flatten_cons, Vector.forM_toList, Vector.cons, List.forM_cons, ←Vector.forM_toList,
      bind_operations_eq, ih, constant.local_length_eq]

theorem forAll_iff {prop : Operations.Condition F} :
  (xs.forM circuit).forAll prop n ↔
    ∀ (i : Fin m), (circuit xs[i.val]).forAll prop (n + i * constant.local_length) := by
  rw [forAll_def, operations_eq, forAll_flatten]
end ForM

namespace MapM
variable {circuit : α → Circuit F β}
  {xs : Vector α m} [constant: ConstantCircuits circuit] (n : ℕ)

theorem local_length_eq : (xs.mapM circuit).local_length n = m * constant.local_length := by
  induction xs using Vector.induct_push
  case nil =>
    rw [Vector.mapM_mk_empty, pure_local_length_eq, zero_mul]
  case push xs x ih =>
    rw [Vector.mapM_push, bind_local_length_eq, bind_local_length_eq, pure_local_length_eq, ih, constant.local_length_eq]
    ring

theorem output_eq : (xs.mapM circuit).output n =
    xs.mapIdx fun i x => (circuit x).output (n + i * constant.local_length) := by
  induction xs using Vector.induct_push
  case nil => simp
  case push xs x ih =>
    rw [Vector.mapM_push, bind_output_eq, bind_output_eq, pure_output_eq, ih, local_length_eq]
    simp

lemma ext_map_toList (f g : Circuit F (Vector α n)) :
    (fun v => v.toArray.toList) <$> f = (fun v => v.toArray.toList) <$> g → f = g := by
  intro h
  rw [ext_iff] at h
  ext1 n
  · replace h := (h n).left
    rw [map_output_eq, map_output_eq] at h
    exact Vector.toList_inj.mp h
  · replace h := (h n).right
    rw [map_operations_eq, map_operations_eq] at h
    exact h

lemma mapM_cons (xs : Vector α n) (body : α → Circuit F β) (x : α) :
  (Vector.cons x xs).mapM body = do
    let y ← body x
    let ys ← xs.mapM body
    return Vector.cons y ys := by
  apply ext_map_toList
  rw [Vector.mapM_toList, Vector.toList_cons, List.mapM_cons, ←Vector.mapM_toList]
  simp only [map_bind, map_pure, Vector.toList_cons]
  rfl

theorem operations_eq : (xs.mapM circuit).operations n =
    (List.ofFn fun (i : Fin m) => (circuit xs[i.val]).operations (n + i * constant.local_length)).flatten := by
  induction xs using Vector.induct generalizing n
  case nil => simp [pure_operations_eq]
  case cons x xs ih =>
    rw [mapM_cons, bind_operations_eq, bind_operations_eq, pure_operations_eq, ih,
      constant.local_length_eq, List.append_nil, ofFn_flatten_cons]

theorem forAll_iff {prop : Operations.Condition F} :
  (xs.mapM circuit).forAll prop n ↔
    ∀ (i : Fin m), (circuit xs[i.val]).forAll prop (n + i * constant.local_length) := by
  rw [forAll_def, operations_eq, forAll_flatten]

end MapM

def forEach {m : ℕ} (xs : Vector α m) [Inhabited α] (body : α → Circuit F Unit)
    (_constant : ConstantCircuits body := by infer_constant_circuits) : Circuit F Unit :=
  xs.forM body

section forEach
variable {env : Environment F} {m n : ℕ} [Inhabited α] {xs : Vector α m}
  {body : α → Circuit F Unit} {constant : ConstantCircuits body} {prop : Operations.Condition F}

@[circuit_norm ↓]
lemma forEach.soundness :
  constraints_hold.soundness env ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, constraints_hold.soundness env (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [forEach, constraints_hold.soundness_iff_forAll']
  rw [ForM.forAll_iff, ConstantCircuits.local_length_eq]

/-- variant of `forEach.soundness`, for when the constraints don't depend on the input offset -/
lemma forEach.soundness' :
  constraints_hold.soundness env (forEach xs body constant |>.operations n) →
    ∀ x ∈ xs, ∃ k : ℕ, constraints_hold.soundness env (body x |>.operations k) := by
  simp only [forEach, constraints_hold.soundness_iff_forAll', ForM.forAll_iff]
  intro h x hx
  obtain ⟨i, hi, rfl⟩ := Vector.getElem_of_mem hx
  exact ⟨ _ , h ⟨i, hi⟩ ⟩

@[circuit_norm ↓]
lemma forEach.completeness :
  constraints_hold.completeness env ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, constraints_hold.completeness env (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [forEach, constraints_hold.completeness_iff_forAll']
  rw [ForM.forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma forEach.uses_local_witnesses :
  env.uses_local_witnesses_completeness n ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, env.uses_local_witnesses_completeness (n + i*(body default).local_length) (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [forEach, env.uses_local_witnesses_completeness_iff_forAll, ←forAll_def]
  rw [ForM.forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma forEach.forAll :
  Operations.forAll n prop ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, (body xs[i.val] |>.forAll prop (n + i*(body default).local_length)) := by
  simp only [forEach, ←forAll_def]
  rw [ForM.forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma forEach.local_length_eq :
    (forEach xs body constant).local_length n = m * (body default).local_length := by
  rw [forEach, ForM.local_length_eq, constant.local_length_eq]

@[circuit_norm ↓]
lemma forEach.output_eq :
  (forEach xs body constant).output n = () := rfl

end forEach
