/-
This file proves some properties about `forM`, `mapM`, and `foldlM` monad loops when used in a `Circuit`,
typically leveraging a `ConstantLength` assumption on the loop body.

The end result are loop methods `Circuit.{mapFinRange, map, forEach, foldl}` that simplify
under `circuit_norm` in every way we need them to.
-/
import Clean.Circuit.Subcircuit
import Clean.Utils.Misc

variable {n m : ℕ} {F : Type} [Field F] {α β : Type}

lemma Vector.forM_toList (xs : Vector α n) {m : Type → Type} [Monad m] (body : α → m Unit) :
    xs.forM body = forM xs.toList body := by
  rw [Vector.forM_eq_forM, Vector.forM_mk, List.forM_toArray, List.forM_eq_forM]; rfl

lemma Vector.toList_mapM (xs : Vector α n) {m : Type → Type} [monad: Monad m] [LawfulMonad m] (body : α → m β) :
    Vector.toList <$> (xs.mapM body) = xs.toList.mapM body := by
  rw [←Array.toList_mapM]
  suffices toList <$> mapM body xs = Array.toList <$> Array.mapM body xs.toArray by
    convert this
  rw [←Vector.toArray_mapM, Functor.map_map]
  congr

lemma Vector.foldlM_toList (xs : Vector α n) {m : Type → Type} [Monad m] (body : β → α → m β) (init : β) :
    xs.foldlM body init = xs.toList.foldlM body init := by
  rw [Vector.foldlM_mk, List.foldlM_toArray]
  congr

namespace Circuit
variable {prop : Condition F}

lemma ConstantLength.length_eq_default {circuit : α → Circuit F β} (_ : ConstantLength circuit) [Inhabited α] (a : α) (n : ℕ) :
   (circuit a).localLength n = (circuit default).localLength 0 := by
  simp only [ConstantLength.localLength_eq]

def ConstantLength.fromConstantLength' [Inhabited β] (body : β × Fin m → Circuit F β)
    (h : ∀ (acc : β) (i i' : Fin m) n,
      (body (acc, i)).localLength n = (body (default, i')).localLength 0) :
    ConstantLength body where
  localLength := match m with
    | 0 => 0
    | m + 1 => (body (default, 0)).localLength 0
  localLength_eq := by
    intro (b, i) n
    rcases m with rfl | m; nomatch i
    exact h b i 0 n

-- helper lemmas to characterize `forAll` statements on the operations generated by loops

lemma forAll_flatten_abstract (circuit : Fin m → Circuit F β) (constant : ConstantLength circuit) :
  Operations.forAll n prop (List.ofFn fun i => (circuit i).operations (n + i * constant.localLength)).flatten
    ↔ ∀ (i : Fin m), (circuit i).forAll (n + i * constant.localLength) prop := by
  induction m generalizing n
  case zero => simp [Operations.forAll]
  case succ m ih =>
    rw [List.ofFn_succ, List.flatten_cons, Operations.forAll_append, Fin.forall_fin_succ, Circuit.forAll_def]
    simp only [Fin.val_zero, zero_mul, add_zero, Fin.val_succ]
    let circuit' := fun i : Fin m => circuit i.succ
    let constant' : ConstantLength circuit' := {
      localLength := constant.localLength
      localLength_eq a n := constant.localLength_eq (a.succ) n }
    set k := constant.localLength
    specialize ih (n:=n + k) circuit' constant'
    set k' := constant'.localLength
    have : k' = k := rfl
    rw [this] at ih
    have : ((circuit 0).operations n).localLength + n = n + constant.localLength := by
      rw [←constant.localLength_eq 0 n]; ac_rfl
    rw [this]
    ring_nf at ih ⊢
    rw [ih]

lemma forAll_flatten (xs : Vector α m) {circuit : α → Circuit F β} (constant : ConstantLength circuit) :
  Operations.forAll n prop (List.ofFn fun (i : Fin m) => (circuit xs[i.val]).operations (n + i * constant.localLength)).flatten
    ↔ ∀ (i : Fin m), (circuit xs[i.val]).forAll (n + i * constant.localLength) prop :=
  forAll_flatten_abstract (fun i : Fin m => circuit xs[i.val]) {
    localLength := constant.localLength
    localLength_eq _ _ := constant.localLength_eq .. }

-- helper lemma to do induction on (List.ofFn ...).flatten terms
private lemma ofFn_flatten_cons {circuit : α → Circuit F β} (constant : ConstantLength circuit) (x : α) (xs : Vector α m) (n : ℕ) :
  (List.ofFn fun i => (circuit (Vector.cons x xs)[i.val]).operations (n + i * constant.localLength)).flatten
    = (circuit x).operations n ++ (List.ofFn fun i => (circuit xs[i.val]).operations (n + constant.localLength + i * constant.localLength)).flatten := by
  simp +arith [Vector.cons, add_mul]

namespace ForM
variable {circuit : α → Circuit F Unit} (xs : Vector α m) (constant : ConstantLength circuit) (n : ℕ)

theorem localLength_eq : (xs.forM circuit).localLength n = m * constant.localLength := by
  set k := constant.localLength
  induction xs using Vector.induct generalizing n
  case nil => ac_rfl
  case cons x xs ih =>
    rw [Vector.forM_toList, Vector.cons, Vector.toList_mk, List.forM_cons, ←Vector.forM_toList,
      bind_localLength_eq, ih, constant.localLength_eq]
    ring

theorem output_eq : (xs.forM circuit).output n = () := rfl

theorem operations_eq :
  (xs.forM circuit).operations n =
    (List.ofFn fun (i : Fin m) => (circuit xs[i.val]).operations (n + i * constant.localLength)).flatten := by
  induction xs using Vector.induct generalizing n
  case nil => rfl
  case cons x xs ih =>
    rw [ofFn_flatten_cons, Vector.forM_toList, Vector.cons, Vector.toList_mk, List.forM_cons, ←Vector.forM_toList,
      bind_operations_eq, ih, constant.localLength_eq]

theorem forAll_iff {prop : Condition F} :
  (xs.forM circuit).forAll n prop ↔
    ∀ (i : Fin m), (circuit xs[i.val]).forAll (n + i * constant.localLength) prop := by
  rw [forAll_def, operations_eq, forAll_flatten]
end ForM

namespace MapM
variable {circuit : α → Circuit F β} {xs : Vector α m} [constant: ConstantLength circuit]
  {prop : Condition F}

theorem localLength_eq : (xs.mapM circuit).localLength n = m * constant.localLength := by
  induction xs using Vector.inductPush
  case nil =>
    rw [Vector.mapM_mk_empty, pure_localLength_eq, zero_mul]
  case push xs x ih =>
    rw [Vector.mapM_push, bind_localLength_eq, bind_localLength_eq, pure_localLength_eq, ih, constant.localLength_eq]
    ring

theorem output_eq : (xs.mapM circuit).output n =
    xs.mapIdx fun i x => (circuit x).output (n + i * constant.localLength) := by
  induction xs using Vector.inductPush
  case nil => simp
  case push xs x ih =>
    rw [Vector.mapM_push, bind_output_eq, bind_output_eq, pure_output_eq, ih, localLength_eq]
    simp

lemma ext_map_toList (f g : Circuit F (Vector α n)) :
    (fun v => v.toList) <$> f = (fun v => v.toList) <$> g → f = g := by
  intro h
  rw [ext_iff] at h
  ext1 n
  · replace h := (h n).left
    rw [map_output_eq, map_output_eq] at h
    exact Vector.toList_inj.mp h
  · replace h := (h n).right
    rw [map_operations_eq, map_operations_eq] at h
    exact h

lemma mapM_cons (xs : Vector α n) (body : α → Circuit F β) (x : α) :
  (Vector.cons x xs).mapM body = do
    let y ← body x
    let ys ← xs.mapM body
    return Vector.cons y ys := by
  apply ext_map_toList
  rw [Vector.toList_mapM, Vector.toList_cons, List.mapM_cons, ←Vector.toList_mapM]
  simp only [map_bind, map_pure]
  rfl

theorem operations_eq : (xs.mapM circuit).operations n =
    (List.ofFn fun (i : Fin m) => (circuit xs[i.val]).operations (n + i * constant.localLength)).flatten := by
  induction xs using Vector.induct generalizing n
  case nil => simp [pure_operations_eq]
  case cons x xs ih =>
    rw [mapM_cons, bind_operations_eq, bind_operations_eq, pure_operations_eq, ih,
      constant.localLength_eq, List.append_nil, ofFn_flatten_cons]

theorem forAll_iff :
  (xs.mapM circuit).forAll n prop ↔
    ∀ (i : Fin m), (circuit xs[i.val]).forAll (n + i * constant.localLength) prop := by
  rw [forAll_def, operations_eq, forAll_flatten]

-- specialization to mapFinRangeM
theorem mapFinRangeM_forAll_iff {circuit : Fin m → Circuit F β} [constant : ConstantLength circuit] :
  (Vector.mapFinRangeM m circuit).forAll n prop ↔
    ∀ i : Fin m, (circuit i).forAll (n + i*constant.localLength) prop := by
  rw [Vector.mapFinRangeM, forAll_iff]
  simp only [Vector.getElem_finRange]
end MapM

namespace FoldlM
@[reducible]
def prod (circuit : β → α → Circuit F β) : β × α → Circuit F β := fun t => circuit t.1 t.2

variable {env : Environment F} {prop : Condition F} {xs : Vector α m}
  {circuit : β → α → Circuit F β} {init : β} {constant : ConstantLength (prod circuit)}

lemma foldlM_cons (x : α) :
  (Vector.cons x xs).foldlM circuit init = (do
    let init' ← circuit init x
    xs.foldlM circuit init') := by
  rw [Vector.foldlM_toList, Vector.cons, Vector.toList_mk, List.foldlM_cons]
  simp only [←Vector.foldlM_toList]

theorem localLength_eq :
    (xs.foldlM circuit init).localLength n = m * constant.localLength := by
  induction xs using Vector.induct generalizing init n
  case nil => rw [zero_mul]; rfl
  case cons x xs ih =>
    rw [foldlM_cons, bind_localLength_eq, ih, constant.localLength_eq (init, x)]
    ring

lemma finFoldl_cons_succ (x : α) :
  Fin.foldl (m + 1) (fun acc i => (circuit acc (Vector.cons x xs)[i.val]).output (n + i * constant.localLength)) init
    = Fin.foldl m (fun acc i => (circuit acc xs[i.val]).output (n + constant.localLength + i * constant.localLength)) ((circuit init x).output n) := by
  set k := constant.localLength
  rw [Fin.foldl_succ]
  simp only [Fin.val_succ, Fin.val_zero, zero_mul, add_zero]
  congr
  funext acc i
  rw [add_mul, add_assoc, add_comm k]
  simp [Vector.cons]

theorem output_eq :
  (xs.foldlM circuit init).output n =
    Fin.foldl m (fun acc i => (circuit acc xs[i.val]).output (n + i * constant.localLength)) init := by
  induction xs using Vector.induct generalizing init n
  case nil => rfl
  case cons x xs ih =>
    rw [foldlM_cons, bind_output_eq, ih, constant.localLength_eq (init, x), finFoldl_cons_succ]

def foldlAcc (n : ℕ) (xs : Vector α m) (circuit : β → α → Circuit F β) (init : β) (j : Fin m) : β :=
  Fin.foldl j (fun acc i => (circuit acc xs[i.val]).output (n + i*(circuit acc xs[i.val]).localLength)) init

lemma foldlAcc_zero [NeZero m] : foldlAcc n xs circuit init 0 = init := by
  simp [foldlAcc, Fin.foldl_zero]

lemma foldlAcc_cons_succ (i : Fin m) (x : α) [constant : ConstantLength (prod circuit)] :
  foldlAcc n (Vector.cons x xs) circuit init i.succ =
    foldlAcc (n + (circuit init x).localLength n) xs circuit ((circuit init x).output n) i := by
  simp only [foldlAcc]
  simp only [Fin.val_succ, Vector.cons, Vector.getElem_mk, List.getElem_toArray, Fin.foldl_succ,
    List.getElem_cons_succ, add_mul, one_mul,
    Fin.val_zero, List.getElem_cons_zero, zero_mul, add_zero]
  congr
  funext acc j
  rw [constant.localLength_eq (init, x), ←constant.localLength_eq (acc, _) 0]
  ac_rfl

theorem operations_eq :
  (Vector.foldlM circuit init xs).operations n =
    (List.ofFn fun i => (circuit (foldlAcc n xs circuit init i) xs[i.val]).operations (n + i * constant.localLength)).flatten := by
  induction xs using Vector.induct generalizing n init with
  | nil => rfl
  | cons x xs ih =>
    rw [foldlM_cons, bind_operations_eq, ih, List.ofFn_succ, List.flatten_cons]
    simp only [foldlAcc_cons_succ, foldlAcc_zero]
    simp +arith [Vector.cons, add_mul, constant.localLength_eq (init, x)]

variable {prop : Condition F}

lemma forAll_flatten_foldl :
  Operations.forAll n prop (List.ofFn fun (i : Fin m) => (circuit (foldlAcc n xs circuit init i) xs[i.val]).operations (n + i * constant.localLength)).flatten
    ↔ ∀ (i : Fin m), (circuit (foldlAcc n xs circuit init i) xs[i.val]).forAll (n + i * constant.localLength) prop :=
  forAll_flatten_abstract (fun i : Fin m => circuit (foldlAcc n xs circuit init i) xs[i.val]) {
    localLength := constant.localLength
    localLength_eq i n := constant.localLength_eq (_, _) _
  }

theorem forAll_iff {constant : ConstantLength (prod circuit)} :
  (xs.foldlM circuit init).forAll n prop ↔
    ∀ i : Fin m, (circuit (foldlAcc n xs circuit init i) xs[i.val]).forAll (n + i * (circuit init xs[i.val]).localLength) prop := by
  rw [forAll_def, operations_eq, forAll_flatten_foldl, iff_iff_eq]
  congr!
  rw [←constant.localLength_eq (init, _)]

-- specialization to xs := Vector.finRange m
section
variable {env : Environment F} {prop : Condition F} {m : ℕ}
  {Acc : ℕ → Type}
  {circuit : β → Fin m → Circuit F β} {init : β} {constant : ConstantLength (prod circuit)}

theorem forAll_iff_finRange {constant : ConstantLength (prod circuit)} :
  ((Vector.finRange m).foldlM circuit init).forAll n prop ↔
    ∀ i : Fin m, (circuit (foldlAcc n (Vector.finRange m) circuit init i) i)
    |>.forAll (n + i * (circuit init i).localLength) prop := by
  simp only [forAll_iff, Vector.getElem_finRange]
end
-- we can massively simplify the foldlM theory when assuming the body's output is independent of the input

variable [Inhabited β] [Inhabited α] {h_const_out : ConstantOutput fun (t : β × α) => circuit t.1 t.2}

theorem foldlAcc_const_succ (constant : ConstantLength (prod circuit))
  (h_const_out : ConstantOutput fun (t : β × α) => circuit t.1 t.2)
  (i : ℕ) (hi : i + 1 < m) :
  foldlAcc n xs circuit init ⟨ i + 1, hi ⟩ =
    (circuit default xs[i]).output (n + i * (circuit default default).localLength) := by
  simp only [foldlAcc]
  conv => lhs; lhs; intro acc i; rw [h_const_out (acc, _),
    ConstantLength.length_eq_default constant (acc, _)]
  rw [h_const_out (_, xs[i])]
  simp only [prod, Fin.foldl_const, Fin.val_last]
  rfl

theorem foldlAcc_const (constant : ConstantLength (prod circuit))
  (h_const_out : ConstantOutput fun (t : β × α) => circuit t.1 t.2)
  (i : ℕ) (hi : i < m) :
  foldlAcc n xs circuit init ⟨ i, hi ⟩ = match i with
    | 0 => init
    | i + 1 => (circuit default xs[i]).output (n + i * (circuit default default).localLength) := by
  rcases i with _ | i
  · simp [foldlAcc]
  · rw [foldlAcc_const_succ constant h_const_out]

theorem operations_eq_const [NeZero m] (constant : ConstantLength (prod circuit))
    (h_const_out : ConstantOutput (prod circuit)) :
  (Vector.foldlM circuit init xs).operations n =
  (circuit init (xs[0]'(NeZero.pos m))).operations n ++
  (List.ofFn fun (⟨i, _⟩ : Fin (m - 1)) =>
    let k := (circuit default default).localLength
    let acc := (circuit default xs[i]).output (n + i*k)
    (circuit acc xs[i + 1]).operations (n + (i + 1)*k)).flatten := by
  rw [operations_eq]
  simp only
  set k := (circuit default default).localLength
  set k' := constant.localLength
  have : k' = k := by simp only [k]; rw [constant.localLength_eq (_, _)]
  rw [this]
  rcases m with rfl | m
  · nomatch ‹NeZero 0›
  rw [List.ofFn_succ, List.flatten_cons]
  simp only [foldlAcc_zero, Fin.val_zero, zero_mul, add_zero, Fin.val_succ, add_mul, one_mul,
    add_tsub_cancel_right, Nat.add_one_sub_one, Fin.cast_eq_self, List.append_cancel_left_eq]
  congr
  funext i
  rcases i with ⟨ i, hi ⟩
  simp only [Fin.succ_mk]
  rw [foldlAcc_const_succ constant h_const_out]

theorem forAll_iff_const [NeZero m] (constant : ConstantLength (prod circuit))
    (h_const_out : ConstantOutput (prod circuit)) :
  (xs.foldlM circuit init).forAll n prop ↔
  (circuit init (xs[0]'(NeZero.pos m))).forAll n prop ∧
  ∀ (i : ℕ) (hi : i + 1 < m),
    let acc := (circuit default xs[i]).output (n + i*(circuit default default).localLength);
    (circuit acc xs[i + 1]).forAll (n + (i + 1)*(circuit default default).localLength) prop := by
  rw [forAll_iff (constant:=constant)]
  set k := (circuit default default).localLength
  simp only
  constructor
  · intro h
    constructor
    · specialize h 0
      simp only [Fin.val_zero] at h
      rw [foldlAcc_zero, zero_mul, add_zero] at h
      exact h
    · intro i hi
      specialize h ⟨ i + 1, hi ⟩
      rw [foldlAcc_const_succ constant h_const_out] at h
      convert h using 3
      rw [ConstantLength.length_eq_default constant (init, _)]
      rfl
  intro h i
  rcases i with ⟨ _ | i, hi ⟩
  · simp only [Fin.mk_zero']
    rw [foldlAcc_zero, zero_mul, add_zero]
    exact h.left
  · rw [foldlAcc_const_succ constant h_const_out]
    convert (h.right i hi) using 3
    rw [ConstantLength.length_eq_default constant (init, _)]
    rfl

end FoldlM

def forEach {m : ℕ} (xs : Vector α m) [Inhabited α] (body : α → Circuit F Unit)
    (_constant : ConstantLength body := by infer_constant_length) : Circuit F Unit :=
  xs.forM body

@[circuit_norm]
theorem forEach_cons {m : ℕ} (x : α) (xs : Vector α m) [Inhabited α] (body : α → Circuit F Unit)
    (constant : ConstantLength body) :
    forEach (Vector.cons x xs) body constant = body x *> forEach xs body constant := by
  unfold forEach
  rw [Vector.forM_toList, Vector.cons, Vector.toList_mk, List.forM_cons]
  rw [←Vector.forM_toList]
  rfl

def map {m : ℕ} (xs : Vector α m) (body : α → Circuit F β)
    (_constant : ConstantLength body := by infer_constant_length) : Circuit F (Vector β m) :=
  xs.mapM body

def mapFinRange (m : ℕ) [NeZero m] (body : Fin m → Circuit F β)
    (_constant : ConstantLength body := by infer_constant_length) : Circuit F (Vector β m) :=
  Vector.mapFinRangeM m body

def foldl {m : ℕ} [Inhabited β] [Inhabited α] (xs : Vector α m) (init : β) (body : β → α → Circuit F β)
  (_const_out : ConstantOutput (fun (s, a) => body s a) := by
    simp only [circuit_norm]
    intros
    rfl)
  (_constant : ConstantLength (fun (s, a) => body s a) := by infer_constant_length)
   : Circuit F β :=
  xs.foldlM body init

def foldlRange (m : ℕ) [Inhabited β] (init : β) (body : β → Fin m → Circuit F β)
  (_constant : ConstantLength (fun (s, a) => body s a) := by
    apply Circuit.ConstantLength.fromConstantLength'
    try simp only [circuit_norm]
    try intros
    try ac_rfl) : Circuit F β :=
  (Vector.finRange m).foldlM body init

section forEach
variable {env : Environment F} {m n : ℕ} [Inhabited α] {xs : Vector α m}
  {body : α → Circuit F Unit} {constant : ConstantLength body} {prop : Condition F}

@[circuit_norm ↓]
lemma forEach.localLength_eq :
    (forEach xs body constant).localLength n = m * (body default).localLength := by
  rw [forEach, ForM.localLength_eq, constant.localLength_eq]

@[circuit_norm ↓]
lemma forEach.output_eq :
  (forEach xs body constant).output n = () := rfl

@[circuit_norm ↓]
lemma forEach.forAll :
  Operations.forAll n prop ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, (body xs[i.val] |>.forAll (n + i*(body default).localLength) prop) := by
  simp only [forEach, ←forAll_def]
  rw [ForM.forAll_iff, ConstantLength.localLength_eq]

@[circuit_norm ↓]
lemma forEach.soundness :
  ConstraintsHold.Soundness env ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, ConstraintsHold.Soundness env (body xs[i.val] |>.operations (n + i*(body default).localLength)) := by
  simp only [forEach, ConstraintsHold.soundness_iff_forAll']
  rw [ForM.forAll_iff, ConstantLength.localLength_eq]

/-- variant of `forEach.soundness`, for when the constraints don't depend on the input offset -/
lemma forEach.soundness' :
  ConstraintsHold.Soundness env (forEach xs body constant |>.operations n) →
    ∀ x ∈ xs, ∃ k : ℕ, ConstraintsHold.Soundness env (body x |>.operations k) := by
  simp only [forEach, ConstraintsHold.soundness_iff_forAll', ForM.forAll_iff]
  intro h x hx
  obtain ⟨i, hi, rfl⟩ := Vector.getElem_of_mem hx
  exact ⟨ _ , h ⟨i, hi⟩ ⟩

@[circuit_norm ↓]
lemma forEach.completeness :
  ConstraintsHold.Completeness env ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, ConstraintsHold.Completeness env (body xs[i.val] |>.operations (n + i*(body default).localLength)) := by
  simp only [forEach, ConstraintsHold.completeness_iff_forAll']
  rw [ForM.forAll_iff, ConstantLength.localLength_eq]

@[circuit_norm ↓]
lemma forEach.usesLocalWitnesses :
  env.UsesLocalWitnessesCompleteness n ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, env.UsesLocalWitnessesCompleteness (n + i*(body default).localLength) (body xs[i.val] |>.operations (n + i*(body default).localLength)) := by
  simp only [forEach, env.usesLocalWitnessesCompleteness_iff_forAll, ←forAll_def]
  rw [ForM.forAll_iff, ConstantLength.localLength_eq]
end forEach

section map
variable {env : Environment F} {m n : ℕ} [Inhabited α] {xs : Vector α m}
  {body : α → Circuit F β} {constant : ConstantLength body} {prop : Condition F}

@[circuit_norm ↓]
lemma map.localLength_eq :
    (map xs body constant).localLength n = m * (body default).localLength := by
  rw [map, MapM.localLength_eq, constant.localLength_eq]

@[circuit_norm ↓]
lemma map.output_eq :
  (map xs body constant).output n =
    xs.mapIdx fun i x => (body x).output (n + i*(body default).localLength) := by
  rw [map, MapM.output_eq, ConstantLength.localLength_eq]

@[circuit_norm ↓]
lemma map.forAll :
  Operations.forAll n prop (map xs body constant |>.operations n) ↔
    ∀ i : Fin m, (body xs[i.val] |>.forAll (n + i*(body default).localLength) prop) := by
  simp only [map, ←forAll_def]
  rw [MapM.forAll_iff, ConstantLength.localLength_eq]

@[circuit_norm ↓]
lemma map.soundness :
  ConstraintsHold.Soundness env (map xs body constant |>.operations n) ↔
    ∀ i : Fin m, ConstraintsHold.Soundness env (body xs[i.val] |>.operations (n + i*(body default).localLength)) := by
  simp only [map, ConstraintsHold.soundness_iff_forAll']
  rw [MapM.forAll_iff, ConstantLength.localLength_eq]

@[circuit_norm ↓]
lemma map.completeness :
  ConstraintsHold.Completeness env (map xs body constant |>.operations n) ↔
    ∀ i : Fin m, ConstraintsHold.Completeness env (body xs[i.val] |>.operations (n + i*(body default).localLength)) := by
  simp only [map, ConstraintsHold.completeness_iff_forAll']
  rw [MapM.forAll_iff, ConstantLength.localLength_eq]

@[circuit_norm ↓]
lemma map.usesLocalWitnesses :
  env.UsesLocalWitnessesCompleteness n (map xs body constant |>.operations n) ↔
    ∀ i : Fin m, env.UsesLocalWitnessesCompleteness (n + i*(body default).localLength) (body xs[i.val] |>.operations (n + i*(body default).localLength)) := by
  simp only [map, env.usesLocalWitnessesCompleteness_iff_forAll, ←forAll_def]
  rw [MapM.forAll_iff, ConstantLength.localLength_eq]
end map

section mapFinRange
variable {env : Environment F} {m n : ℕ} [NeZero m] {body : Fin m → Circuit F β}
  {constant : ConstantLength body} {prop : Condition F}

@[circuit_norm ↓]
lemma mapFinRange.localLength_eq :
    (mapFinRange m body constant).localLength n = m * (body 0).localLength := by
  rw [mapFinRange, Vector.mapFinRangeM, MapM.localLength_eq, constant.localLength_eq]

@[circuit_norm ↓]
lemma mapFinRange.output_eq :
  (mapFinRange m body constant).output n =
    Vector.mapFinRange m fun i => (body i).output (n + i*(body 0).localLength) := by
  rw [mapFinRange, Vector.mapFinRangeM, MapM.output_eq, ConstantLength.localLength_eq]
  ext i hi
  rw [Vector.getElem_mapIdx, Vector.getElem_finRange, Vector.getElem_mapFinRange]

@[circuit_norm ↓]
lemma mapFinRange.forAll :
  Operations.forAll n prop (mapFinRange m body constant |>.operations n) ↔
    ∀ i : Fin m, (body i |>.forAll (n + i*(body 0).localLength) prop) := by
  simp only [mapFinRange, ←forAll_def]
  rw [MapM.mapFinRangeM_forAll_iff, ConstantLength.localLength_eq]

@[circuit_norm ↓]
lemma mapFinRange.soundness :
  ConstraintsHold.Soundness env (mapFinRange m body constant |>.operations n) ↔
    ∀ i : Fin m, ConstraintsHold.Soundness env (body i |>.operations (n + i*(body 0).localLength)) := by
  simp only [mapFinRange, ConstraintsHold.soundness_iff_forAll']
  rw [MapM.mapFinRangeM_forAll_iff, ConstantLength.localLength_eq]

@[circuit_norm ↓]
lemma mapFinRange.completeness :
  ConstraintsHold.Completeness env (mapFinRange m body constant |>.operations n) ↔
    ∀ i : Fin m, ConstraintsHold.Completeness env (body i |>.operations (n + i*(body 0).localLength)) := by
  simp only [mapFinRange, ConstraintsHold.completeness_iff_forAll']
  rw [MapM.mapFinRangeM_forAll_iff, ConstantLength.localLength_eq]

@[circuit_norm ↓]
lemma mapFinRange.usesLocalWitnesses :
  env.UsesLocalWitnessesCompleteness n (mapFinRange m body constant |>.operations n) ↔
    ∀ i : Fin m, env.UsesLocalWitnessesCompleteness (n + i*(body 0).localLength) (body i |>.operations (n + i*(body 0).localLength)) := by
  simp only [mapFinRange, env.usesLocalWitnessesCompleteness_iff_forAll, ←forAll_def]
  rw [MapM.mapFinRangeM_forAll_iff, ConstantLength.localLength_eq]
end mapFinRange

section foldl
variable {env : Environment F} {m n : ℕ} [Inhabited β] [Inhabited α] {xs : Vector α m}
  {body : β → α → Circuit F β} {init : β} {constant : ConstantLength fun (t : β × α) => body t.1 t.2}
  {const_out : ConstantOutput (fun (t : β × α) => body t.1 t.2)}

@[circuit_norm ↓]
lemma foldl.localLength_eq :
    (foldl xs init body const_out constant).localLength n = m * (body default default).localLength := by
  rw [foldl, FoldlM.localLength_eq, constant.localLength_eq (_, _)]

@[circuit_norm ↓]
lemma foldl.output_eq [NeZero m] :
  (foldl xs init body const_out constant).output n =
    (body default (xs[m-1]'(Nat.pred_lt (NeZero.ne m)))).output (n + (m-1)*(body default default).localLength) := by
  rw [foldl, FoldlM.output_eq]
  unfold FoldlM.prod
  rw [constant.localLength_eq (default, default) 0]
  set k := constant.localLength
  have : m-1 < m := Nat.pred_lt (NeZero.ne m)
  rw [const_out (_, xs[m-1])]
  conv => lhs; lhs; intro acc i; rw [const_out (acc, _)]
  rcases m with _ | m
  · nomatch this
  simp only [Fin.foldl_const, Fin.val_last, add_tsub_cancel_right]

@[circuit_norm ↓]
lemma foldl.forAll [NeZero m] :
  Operations.forAll n prop (foldl xs init body const_out constant |>.operations n) ↔
    (body init (xs[0]'(NeZero.pos m)) |>.forAll n prop) ∧
    ∀ (i : ℕ) (hi : i + 1 < m),
      let k := (body default default).localLength;
      let acc := (body default xs[i]).output (n + i*k);
      (body acc xs[i + 1]).forAll (n + (i + 1)*k) prop := by
  simp only [foldl, ←forAll_def]
  rw [FoldlM.forAll_iff_const constant const_out]

@[circuit_norm ↓]
lemma foldl.soundness [NeZero m] :
  ConstraintsHold.Soundness env (foldl xs init body const_out constant |>.operations n) ↔
    ConstraintsHold.Soundness env (body init (xs[0]'(NeZero.pos m)) |>.operations n) ∧
    ∀ (i : ℕ) (hi : i + 1 < m),
      let acc := (body default xs[i]).output (n + i*(body default default).localLength);
      ConstraintsHold.Soundness env (body acc xs[i + 1] |>.operations (n + (i + 1)*(body default default).localLength)) := by
  simp only [foldl, ConstraintsHold.soundness_iff_forAll']
  rw [FoldlM.forAll_iff_const constant const_out]

@[circuit_norm ↓]
lemma foldl.completeness [NeZero m] :
  ConstraintsHold.Completeness env (foldl xs init body const_out constant |>.operations n) ↔
    ConstraintsHold.Completeness env (body init (xs[0]'(NeZero.pos m)) |>.operations n) ∧
    ∀ (i : ℕ) (hi : i + 1 < m),
      let acc := (body default xs[i]).output (n + i*(body default default).localLength);
      ConstraintsHold.Completeness env (body acc xs[i + 1] |>.operations (n + (i + 1)*(body default default).localLength)) := by
  simp only [foldl, ConstraintsHold.completeness_iff_forAll']
  rw [FoldlM.forAll_iff_const constant const_out]

@[circuit_norm ↓]
lemma foldl.usesLocalWitnesses [NeZero m] :
  env.UsesLocalWitnessesCompleteness n (foldl xs init body const_out constant |>.operations n) ↔
    env.UsesLocalWitnessesCompleteness n (body init (xs[0]'(NeZero.pos m)) |>.operations n) ∧
    ∀ (i : ℕ) (hi : i + 1 < m),
      let k := (body default default).localLength;
      let acc := (body default xs[i]).output (n + i*k);
      env.UsesLocalWitnessesCompleteness (n + (i + 1)*k) (body acc xs[i + 1] |>.operations (n + (i + 1)*k)) := by
  simp only [foldl, env.usesLocalWitnessesCompleteness_iff_forAll, ←forAll_def]
  rw [FoldlM.forAll_iff_const constant const_out]
end foldl

section foldlRange
variable {env : Environment F} {m n : ℕ} [Inhabited β]
  {body : β → Fin m → Circuit F β} {init : β} {constant : ConstantLength fun (t : β × Fin m) => body t.1 t.2}

@[circuit_norm ↓]
lemma foldlRange.localLength_eq :
    (foldlRange m init body constant).localLength n =
      if h : m > 0 then m * (body default ⟨0, h⟩).localLength else 0 := by
  rw [foldlRange, FoldlM.localLength_eq (constant:=constant)]
  rcases m with rfl | m; simp
  have : m + 1 > 0 := by omega
  simp only [this, ↓reduceDIte]
  rw [constant.localLength_eq (_, _)]

@[circuit_norm ↓]
lemma foldlRange.output_eq :
  (foldlRange m init body constant).output n =
    Fin.foldl m (fun acc i => (body acc i).output (n + i*(body default i).localLength)) init := by
  rw [foldlRange, FoldlM.output_eq (constant:=constant)]
  simp only [Vector.getElem_finRange, Fin.eta]
  congr! 6
  rw [constant.localLength_eq (_, _)]

@[circuit_norm ↓]
lemma foldlRange.forAll :
  Operations.forAll n prop (foldlRange m init body constant |>.operations n) ↔
    ∀ i : Fin m,
      body (FoldlM.foldlAcc n (Vector.finRange m) body init i) i
      |>.forAll (n + i * (body default i).localLength) prop := by
  simp only [foldlRange, ←forAll_def]
  rw [FoldlM.forAll_iff_finRange (constant:=constant)]
  congr! 4
  rw [constant.localLength_eq (_, _), constant.localLength_eq (_, _)]

@[circuit_norm ↓]
lemma foldlRange.soundness :
  ConstraintsHold.Soundness env (foldlRange m init body constant |>.operations n) ↔
    ∀ i : Fin m,
    ConstraintsHold.Soundness env (body (FoldlM.foldlAcc n (Vector.finRange m) body init i) i
    |>.operations (n + i * (body default i).localLength)) := by
  simp only [ConstraintsHold.soundness_iff_forAll', foldlRange.forAll]

@[circuit_norm ↓]
lemma foldlRange.completeness :
  ConstraintsHold.Completeness env (foldlRange m init body constant |>.operations n) ↔
    ∀ i : Fin m,
    ConstraintsHold.Completeness env (body (FoldlM.foldlAcc n (Vector.finRange m) body init i) i
    |>.operations (n + i * (body default i).localLength)) := by
  simp only [ConstraintsHold.completeness_iff_forAll', foldlRange.forAll]

@[circuit_norm ↓]
lemma foldlRange.usesLocalWitnesses :
  env.UsesLocalWitnessesCompleteness n (foldlRange m init body constant |>.operations n) ↔
    ∀ i : Fin m,
      env.UsesLocalWitnessesCompleteness (n + i * (body default i).localLength) (body (FoldlM.foldlAcc n (Vector.finRange m) body init i) i
      |>.operations (n + i * (body default i).localLength)) := by
  simp only [env.usesLocalWitnessesCompleteness_iff_forAll, foldlRange.forAll]

end foldlRange

theorem collectAdds_forEach {m : ℕ} (xs : Vector α m) [Inhabited α] (body : α → Circuit F Unit)
    (constant : ConstantLength body) (env : Environment F) (offset : ℕ)
    (h_body : ∀ x n, Operations.collectAdds env ((body x) n).2 = 0) :
    Operations.collectAdds env ((forEach xs body constant) offset).2 = 0 := by
  induction xs using Vector.induct generalizing offset
  · rfl
  case cons n a as ih =>
    simp only [circuit_norm, Operations.collectAdds_append]
    rw [h_body, ih]
    rfl

/-- General version of collectAdds_forEach that relates forEach to Finset.sum via toFinsupp.
    Each step's collectAdds equals the corresponding localAdds_fn applied to that element. -/
theorem collectAdds_forEach_sum [DecidableEq F] {m : ℕ} (xs : Vector α m) [Inhabited α]
    (body : α → Circuit F Unit)
    (constant : ConstantLength body) (env : Environment F) (offset : ℕ)
    (localAdds_fn : α → InteractionDelta F)
    (h_body : ∀ x n, Operations.collectAdds env ((body x) n).2 = localAdds_fn x) :
    (Operations.collectAdds env ((forEach xs body constant) offset).2).toFinsupp =
    ∑ i : Fin m, (localAdds_fn xs[i]).toFinsupp := by
  induction xs using Vector.induct generalizing offset
  case nil =>
    simp only [Finset.univ_eq_empty, Finset.sum_empty]
    rfl
  case cons n a as ih =>
    simp only [circuit_norm, Operations.collectAdds_append]
    rw [← InteractionDelta.add_eq_append, InteractionDelta.toFinsupp_add, h_body, ih]
    rw [Fin.sum_univ_succ]
    congr 1

/-- Version of collectAdds_forEach_sum using toFinsupp equality for h_body.
    This is useful when the body's localAdds_eq gives toFinsupp equality. -/
theorem collectAdds_forEach_sum' [DecidableEq F] {m : ℕ} (xs : Vector α m) [Inhabited α]
    (body : α → Circuit F Unit)
    (constant : ConstantLength body) (env : Environment F) (offset : ℕ)
    (localAdds_fn : α → InteractionDelta F)
    (h_body : ∀ x n, (Operations.collectAdds env ((body x) n).2).toFinsupp = (localAdds_fn x).toFinsupp) :
    (Operations.collectAdds env ((forEach xs body constant) offset).2).toFinsupp =
    ∑ i : Fin m, (localAdds_fn xs[i]).toFinsupp := by
  induction xs using Vector.induct generalizing offset
  case nil =>
    simp only [Finset.univ_eq_empty, Finset.sum_empty]
    rfl
  case cons n a as ih =>
    simp only [circuit_norm, Operations.collectAdds_append]
    rw [← InteractionDelta.add_eq_append, InteractionDelta.toFinsupp_add, h_body, ih]
    rw [Fin.sum_univ_succ]
    congr 1

/-- Relates collectAdds of forEach to a foldl over finRange.
    This is useful for proving Bundle.localAdds_eq where localAdds is defined via foldl. -/
theorem collectAdds_forEach_foldl {m : ℕ} (xs : Vector α m) [Inhabited α]
    (body : α → Circuit F Unit) (constant : ConstantLength body)
    (env : Environment F) (offset : ℕ) :
    Operations.collectAdds env ((forEach xs body constant) offset).2 =
    (List.finRange m).foldl (fun acc (i : Fin m) =>
      acc + Operations.collectAdds env ((body xs[i]) (offset + i * constant.localLength)).2) 0 := by
  induction xs using Vector.induct generalizing offset
  case nil => rfl
  case cons n a as ih =>
    simp only [circuit_norm, Operations.collectAdds_append]
    have h_len : Operations.localLength (body a offset).2 = constant.localLength := constant.localLength_eq a offset
    rw [h_len, ih]
    simp only [List.finRange_succ, List.foldl_cons, List.foldl_map, List.nil_append]
    set k := constant.localLength
    simp only [Fin.val_zero, zero_mul, add_zero]
    simp only [Vector.cons, Vector.getElem_mk, List.getElem_toArray, List.getElem_cons_zero]
    -- Goal: collectAdds(body a) ++ foldl(...offset+k+i*k...) 0 = foldl(...offset+i.succ*k...)(collectAdds(body a))
    -- Note: (a::as)[i.succ] = as[i] and offset+k+i*k = offset+i.succ*k
    -- First, show both foldl functions compute the same on each step
    have h_fun_eq : (fun acc (i : Fin n) => acc + Operations.collectAdds env (body as[↑i] (offset + k + ↑i * k)).2) =
                    (fun acc (i : Fin n) => acc + Operations.collectAdds env (body (a :: as.toList)[↑(Fin.succ i)] (offset + ↑(Fin.succ i) * k)).2) := by
      funext acc i
      -- Show: as[i] = (a :: as.toList)[i+1] and offset + k + i*k = offset + (i+1)*k
      -- Use: (a :: as.toList)[i+1] = as.toList[i] = as[i]
      -- Goal: acc + collectAdds(body as[i] (off + k + i*k)).2 = acc + collectAdds(body (a::as.toList)[i.succ] (off + i.succ*k)).2
      -- 1. Show (a :: as.toList)[i.succ] = as[i]
      -- 2. Show off + k + i*k = off + i.succ*k
      have h1 : (a :: as.toList)[(i.succ : Fin (n+1))] = as[i] := by
        show (a :: as.toList)[i.succ.val] = as[i.val]
        simp only [Fin.val_succ, List.getElem_cons_succ, Vector.getElem_toList]
      have h2 : offset + k + ↑i * k = offset + (↑i + 1) * k := by ring
      simp only [h1, h2, Fin.val_succ]
    rw [h_fun_eq]
    -- Now: init ++ foldl f 0 xs = foldl f init xs for init = collectAdds(body a)
    set f := fun acc (i : Fin n) => acc + Operations.collectAdds env (body (a :: as.toList)[↑(Fin.succ i)] (offset + ↑(Fin.succ i) * k)).2
    have h_foldl : ∀ (init : InteractionDelta F) (xs : List (Fin n)),
        init ++ xs.foldl f 0 = xs.foldl f init := by
      intro init xs
      induction xs generalizing init with
      | nil => simp only [List.foldl_nil, InteractionDelta.zero_eq_nil, List.append_nil]
      | cons y ys ih_inner =>
        simp only [List.foldl_cons]
        -- Goal: init ++ foldl f (f 0 y) ys = foldl f (f init y) ys
        -- By ih_inner: foldl f (f 0 y) ys = (f 0 y) ++ foldl f 0 ys
        -- and: foldl f (f init y) ys = (f init y) ++ foldl f 0 ys
        rw [← ih_inner (f 0 y), ← ih_inner (f init y)]
        -- Now: init ++ ((f 0 y) ++ foldl f 0 ys) = (f init y) ++ foldl f 0 ys
        -- Expand f: f 0 y = 0 + collectAdds y, f init y = init + collectAdds y
        show init ++ ((0 + _) ++ _) = (init + _) ++ _
        rw [InteractionDelta.zero_add', InteractionDelta.add_eq_append, List.append_assoc]
    exact h_foldl _ _

theorem collectAdds_map {m : ℕ} (xs : Vector α m) (body : α → Circuit F β)
    (constant : ConstantLength body) (env : Environment F) (offset : ℕ)
    (h_body : ∀ x n, ((body x).operations n).collectAdds env = 0) :
    ((map xs body constant).operations offset).collectAdds env = 0 := by
  unfold map
  induction xs using Vector.induct generalizing offset
  case nil =>
    simp [Circuit.operations, Circuit.pure_operations_eq, Operations.collectAdds]
  case cons x xs ih =>
    simp only [MapM.mapM_cons, Circuit.bind_operations_eq, Circuit.pure_operations_eq]
    rw [Operations.collectAdds_append, Operations.collectAdds_append]
    simp only [Operations.collectAdds, h_body, InteractionDelta.add_zero', ih]

theorem collectAdds_mapFinRange (m : ℕ) [NeZero m] (body : Fin m → Circuit F β)
    (constant : ConstantLength body) (env : Environment F) (offset : ℕ)
    (h_body : ∀ i n, ((body i).operations n).collectAdds env = 0) :
    ((mapFinRange m body constant).operations offset).collectAdds env = 0 := by
  unfold mapFinRange Vector.mapFinRangeM
  exact collectAdds_map (Vector.finRange m) body constant env offset h_body

theorem collectAdds_foldl [Inhabited β] [Inhabited α] {m : ℕ} (xs : Vector α m)
    (init : β) (body : β → α → Circuit F β)
    (const_out : ConstantOutput (fun (s, a) => body s a))
    (constant : ConstantLength (fun (s, a) => body s a))
    (env : Environment F) (offset : ℕ)
    (h_body : ∀ s x n, ((body s x).operations n).collectAdds env = 0) :
    ((foldl xs init body const_out constant).operations offset).collectAdds env = 0 := by
  induction xs using Vector.induct generalizing offset init
  case nil =>
    simp only [foldl]
    rw [Vector.foldlM_toList, Vector.toList_mk, List.foldlM_nil]
    simp only [pure_operations_eq, Operations.collectAdds]
  case cons x xs ih =>
    simp only [foldl]
    rw [Vector.foldlM_toList, Vector.cons, Vector.toList_mk, List.foldlM_cons]
    simp only [Circuit.bind_operations_eq, Operations.collectAdds_append]
    rw [h_body, InteractionDelta.zero_add', ←Vector.foldlM_toList]
    exact ih _ _

theorem collectAdds_foldlRange [Inhabited β] {m : ℕ} [inst : Inhabited (Fin m)]
    (init : β) (body : β → Fin m → Circuit F β)
    (const_out : ConstantOutput (fun (s, a) => body s a))
    (constant : ConstantLength (fun (s, a) => body s a))
    (env : Environment F) (offset : ℕ)
    (h_body : ∀ s i n, ((body s i).operations n).collectAdds env = 0) :
    ((foldlRange m init body constant).operations offset).collectAdds env = 0 := by
  unfold foldlRange
  exact collectAdds_foldl (Vector.finRange m) init body const_out constant env offset h_body

/-- Version of collectAdds_foldlRange that works for all m including 0. -/
theorem collectAdds_foldlRange' [Inhabited β] {m : ℕ}
    (init : β) (body : β → Fin m → Circuit F β)
    (constant : ConstantLength (fun (s, a) => body s a))
    (env : Environment F) (offset : ℕ)
    (h_body : ∀ s i n, ((body s i).operations n).collectAdds env = 0) :
    ((foldlRange m init body constant).operations offset).collectAdds env = 0 := by
  simp only [foldlRange]
  rw [Vector.foldlM_toList]
  induction (Vector.finRange m).toList generalizing offset init with
  | nil => simp only [List.foldlM_nil, pure_operations_eq, Operations.collectAdds]
  | cons x xs ih =>
    simp only [List.foldlM_cons, Circuit.bind_operations_eq, Operations.collectAdds_append]
    rw [h_body, InteractionDelta.zero_add']
    exact ih ((body init x).output offset) (offset + (body init x).localLength offset)

end Circuit
