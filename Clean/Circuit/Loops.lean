/-
This file proves some properties about `forM`, `mapM`, and `foldlM` monad loops when used in a `Circuit`,
typically leveraging a `ConstantCircuits` assumption on the loop body.

The end result are loop methods `Circuit.{mapFinRange, map, forEach, foldl}` that simplify
under `circuit_norm` in every way we need them to.
-/
import Clean.Circuit.Constant
import Clean.Utils.Misc
variable {n m : ℕ} {F : Type} [Field F] {α β : Type}

lemma Vector.forM_toList (xs : Vector α n) {m : Type → Type} [Monad m] (body : α → m Unit) :
    xs.forM body = forM xs.toList body := by
  rw [Vector.forM_eq_forM, Vector.forM_mk, List.forM_toArray, List.forM_eq_forM]

lemma Vector.mapM_toList (xs : Vector α n) {m : Type → Type} [monad: Monad m] [LawfulMonad m] (body : α → m β) :
    (fun v => v.toArray.toList) <$> (xs.mapM body) = xs.toList.mapM body := by
  rw [←Array.toList_mapM, ←Vector.toArray_mapM, Functor.map_map]

lemma Vector.foldlM_toList (xs : Vector α n) {m : Type → Type} [Monad m] (body : β → α → m β) (init : β) :
    xs.foldlM body init = xs.toList.foldlM body init := by
  rw [Vector.foldlM_mk, List.foldlM_toArray]
namespace Circuit
variable {prop : Condition F}

-- helper lemmas to characterize `forAll` statements on the operations generated by loops

lemma forAll_flatten_abstract (circuit : Fin m → Circuit F β) (constant : ConstantCircuits circuit) :
  Operations.forAll n prop (List.ofFn fun i => (circuit i).operations (n + i * constant.local_length)).flatten
    ↔ ∀ (i : Fin m), (circuit i).forAll (n + i * constant.local_length) prop := by
  induction m generalizing n
  case zero => simp [Operations.forAll]
  case succ m ih =>
    rw [List.ofFn_succ, List.flatten_cons, Operations.forAll_append, Fin.forall_fin_succ, Circuit.forAll_def]
    simp only [Fin.val_zero, zero_mul, add_zero, Fin.val_succ]
    let circuit' := fun i : Fin m => circuit i.succ
    let constant' : ConstantCircuits circuit' := {
      local_length := constant.local_length
      local_length_eq a n := constant.local_length_eq (a.succ) n }
    set k := constant.local_length
    specialize ih (n := n + k) circuit' constant'
    set k' := constant'.local_length
    have : k' = k := rfl
    rw [this] at ih
    have : ((circuit 0).operations n).local_length + n = n + constant.local_length := by
      rw [←constant.local_length_eq 0 n]; ac_rfl
    rw [this]
    ring_nf at ih ⊢
    rw [ih]

lemma forAll_flatten (xs : Vector α m) {circuit : α → Circuit F β} (constant : ConstantCircuits circuit) :
  Operations.forAll n prop (List.ofFn fun (i : Fin m) => (circuit xs[i.val]).operations (n + i * constant.local_length)).flatten
    ↔ ∀ (i : Fin m), (circuit xs[i.val]).forAll (n + i * constant.local_length) prop :=
  forAll_flatten_abstract (fun i : Fin m => circuit xs[i.val]) {
    local_length := constant.local_length
    local_length_eq _ _ := constant.local_length_eq .. }

-- helper lemma to do induction on (List.ofFn ...).flatten terms
private lemma ofFn_flatten_cons {circuit : α → Circuit F β} (constant : ConstantCircuits circuit) (x : α) (xs : Vector α m) (n : ℕ) :
  (List.ofFn fun i => (circuit (Vector.cons x xs)[i.val]).operations (n + i * constant.local_length)).flatten
    = (circuit x).operations n ++ (List.ofFn fun i => (circuit xs[i.val]).operations (n + constant.local_length + i * constant.local_length)).flatten := by
  simp +arith [Vector.cons, add_mul]

namespace ForM
variable {circuit : α → Circuit F Unit} (xs : Vector α m) (constant : ConstantCircuits circuit) (n : ℕ)

theorem local_length_eq : (xs.forM circuit).local_length n = m * constant.local_length := by
  set k := constant.local_length
  induction xs using Vector.induct generalizing n
  case nil => ac_rfl
  case cons x xs ih =>
    rw [Vector.forM_toList, Vector.cons, List.forM_cons, ←Vector.forM_toList,
      bind_local_length_eq, ih, constant.local_length_eq]
    ring

theorem output_eq : (xs.forM circuit).output n = () := rfl

theorem operations_eq :
  (xs.forM circuit).operations n =
    (List.ofFn fun (i : Fin m) => (circuit xs[i.val]).operations (n + i * constant.local_length)).flatten := by
  induction xs using Vector.induct generalizing n
  case nil => rfl
  case cons x xs ih =>
    rw [ofFn_flatten_cons, Vector.forM_toList, Vector.cons, List.forM_cons, ←Vector.forM_toList,
      bind_operations_eq, ih, constant.local_length_eq]

theorem forAll_iff {prop : Condition F} :
  (xs.forM circuit).forAll n prop ↔
    ∀ (i : Fin m), (circuit xs[i.val]).forAll (n + i * constant.local_length) prop := by
  rw [forAll_def, operations_eq, forAll_flatten]
end ForM

namespace MapM
variable {circuit : α → Circuit F β} {xs : Vector α m} [constant: ConstantCircuits circuit]
  {prop : Condition F}

theorem local_length_eq : (xs.mapM circuit).local_length n = m * constant.local_length := by
  induction xs using Vector.induct_push
  case nil =>
    rw [Vector.mapM_mk_empty, pure_local_length_eq, zero_mul]
  case push xs x ih =>
    rw [Vector.mapM_push, bind_local_length_eq, bind_local_length_eq, pure_local_length_eq, ih, constant.local_length_eq]
    ring

theorem output_eq : (xs.mapM circuit).output n =
    xs.mapIdx fun i x => (circuit x).output (n + i * constant.local_length) := by
  induction xs using Vector.induct_push
  case nil => simp
  case push xs x ih =>
    rw [Vector.mapM_push, bind_output_eq, bind_output_eq, pure_output_eq, ih, local_length_eq]
    simp

lemma ext_map_toList (f g : Circuit F (Vector α n)) :
    (fun v => v.toArray.toList) <$> f = (fun v => v.toArray.toList) <$> g → f = g := by
  intro h
  rw [ext_iff] at h
  ext1 n
  · replace h := (h n).left
    rw [map_output_eq, map_output_eq] at h
    exact Vector.toList_inj.mp h
  · replace h := (h n).right
    rw [map_operations_eq, map_operations_eq] at h
    exact h

lemma mapM_cons (xs : Vector α n) (body : α → Circuit F β) (x : α) :
  (Vector.cons x xs).mapM body = do
    let y ← body x
    let ys ← xs.mapM body
    return Vector.cons y ys := by
  apply ext_map_toList
  rw [Vector.mapM_toList, Vector.toList_cons, List.mapM_cons, ←Vector.mapM_toList]
  simp only [map_bind, map_pure, Vector.toList_cons]
  rfl

theorem operations_eq : (xs.mapM circuit).operations n =
    (List.ofFn fun (i : Fin m) => (circuit xs[i.val]).operations (n + i * constant.local_length)).flatten := by
  induction xs using Vector.induct generalizing n
  case nil => simp [pure_operations_eq]
  case cons x xs ih =>
    rw [mapM_cons, bind_operations_eq, bind_operations_eq, pure_operations_eq, ih,
      constant.local_length_eq, List.append_nil, ofFn_flatten_cons]

theorem forAll_iff :
  (xs.mapM circuit).forAll n prop ↔
    ∀ (i : Fin m), (circuit xs[i.val]).forAll (n + i * constant.local_length) prop := by
  rw [forAll_def, operations_eq, forAll_flatten]

-- specialization to mapFinRangeM
theorem mapFinRangeM_forAll_iff {circuit : Fin m → Circuit F β} [constant : ConstantCircuits circuit] :
  (Vector.mapFinRangeM m circuit).forAll n prop ↔
    ∀ i : Fin m, (circuit i).forAll (n + i*constant.local_length) prop := by
  rw [Vector.mapFinRangeM, forAll_iff]
  simp only [Vector.getElem_finRange]
end MapM

namespace FoldlM
@[reducible]
def prod (circuit : β → α → Circuit F β) : β × α → Circuit F β := fun t => circuit t.1 t.2

variable {env : Environment F} {prop : Condition F} {xs : Vector α m}
  {circuit : β → α → Circuit F β} {init : β} {constant : ConstantCircuits (prod circuit)}

lemma foldlM_cons (x: α) :
  (Vector.cons x xs).foldlM circuit init = (do
    let init' ← circuit init x
    xs.foldlM circuit init') := by
  rw [Vector.foldlM_toList, Vector.cons, List.foldlM_cons]
  simp only [←Vector.foldlM_toList]

theorem local_length_eq :
    (xs.foldlM circuit init).local_length n = m * constant.local_length := by
  induction xs using Vector.induct generalizing init n
  case nil => rw [zero_mul]; rfl
  case cons x xs ih =>
    rw [foldlM_cons, bind_local_length_eq, ih, constant.local_length_eq (init, x)]
    ring

lemma finFoldl_cons_succ (x: α) :
  Fin.foldl (m + 1) (fun acc i => (circuit acc (Vector.cons x xs)[i.val]).output (n + i * constant.local_length)) init
    = Fin.foldl m (fun acc i => (circuit acc xs[i.val]).output (n + constant.local_length + i * constant.local_length)) ((circuit init x).output n) := by
  set k := constant.local_length
  rw [Fin.foldl_succ]
  simp only [Fin.val_succ, Fin.val_zero, zero_mul, add_zero]
  congr
  funext acc i
  rw [add_mul, add_assoc, add_comm k]
  simp [Vector.cons]

theorem output_eq :
  (xs.foldlM circuit init).output n =
    Fin.foldl m (fun acc i => (circuit acc xs[i.val]).output (n + i * constant.local_length)) init := by
  induction xs using Vector.induct generalizing init n
  case nil => rfl
  case cons x xs ih =>
    rw [foldlM_cons, bind_output_eq, ih, constant.local_length_eq (init, x), finFoldl_cons_succ]

variable [Inhabited β] [Inhabited α]

def foldlAcc (n : ℕ) (xs : Vector α m) (circuit : β → α → Circuit F β) (init : β) (j : Fin m) : β :=
  Fin.foldl j (fun acc i => (circuit acc xs[i.val]).output (n + i*(circuit default default).local_length)) init

lemma foldlAcc_zero [NeZero m] : foldlAcc n xs circuit init 0 = init := by
  simp [foldlAcc, Fin.foldl_zero]

lemma foldlAcc_cons_succ (i : Fin m) (x : α) [constant : ConstantCircuits (prod circuit)] :
  foldlAcc n (Vector.cons x xs) circuit init i.succ =
    foldlAcc (n + (circuit init x).local_length n) xs circuit ((circuit init x).output n) i := by
  rw [constant.local_length_eq (init, x), ←constant.local_length_eq (default, default) 0]
  simp only [foldlAcc]
  simp only [Fin.val_succ, Vector.cons, Vector.getElem_mk, List.getElem_toArray, Fin.foldl_succ,
    List.getElem_cons_succ, Array.getElem_toList, Vector.getElem_toArray, add_mul, one_mul,
    Fin.val_zero, List.getElem_cons_zero, zero_mul, add_zero]
  ac_rfl

theorem operations_eq :
  (Vector.foldlM circuit init xs).operations n =
    (List.ofFn fun i => (circuit (foldlAcc n xs circuit init i) xs[i.val]).operations (n + i * constant.local_length)).flatten := by
  induction xs using Vector.induct generalizing n init with
  | nil => rfl
  | cons x xs ih =>
    rw [foldlM_cons, bind_operations_eq, ih, List.ofFn_succ, List.flatten_cons]
    simp only [foldlAcc_cons_succ, foldlAcc_zero]
    simp +arith [Vector.cons, add_mul, constant.local_length_eq (init, x)]

variable {prop : Condition F}

lemma forAll_flatten_foldl :
  Operations.forAll n prop (List.ofFn fun (i : Fin m) => (circuit (foldlAcc n xs circuit init i) xs[i.val]).operations (n + i * constant.local_length)).flatten
    ↔ ∀ (i : Fin m), (circuit (foldlAcc n xs circuit init i) xs[i.val]).forAll (n + i * constant.local_length) prop :=
  forAll_flatten_abstract (fun i : Fin m => circuit (foldlAcc n xs circuit init i) xs[i.val]) {
    local_length := constant.local_length
    local_length_eq i n := constant.local_length_eq (_, _) _
  }

theorem forAll_iff {constant : ConstantCircuits (prod circuit)} :
  (xs.foldlM circuit init).forAll n prop ↔
    ∀ i : Fin m, (circuit (foldlAcc n xs circuit init i) xs[i.val]).forAll (n + i * (circuit default default).local_length) prop := by
  rw [forAll_def, operations_eq, forAll_flatten_foldl, constant.local_length_eq (_, _)]

-- we can massively simplify the foldlM theory when assuming the body's output is independent of the input

variable {h_const_out : Circuit.constant_output fun (t : β × α) => circuit t.1 t.2}

theorem foldlAcc_const_succ (h_const_out : Circuit.constant_output fun (t : β × α) => circuit t.1 t.2)
  (i : ℕ) (hi : i + 1 < m) :
  foldlAcc n xs circuit init ⟨ i + 1, hi ⟩ =
    (circuit default xs[i]).output (n + i*(circuit default default).local_length) := by
  simp only [foldlAcc]
  conv => lhs; lhs; intro acc i; rw [h_const_out (acc, _)]
  rw [h_const_out (_, xs[i])]
  simp [Fin.foldl_const]

theorem foldlAcc_const (h_const_out : Circuit.constant_output fun (t : β × α) => circuit t.1 t.2)
  (i : ℕ) (hi : i < m) :
  foldlAcc n xs circuit init ⟨ i, hi ⟩ = match i with
    | 0 => init
    | i + 1 => (circuit default xs[i]).output (n + i * (circuit default default).local_length) := by
  rcases i with _ | i
  · simp [foldlAcc]
  · rw [foldlAcc_const_succ h_const_out]

theorem operations_eq_const [NeZero m] (constant : ConstantCircuits (prod circuit))
    (h_const_out : Circuit.constant_output (prod circuit)) :
  (Vector.foldlM circuit init xs).operations n =
  (circuit init (xs[0]'(NeZero.pos m))).operations n ++
  (List.ofFn fun (⟨i, _⟩ : Fin (m - 1)) =>
    let k := (circuit default default).local_length
    let acc := (circuit default xs[i]).output (n + i*k)
    (circuit acc xs[i + 1]).operations (n + (i + 1)*k)).flatten := by
  rw [operations_eq]
  simp only
  set k := (circuit default default).local_length
  set k' := constant.local_length
  have : k' = k := by simp only [k]; rw [constant.local_length_eq (_, _)]
  rw [this]
  rcases m with rfl | m
  · nomatch ‹NeZero 0›
  rw [List.ofFn_succ, List.flatten_cons]
  simp only [foldlAcc_zero, Fin.val_zero, zero_mul, add_zero, Fin.val_succ, add_mul, one_mul,
    add_tsub_cancel_right, Nat.add_one_sub_one, Fin.cast_eq_self, List.append_cancel_left_eq]
  congr
  funext i
  rcases i with ⟨ i, hi ⟩
  simp only [Fin.succ_mk]
  rw [foldlAcc_const_succ h_const_out]

theorem forAll_iff_const [NeZero m] (constant : ConstantCircuits (prod circuit))
    (h_const_out : Circuit.constant_output (prod circuit)) :
  (xs.foldlM circuit init).forAll n prop ↔
  (circuit init (xs[0]'(NeZero.pos m))).forAll n prop ∧
  ∀ (i : ℕ) (hi : i + 1 < m),
    let acc := (circuit default xs[i]).output (n + i*(circuit default default).local_length);
    (circuit acc xs[i + 1]).forAll (n + (i + 1)*(circuit default default).local_length) prop := by
  rw [forAll_iff (constant:=constant)]
  set k := (circuit default default).local_length
  simp only
  constructor
  · intro h
    constructor
    · specialize h 0
      simp only [Fin.val_zero] at h
      rw [foldlAcc_zero, zero_mul, add_zero] at h
      exact h
    · intro i hi
      specialize h ⟨ i + 1, hi ⟩
      rw [foldlAcc_const_succ h_const_out] at h
      exact h
  intro h i
  rcases i with ⟨ _ | i, hi ⟩
  · simp only [Fin.mk_zero', Fin.val_zero]
    rw [foldlAcc_zero, zero_mul, add_zero]
    exact h.left
  · rw [foldlAcc_const_succ h_const_out]
    exact h.right i hi

end FoldlM

def forEach {m : ℕ} (xs : Vector α m) [Inhabited α] (body : α → Circuit F Unit)
    (_constant : ConstantCircuits body := by infer_constant_circuits) : Circuit F Unit :=
  xs.forM body

def map {m : ℕ} (xs : Vector α m) (body : α → Circuit F β)
    (_constant : ConstantCircuits body := by infer_constant_circuits) : Circuit F (Vector β m) :=
  xs.mapM body

def mapFinRange (m : ℕ) [NeZero m] (body : Fin m → Circuit F β)
    (_constant : ConstantCircuits body := by infer_constant_circuits) : Circuit F (Vector β m) :=
  Vector.mapFinRangeM m body

def foldl {m : ℕ} [Inhabited β] [Inhabited α] (xs : Vector α m) (init : β) (body : β → α → Circuit F β)
  (_const_out : Circuit.constant_output (fun (s, a) => body s a) := by
    simp only [circuit_norm]
    intros
    rfl)
  (_constant : ConstantCircuits (fun (s, a) => body s a) := by infer_constant_circuits)
   : Circuit F β :=
  xs.foldlM body init

section forEach
variable {env : Environment F} {m n : ℕ} [Inhabited α] {xs : Vector α m}
  {body : α → Circuit F Unit} {constant : ConstantCircuits body} {prop : Condition F}

@[circuit_norm ↓]
lemma forEach.local_length_eq :
    (forEach xs body constant).local_length n = m * (body default).local_length := by
  rw [forEach, ForM.local_length_eq, constant.local_length_eq]

@[circuit_norm ↓]
lemma forEach.output_eq :
  (forEach xs body constant).output n = () := rfl

@[circuit_norm ↓]
lemma forEach.forAll :
  Operations.forAll n prop ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, (body xs[i.val] |>.forAll (n + i*(body default).local_length) prop) := by
  simp only [forEach, ←forAll_def]
  rw [ForM.forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma forEach.soundness :
  constraints_hold.soundness env ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, constraints_hold.soundness env (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [forEach, constraints_hold.soundness_iff_forAll']
  rw [ForM.forAll_iff, ConstantCircuits.local_length_eq]

/-- variant of `forEach.soundness`, for when the constraints don't depend on the input offset -/
lemma forEach.soundness' :
  constraints_hold.soundness env (forEach xs body constant |>.operations n) →
    ∀ x ∈ xs, ∃ k : ℕ, constraints_hold.soundness env (body x |>.operations k) := by
  simp only [forEach, constraints_hold.soundness_iff_forAll', ForM.forAll_iff]
  intro h x hx
  obtain ⟨i, hi, rfl⟩ := Vector.getElem_of_mem hx
  exact ⟨ _ , h ⟨i, hi⟩ ⟩

@[circuit_norm ↓]
lemma forEach.completeness :
  constraints_hold.completeness env ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, constraints_hold.completeness env (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [forEach, constraints_hold.completeness_iff_forAll']
  rw [ForM.forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma forEach.usesLocalWitnesses :
  env.uses_local_witnesses_completeness n ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, env.uses_local_witnesses_completeness (n + i*(body default).local_length) (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [forEach, env.usesLocalWitnesses_completeness_iff_forAll, ←forAll_def]
  rw [ForM.forAll_iff, ConstantCircuits.local_length_eq]
end forEach

section map
variable {env : Environment F} {m n : ℕ} [Inhabited α] {xs : Vector α m}
  {body : α → Circuit F β} {constant : ConstantCircuits body} {prop : Condition F}

@[circuit_norm ↓]
lemma map.local_length_eq :
    (map xs body constant).local_length n = m * (body default).local_length := by
  rw [map, MapM.local_length_eq, constant.local_length_eq]

@[circuit_norm ↓]
lemma map.output_eq :
  (map xs body constant).output n =
    xs.mapIdx fun i x => (body x).output (n + i*(body default).local_length) := by
  rw [map, MapM.output_eq, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma map.forAll :
  Operations.forAll n prop (map xs body constant |>.operations n) ↔
    ∀ i : Fin m, (body xs[i.val] |>.forAll (n + i*(body default).local_length) prop) := by
  simp only [map, ←forAll_def]
  rw [MapM.forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma map.soundness :
  constraints_hold.soundness env (map xs body constant |>.operations n) ↔
    ∀ i : Fin m, constraints_hold.soundness env (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [map, constraints_hold.soundness_iff_forAll']
  rw [MapM.forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma map.completeness :
  constraints_hold.completeness env (map xs body constant |>.operations n) ↔
    ∀ i : Fin m, constraints_hold.completeness env (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [map, constraints_hold.completeness_iff_forAll']
  rw [MapM.forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma map.usesLocalWitnesses :
  env.uses_local_witnesses_completeness n (map xs body constant |>.operations n) ↔
    ∀ i : Fin m, env.uses_local_witnesses_completeness (n + i*(body default).local_length) (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [map, env.usesLocalWitnesses_completeness_iff_forAll, ←forAll_def]
  rw [MapM.forAll_iff, ConstantCircuits.local_length_eq]
end map

section mapFinRange
variable {env : Environment F} {m n : ℕ} [NeZero m] {body : Fin m → Circuit F β}
  {constant : ConstantCircuits body} {prop : Condition F}

@[circuit_norm ↓]
lemma mapFinRange.local_length_eq :
    (mapFinRange m body constant).local_length n = m * (body 0).local_length := by
  rw [mapFinRange, Vector.mapFinRangeM, MapM.local_length_eq, constant.local_length_eq]

@[circuit_norm ↓]
lemma mapFinRange.output_eq :
  (mapFinRange m body constant).output n =
    Vector.mapFinRange m fun i => (body i).output (n + i*(body 0).local_length) := by
  rw [mapFinRange, Vector.mapFinRangeM, MapM.output_eq, ConstantCircuits.local_length_eq]
  ext i hi
  rw [Vector.getElem_mapIdx, Vector.getElem_finRange, Vector.getElem_mapFinRange]

@[circuit_norm ↓]
lemma mapFinRange.forAll :
  Operations.forAll n prop (mapFinRange m body constant |>.operations n) ↔
    ∀ i : Fin m, (body i |>.forAll (n + i*(body 0).local_length) prop) := by
  simp only [mapFinRange, ←forAll_def]
  rw [MapM.mapFinRangeM_forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma mapFinRange.soundness :
  constraints_hold.soundness env (mapFinRange m body constant |>.operations n) ↔
    ∀ i : Fin m, constraints_hold.soundness env (body i |>.operations (n + i*(body 0).local_length)) := by
  simp only [mapFinRange, constraints_hold.soundness_iff_forAll']
  rw [MapM.mapFinRangeM_forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma mapFinRange.completeness :
  constraints_hold.completeness env (mapFinRange m body constant |>.operations n) ↔
    ∀ i : Fin m, constraints_hold.completeness env (body i |>.operations (n + i*(body 0).local_length)) := by
  simp only [mapFinRange, constraints_hold.completeness_iff_forAll']
  rw [MapM.mapFinRangeM_forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma mapFinRange.usesLocalWitnesses :
  env.uses_local_witnesses_completeness n (mapFinRange m body constant |>.operations n) ↔
    ∀ i : Fin m, env.uses_local_witnesses_completeness (n + i*(body 0).local_length) (body i |>.operations (n + i*(body 0).local_length)) := by
  simp only [mapFinRange, env.usesLocalWitnesses_completeness_iff_forAll, ←forAll_def]
  rw [MapM.mapFinRangeM_forAll_iff, ConstantCircuits.local_length_eq]
end mapFinRange

section foldl
variable {env : Environment F} {m n : ℕ} [Inhabited β] [Inhabited α] {xs : Vector α m}
  {body : β → α → Circuit F β} {init : β} {constant : ConstantCircuits fun (t : β × α) => body t.1 t.2}
  {const_out : Circuit.constant_output (fun (t : β × α) => body t.1 t.2)}

@[circuit_norm ↓]
lemma foldl.local_length_eq :
    (foldl xs init body const_out constant).local_length n = m * (body default default).local_length := by
  rw [foldl, FoldlM.local_length_eq, constant.local_length_eq (_, _)]

@[circuit_norm ↓]
lemma foldl.output_eq [NeZero m] :
  (foldl xs init body const_out constant).output n =
    (body default (xs[m-1]'(Nat.pred_lt (NeZero.ne m)))).output (n + (m-1)*(body default default).local_length) := by
  rw [foldl, FoldlM.output_eq]
  unfold FoldlM.prod
  rw [constant.local_length_eq (default, default) 0]
  set k := constant.local_length
  have : m-1 < m := Nat.pred_lt (NeZero.ne m)
  rw [const_out (_, xs[m-1])]
  conv => lhs; lhs; intro acc i; rw [const_out (acc, _)]
  rcases m with _ | m
  · nomatch this
  simp only [Fin.foldl_const, Fin.natCast_eq_last, Fin.val_last, add_tsub_cancel_right]

@[circuit_norm ↓]
lemma foldl.forAll [NeZero m] :
  Operations.forAll n prop (foldl xs init body const_out constant |>.operations n) ↔
    (body init (xs[0]'(NeZero.pos m)) |>.forAll n prop) ∧
    ∀ (i : ℕ) (hi : i + 1 < m),
      let k := (body default default).local_length;
      let acc := (body default xs[i]).output (n + i*k);
      (body acc xs[i + 1]).forAll (n + (i + 1)*k) prop := by
  simp only [foldl, ←forAll_def]
  rw [FoldlM.forAll_iff_const constant const_out]

@[circuit_norm ↓]
lemma foldl.soundness [NeZero m] :
  constraints_hold.soundness env (foldl xs init body const_out constant |>.operations n) ↔
    constraints_hold.soundness env (body init (xs[0]'(NeZero.pos m)) |>.operations n) ∧
    ∀ (i : ℕ) (hi : i + 1 < m),
      let acc := (body default xs[i]).output (n + i*(body default default).local_length);
      constraints_hold.soundness env (body acc xs[i + 1] |>.operations (n + (i + 1)*(body default default).local_length)) := by
  simp only [foldl, constraints_hold.soundness_iff_forAll']
  rw [FoldlM.forAll_iff_const constant const_out]

@[circuit_norm ↓]
lemma foldl.completeness [NeZero m] :
  constraints_hold.completeness env (foldl xs init body const_out constant |>.operations n) ↔
    constraints_hold.completeness env (body init (xs[0]'(NeZero.pos m)) |>.operations n) ∧
    ∀ (i : ℕ) (hi : i + 1 < m),
      let acc := (body default xs[i]).output (n + i*(body default default).local_length);
      constraints_hold.completeness env (body acc xs[i + 1] |>.operations (n + (i + 1)*(body default default).local_length)) := by
  simp only [foldl, constraints_hold.completeness_iff_forAll']
  rw [FoldlM.forAll_iff_const constant const_out]

@[circuit_norm ↓]
lemma foldl.usesLocalWitnesses [NeZero m] :
  env.uses_local_witnesses_completeness n (foldl xs init body const_out constant |>.operations n) ↔
    env.uses_local_witnesses_completeness n (body init (xs[0]'(NeZero.pos m)) |>.operations n) ∧
    ∀ (i : ℕ) (hi : i + 1 < m),
      let k := (body default default).local_length;
      let acc := (body default xs[i]).output (n + i*k);
      env.uses_local_witnesses_completeness (n + (i + 1)*k) (body acc xs[i + 1] |>.operations (n + (i + 1)*k)) := by
  simp only [foldl, env.usesLocalWitnesses_completeness_iff_forAll, ←forAll_def]
  rw [FoldlM.forAll_iff_const constant const_out]
end foldl

end Circuit
