/-
This file proves some properties about `forM`, `mapM`, and `foldlM` monad loops when used in a `Circuit`,
typically leveraging a `ConstantCircuits` assumption on the loop body.

The end result are loop methods `Circuit.{mapFinRange, map, forEach, foldl}` that simplify
under `circuit_norm` in every way we need them to.
-/
import Clean.Circuit.Constant
import Clean.Utils.Misc
variable {n m : ℕ} {F : Type} [Field F] {α β : Type}

lemma Vector.forM_toList (xs : Vector α n) {m : Type → Type} [Monad m] (body : α → m Unit) :
    xs.forM body = forM xs.toList body := by
  rw [Vector.forM_eq_forM, Vector.forM_mk, List.forM_toArray, List.forM_eq_forM]

lemma Vector.mapM_toList (xs : Vector α n) {m : Type → Type} [monad: Monad m] [LawfulMonad m] (body : α → m β) :
    (fun v => v.toArray.toList) <$> (xs.mapM body) = xs.toList.mapM body := by
  rw [←Array.toList_mapM, ←Vector.toArray_mapM, Functor.map_map]

lemma Vector.foldlM_toList (xs : Vector α n) {m : Type → Type} [Monad m] (body : β → α → m β) (init : β) :
    xs.foldlM body init = xs.toList.foldlM body init := by
  rw [Vector.foldlM_mk, List.foldlM_toArray]

namespace Circuit

-- helper lemma to characterize `forAll` statements on the operations generated by loops
lemma forAll_flatten (xs : Vector α m) {circuit : α → Circuit F β} (constant : ConstantCircuits circuit)
  {prop : Operations.Condition F} :
  Operations.forAll n prop (List.ofFn fun (i : Fin m) => (circuit xs[i.val]).operations (n + i * constant.local_length)).flatten
    ↔ ∀ (i : Fin m), (circuit xs[i.val]).forAll (n + i * constant.local_length) prop := by
  induction m generalizing n
  case zero => simp [Operations.forAll]
  case succ m ih =>
    rw [List.ofFn_succ, List.flatten_cons, Operations.forAll_append, Fin.forall_fin_succ, Circuit.forAll_def]
    simp only [Fin.val_zero, zero_mul, add_zero, Fin.val_succ]
    specialize ih (n := n + constant.local_length) (xs := xs.drop 1)
    simp only [Vector.drop_eq_cast_extract, Nat.add_one_sub_one, Vector.getElem_cast,
      Vector.getElem_extract] at ih
    have : ((circuit xs[0]).operations n).local_length + n = n + constant.local_length := by
      rw [←constant.local_length_eq (xs[0]) n]; ac_rfl
    rw [this]
    ring_nf at ih ⊢
    rw [ih]

-- helper lemma to do induction on (List.ofFn ...).flatten terms
private lemma ofFn_flatten_cons {circuit : α → Circuit F β} (constant : ConstantCircuits circuit) (x : α) (xs : Vector α m) (n : ℕ) :
  (List.ofFn fun i => (circuit (Vector.cons x xs)[i.val]).operations (n + i * constant.local_length)).flatten
    = (circuit x).operations n ++ (List.ofFn fun i => (circuit xs[i.val]).operations (n + constant.local_length + i * constant.local_length)).flatten := by
  simp +arith [Vector.cons, add_mul]

namespace ForM
variable {circuit : α → Circuit F Unit} (xs : Vector α m) (constant : ConstantCircuits circuit) (n : ℕ)

theorem local_length_eq : (xs.forM circuit).local_length n = m * constant.local_length := by
  set k := constant.local_length
  induction xs using Vector.induct generalizing n
  case nil => ac_rfl
  case cons x xs ih =>
    rw [Vector.forM_toList, Vector.cons, List.forM_cons, ←Vector.forM_toList,
      bind_local_length_eq, ih, constant.local_length_eq]
    ring

theorem output_eq : (xs.forM circuit).output n = () := rfl

theorem operations_eq :
  (xs.forM circuit).operations n =
    (List.ofFn fun (i : Fin m) => (circuit xs[i.val]).operations (n + i * constant.local_length)).flatten := by
  induction xs using Vector.induct generalizing n
  case nil => rfl
  case cons x xs ih =>
    rw [ofFn_flatten_cons, Vector.forM_toList, Vector.cons, List.forM_cons, ←Vector.forM_toList,
      bind_operations_eq, ih, constant.local_length_eq]

theorem forAll_iff {prop : Operations.Condition F} :
  (xs.forM circuit).forAll n prop ↔
    ∀ (i : Fin m), (circuit xs[i.val]).forAll (n + i * constant.local_length) prop := by
  rw [forAll_def, operations_eq, forAll_flatten]
end ForM

namespace MapM
variable {circuit : α → Circuit F β} {xs : Vector α m} [constant: ConstantCircuits circuit]
  {prop : Operations.Condition F}

theorem local_length_eq : (xs.mapM circuit).local_length n = m * constant.local_length := by
  induction xs using Vector.induct_push
  case nil =>
    rw [Vector.mapM_mk_empty, pure_local_length_eq, zero_mul]
  case push xs x ih =>
    rw [Vector.mapM_push, bind_local_length_eq, bind_local_length_eq, pure_local_length_eq, ih, constant.local_length_eq]
    ring

theorem output_eq : (xs.mapM circuit).output n =
    xs.mapIdx fun i x => (circuit x).output (n + i * constant.local_length) := by
  induction xs using Vector.induct_push
  case nil => simp
  case push xs x ih =>
    rw [Vector.mapM_push, bind_output_eq, bind_output_eq, pure_output_eq, ih, local_length_eq]
    simp

lemma ext_map_toList (f g : Circuit F (Vector α n)) :
    (fun v => v.toArray.toList) <$> f = (fun v => v.toArray.toList) <$> g → f = g := by
  intro h
  rw [ext_iff] at h
  ext1 n
  · replace h := (h n).left
    rw [map_output_eq, map_output_eq] at h
    exact Vector.toList_inj.mp h
  · replace h := (h n).right
    rw [map_operations_eq, map_operations_eq] at h
    exact h

lemma mapM_cons (xs : Vector α n) (body : α → Circuit F β) (x : α) :
  (Vector.cons x xs).mapM body = do
    let y ← body x
    let ys ← xs.mapM body
    return Vector.cons y ys := by
  apply ext_map_toList
  rw [Vector.mapM_toList, Vector.toList_cons, List.mapM_cons, ←Vector.mapM_toList]
  simp only [map_bind, map_pure, Vector.toList_cons]
  rfl

theorem operations_eq : (xs.mapM circuit).operations n =
    (List.ofFn fun (i : Fin m) => (circuit xs[i.val]).operations (n + i * constant.local_length)).flatten := by
  induction xs using Vector.induct generalizing n
  case nil => simp [pure_operations_eq]
  case cons x xs ih =>
    rw [mapM_cons, bind_operations_eq, bind_operations_eq, pure_operations_eq, ih,
      constant.local_length_eq, List.append_nil, ofFn_flatten_cons]

theorem forAll_iff :
  (xs.mapM circuit).forAll n prop ↔
    ∀ (i : Fin m), (circuit xs[i.val]).forAll (n + i * constant.local_length) prop := by
  rw [forAll_def, operations_eq, forAll_flatten]

-- specialization to mapFinRangeM
theorem mapFinRangeM_forAll_iff {circuit : Fin m → Circuit F β} [constant : ConstantCircuits circuit] :
  (Vector.mapFinRangeM m circuit).forAll n prop ↔
    ∀ i : Fin m, (circuit i).forAll (n + i*constant.local_length) prop := by
  rw [Vector.mapFinRangeM, forAll_iff]
  simp only [Vector.getElem_finRange]
end MapM

namespace FoldlM
variable {env : Environment F} {prop : Operations.Condition F} {xs : Vector α m}
  {body : β → α → Circuit F β} {init : β} {constant : ConstantCircuits fun (t : β × α) => body t.1 t.2}

lemma foldlM_cons (x: α) :
  (Vector.cons x xs).foldlM body init = (do
    let init' ← body init x
    xs.foldlM body init') := by
  rw [Vector.foldlM_toList, Vector.cons, List.foldlM_cons]
  simp only [←Vector.foldlM_toList]

theorem local_length_eq :
    (xs.foldlM body init).local_length n = m * constant.local_length := by
  induction xs using Vector.induct generalizing init n
  case nil => rw [zero_mul]; rfl
  case cons x xs ih =>
    rw [foldlM_cons, bind_local_length_eq, ih, constant.local_length_eq (init, x)]
    ring

lemma finFoldl_cons_succ (x: α) :
  Fin.foldl (m + 1) (fun acc i => (body acc (Vector.cons x xs)[i.val]).output (n + i * constant.local_length)) init
    = Fin.foldl m (fun acc i => (body acc xs[i.val]).output (n + constant.local_length + i * constant.local_length)) ((body init x).output n) := by
  set k := constant.local_length
  rw [Fin.foldl_succ]
  simp only [Fin.val_succ, Fin.val_zero, zero_mul, add_zero]
  congr
  funext acc i
  rw [add_mul, add_assoc, add_comm k]
  simp [Vector.cons]

theorem output_eq :
  (xs.foldlM body init).output n =
    Fin.foldl m (fun acc i => (body acc xs[i.val]).output (n + i * constant.local_length)) init := by
  induction xs using Vector.induct generalizing init n
  case nil => rfl
  case cons x xs ih =>
    rw [foldlM_cons, bind_output_eq, ih, constant.local_length_eq (init, x), finFoldl_cons_succ]

variable [Inhabited β] [Inhabited α]

def foldlAcc (n : ℕ) (xs : Vector α m) (body : β → α → Circuit F β) (init : β) (j : Fin m) : β :=
  Fin.foldl j (fun acc i => (body acc xs[i.val]).output (n + i*(body default default).local_length)) init

lemma foldlAcc_zero [NeZero m] : foldlAcc n xs body init 0 = init := by
  simp [foldlAcc, Fin.foldl_zero]

lemma foldlAcc_cons_succ (i : Fin m) (x : α) [constant : ConstantCircuits fun (t : β × α) => body t.1 t.2] :
  foldlAcc n (Vector.cons x xs) body init i.succ =
    foldlAcc (n + (body init x).local_length n) xs body ((body init x).output n) i := by
  rw [constant.local_length_eq (init, x), ←constant.local_length_eq (default, default) 0]
  simp only [foldlAcc]
  simp only [Fin.val_succ, Vector.cons, Vector.getElem_mk, List.getElem_toArray, Fin.foldl_succ,
    List.getElem_cons_succ, Array.getElem_toList, Vector.getElem_toArray, add_mul, one_mul,
    Fin.val_zero, List.getElem_cons_zero, zero_mul, add_zero]
  ac_rfl

end FoldlM

def forEach {m : ℕ} (xs : Vector α m) [Inhabited α] (body : α → Circuit F Unit)
    (_constant : ConstantCircuits body := by infer_constant_circuits) : Circuit F Unit :=
  xs.forM body

def map {m : ℕ} (xs : Vector α m) (body : α → Circuit F β)
    (_constant : ConstantCircuits body := by infer_constant_circuits) : Circuit F (Vector β m) :=
  xs.mapM body

def mapFinRange (m : ℕ) [NeZero m] (body : Fin m → Circuit F β)
    (_constant : ConstantCircuits body := by infer_constant_circuits) : Circuit F (Vector β m) :=
  Vector.mapFinRangeM m body

section forEach
variable {env : Environment F} {m n : ℕ} [Inhabited α] {xs : Vector α m}
  {body : α → Circuit F Unit} {constant : ConstantCircuits body} {prop : Operations.Condition F}

@[circuit_norm ↓]
lemma forEach.local_length_eq :
    (forEach xs body constant).local_length n = m * (body default).local_length := by
  rw [forEach, ForM.local_length_eq, constant.local_length_eq]

@[circuit_norm ↓]
lemma forEach.output_eq :
  (forEach xs body constant).output n = () := rfl

@[circuit_norm ↓]
lemma forEach.forAll :
  Operations.forAll n prop ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, (body xs[i.val] |>.forAll (n + i*(body default).local_length) prop) := by
  simp only [forEach, ←forAll_def]
  rw [ForM.forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma forEach.soundness :
  constraints_hold.soundness env ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, constraints_hold.soundness env (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [forEach, constraints_hold.soundness_iff_forAll']
  rw [ForM.forAll_iff, ConstantCircuits.local_length_eq]

/-- variant of `forEach.soundness`, for when the constraints don't depend on the input offset -/
lemma forEach.soundness' :
  constraints_hold.soundness env (forEach xs body constant |>.operations n) →
    ∀ x ∈ xs, ∃ k : ℕ, constraints_hold.soundness env (body x |>.operations k) := by
  simp only [forEach, constraints_hold.soundness_iff_forAll', ForM.forAll_iff]
  intro h x hx
  obtain ⟨i, hi, rfl⟩ := Vector.getElem_of_mem hx
  exact ⟨ _ , h ⟨i, hi⟩ ⟩

@[circuit_norm ↓]
lemma forEach.completeness :
  constraints_hold.completeness env ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, constraints_hold.completeness env (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [forEach, constraints_hold.completeness_iff_forAll']
  rw [ForM.forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma forEach.uses_local_witnesses :
  env.uses_local_witnesses_completeness n ((forEach xs body constant).operations n) ↔
    ∀ i : Fin m, env.uses_local_witnesses_completeness (n + i*(body default).local_length) (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [forEach, env.uses_local_witnesses_completeness_iff_forAll, ←forAll_def]
  rw [ForM.forAll_iff, ConstantCircuits.local_length_eq]
end forEach

section map
variable {env : Environment F} {m n : ℕ} [Inhabited α] {xs : Vector α m}
  {body : α → Circuit F β} {constant : ConstantCircuits body} {prop : Operations.Condition F}

@[circuit_norm ↓]
lemma map.local_length_eq :
    (map xs body constant).local_length n = m * (body default).local_length := by
  rw [map, MapM.local_length_eq, constant.local_length_eq]

@[circuit_norm ↓]
lemma map.output_eq :
  (map xs body constant).output n =
    xs.mapIdx fun i x => (body x).output (n + i*(body default).local_length) := by
  rw [map, MapM.output_eq, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma map.forAll :
  Operations.forAll n prop (map xs body constant |>.operations n) ↔
    ∀ i : Fin m, (body xs[i.val] |>.forAll (n + i*(body default).local_length) prop) := by
  simp only [map, ←forAll_def]
  rw [MapM.forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma map.soundness :
  constraints_hold.soundness env (map xs body constant |>.operations n) ↔
    ∀ i : Fin m, constraints_hold.soundness env (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [map, constraints_hold.soundness_iff_forAll']
  rw [MapM.forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma map.completeness :
  constraints_hold.completeness env (map xs body constant |>.operations n) ↔
    ∀ i : Fin m, constraints_hold.completeness env (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [map, constraints_hold.completeness_iff_forAll']
  rw [MapM.forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma map.uses_local_witnesses :
  env.uses_local_witnesses_completeness n (map xs body constant |>.operations n) ↔
    ∀ i : Fin m, env.uses_local_witnesses_completeness (n + i*(body default).local_length) (body xs[i.val] |>.operations (n + i*(body default).local_length)) := by
  simp only [map, env.uses_local_witnesses_completeness_iff_forAll, ←forAll_def]
  rw [MapM.forAll_iff, ConstantCircuits.local_length_eq]
end map

section mapFinRange
variable {env : Environment F} {m n : ℕ} [NeZero m] {body : Fin m → Circuit F β}
  {constant : ConstantCircuits body} {prop : Operations.Condition F}

@[circuit_norm ↓]
lemma mapFinRange.local_length_eq :
    (mapFinRange m body constant).local_length n = m * (body 0).local_length := by
  rw [mapFinRange, Vector.mapFinRangeM, MapM.local_length_eq, constant.local_length_eq]

@[circuit_norm ↓]
lemma mapFinRange.output_eq :
  (mapFinRange m body constant).output n =
    Vector.mapFinRange m fun i => (body i).output (n + i*(body 0).local_length) := by
  rw [mapFinRange, Vector.mapFinRangeM, MapM.output_eq, ConstantCircuits.local_length_eq]
  ext i hi
  rw [Vector.getElem_mapIdx, Vector.getElem_finRange, Vector.getElem_mapFinRange]

@[circuit_norm ↓]
lemma mapFinRange.forAll :
  Operations.forAll n prop (mapFinRange m body constant |>.operations n) ↔
    ∀ i : Fin m, (body i |>.forAll (n + i*(body 0).local_length) prop) := by
  simp only [mapFinRange, ←forAll_def]
  rw [MapM.mapFinRangeM_forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma mapFinRange.soundness :
  constraints_hold.soundness env (mapFinRange m body constant |>.operations n) ↔
    ∀ i : Fin m, constraints_hold.soundness env (body i |>.operations (n + i*(body 0).local_length)) := by
  simp only [mapFinRange, constraints_hold.soundness_iff_forAll']
  rw [MapM.mapFinRangeM_forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma mapFinRange.completeness :
  constraints_hold.completeness env (mapFinRange m body constant |>.operations n) ↔
    ∀ i : Fin m, constraints_hold.completeness env (body i |>.operations (n + i*(body 0).local_length)) := by
  simp only [mapFinRange, constraints_hold.completeness_iff_forAll']
  rw [MapM.mapFinRangeM_forAll_iff, ConstantCircuits.local_length_eq]

@[circuit_norm ↓]
lemma mapFinRange.uses_local_witnesses :
  env.uses_local_witnesses_completeness n (mapFinRange m body constant |>.operations n) ↔
    ∀ i : Fin m, env.uses_local_witnesses_completeness (n + i*(body 0).local_length) (body i |>.operations (n + i*(body 0).local_length)) := by
  simp only [mapFinRange, env.uses_local_witnesses_completeness_iff_forAll, ←forAll_def]
  rw [MapM.mapFinRangeM_forAll_iff, ConstantCircuits.local_length_eq]
end mapFinRange
