/-
PicoCairo ADD Instruction Circuit
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Circuit.Subcircuit
import Clean.Examples.PicoCairo.Types
import Clean.Examples.PicoCairo.Helpers
import Clean.Examples.FemtoCairo.FemtoCairo
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.Spec
import Clean.Gadgets.Conditional
import Clean.Gadgets.IsZeroField

namespace Examples.PicoCairo

open Examples.FemtoCairo
open Examples.FemtoCairo.Types
open Examples.FemtoCairo.Spec

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Main circuit for ADD instruction step.
Takes enabled flag, timestamp, and pre-state.
If enabled and instruction at pc is ADD, computes new state and yields trace element.
-/
def addStepCircuitMain
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : Var InstructionStepInput (F p)) : Circuit (F p) Unit := do

  let enabled := input.enabled
  let timestamp := input.timestamp
  let preState := input.preState

  -- Step 1: Check that timestamp + 1 is not zero (prevent overflow)
  -- IsZeroField returns 1 if input is 0, 0 otherwise
  -- We want to assert that the result is 0 (meaning timestamp + 1 ≠ 0)
  let timestampPlusOneIsZero ← subcircuit Gadgets.IsZeroField.circuit (timestamp + 1)
  assertZero timestampPlusOneIsZero

  -- Step 2: Fetch instruction from program memory using FemtoCairo's circuit
  let rawInstruction ← subcircuitWithAssertion (fetchInstructionCircuit program h_programSize) preState.pc

  -- Step 3: Conditionally decode the instruction (returns dummy ADD when disabled)
  let decoded ← subcircuitWithAssertion conditionalDecodeCircuit {
    enabled := enabled,
    rawInstrType := rawInstruction.rawInstrType,
    dummy := dummyADDInstruction
  }

  -- Step 4: Unconditionally assert it's an ADD instruction
  -- When enabled=1, this checks the actual instruction is ADD
  -- When enabled=0, this always passes since dummy is ADD
  assertZero (decoded.instrType.isAdd - 1)

  -- Step 5: Read operands from memory using addressing modes
  let v1 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op1,
    mode := decoded.addr1
  }

  let v2 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op2,
    mode := decoded.addr2
  }

  let v3 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op3,
    mode := decoded.addr3
  }

  -- Step 6: Conditional ADD constraint: v3 = v1 + v2 (only when enabled)
  assertZero (enabled * (v3 - (v1 + v2)))

  -- Step 7: Compute next state (pc increments by 4, ap and fp unchanged for ADD)
  let postPc := preState.pc + 4
  let postAp := preState.ap
  let postFp := preState.fp

  -- Step 8: Conditional yield of new execution trace element
  yieldWhen enabled ⟨"execution", [timestamp + 1, postPc, postAp, postFp]⟩

/--
ElaboratedCircuit for ADD instruction step.
Takes InstructionStepInput and produces unit (since we yield, not return).
-/
def addStepElaboratedCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) InstructionStepInput unit where
  main := addStepCircuitMain program h_programSize memory h_memorySize
  localLength _ := 29  -- IsZero(2) + fetch(4) + conditionalDecode(8) + 3×readMemory(5)
  yields input env _ := {
    nl | env input.enabled ≠ 0 ∧
         nl = ⟨"execution", [env (input.timestamp + 1),
                             env (input.preState.pc + 4),
                             env input.preState.ap,
                             env input.preState.fp]⟩
  }
  yields_eq := by
    intro input env offset
    simp only [addStepCircuitMain, circuit_norm, Gadgets.IsZeroField.circuit, fetchInstructionCircuit, conditionalDecodeCircuit, conditionalDecodeElaborated,
      readFromMemoryCircuit, NamedList.eval]
    aesop

/--
Assumptions for ADD instruction step (for completeness).
Assumes enabled is binary and if enabled, the preState matches the unique execution trace at current timestamp.
Also ensures new timestamp won't overflow.
-/
def addStepAssumptions
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p))) : Prop :=
  IsBool input.enabled ∧
  -- New timestamp should not be zero (prevent overflow)
  input.timestamp + 1 ≠ 0 ∧
  -- If enabled, there's exactly one execution trace at current timestamp matching input state
  (input.enabled = 1 →
    {nl ∈ yielded | nl.name = "execution" ∧
                    ∃ h : nl.values.length = 4,
                    nl.values[0]'(by simp [h]) = input.timestamp} =
    {⟨"execution", [input.timestamp, input.preState.pc, input.preState.ap, input.preState.fp]⟩})

/--
Specification for ADD instruction step (for soundness).
The circuit already ensures fetch/decode succeed and instruction is ADD.
This spec verifies the ADD constraint and correct state transition.
-/
def addStepSpec
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p)))
    (output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  IsBool input.enabled →
  -- If enabled, circuit ensures it's ADD, so we just specify the yields
  if input.enabled = 1 then
    -- Circuit guarantees: fetch succeeds, decode succeeds, instruction is ADD
    -- We need to verify the ADD operation and state transition
    match Spec.fetchInstruction program input.preState.pc with
    | some rawInstr =>
      match Spec.decodeInstruction rawInstr.rawInstrType with
      | some (instrType, addr1, addr2, addr3) =>
        if instrType = 0 then  -- Must be ADD
          -- Read operands
          match Spec.dataMemoryAccess memory rawInstr.op1 addr1 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op2 addr2 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op3 addr3 input.preState.ap input.preState.fp with
          | some v1, some v2, some v3 =>
            -- ADD constraint must hold and we yield new state
            v1 + v2 = v3 ∧
            localYields = {⟨"execution", [input.timestamp + 1,
                                         input.preState.pc + 4,
                                         input.preState.ap,
                                         input.preState.fp]⟩}
          | _, _, _ => False  -- Circuit would fail if reads fail
        else
          False  -- Circuit would fail if not ADD
      | none => False  -- Circuit would fail if decode fails
    | none => False  -- Circuit would fail if fetch fails
  else
    localYields = ∅  -- Disabled, no yields

/--
GeneralFormalCircuit for ADD instruction step.
-/
def addStepFormalCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) InstructionStepInput unit where
  elaborated := addStepElaboratedCircuit program h_programSize memory h_memorySize
  Assumptions := addStepAssumptions program h_programSize memory h_memorySize
  Spec := addStepSpec program h_programSize memory h_memorySize
  soundness := by
    circuit_proof_start [addStepSpec, addStepElaboratedCircuit, addStepCircuitMain,
      Gadgets.IsZeroField.circuit, Gadgets.IsZeroField.Assumptions, Gadgets.IsZeroField.Spec,
      fetchInstructionCircuit, conditionalDecodeCircuit, readFromMemoryCircuit]
    intro h_bool
    rcases h_bool with h_zero | h_one
    · simp only [h_zero, zero_ne_one, ↓reduceIte, ne_eq, not_true_eq_false, false_and, Set.setOf_false]
    · subst h_one
      simp only [↓reduceIte, ne_eq, one_ne_zero, not_false_eq_true, true_and,
        Set.setOf_eq_eq_singleton, Set.singleton_eq_singleton_iff, NamedList.mk.injEq,
        List.cons.injEq, add_left_inj, and_true]
      rcases h_holds with ⟨ h_iszero, h_nonzero, h_fetch, h_decode, h_isadd, h_read1, h_read2, h_read3, h_add ⟩
      -- manual decomposition because State is not ProvableStruct
      rcases input_var_preState with ⟨ input_var_pc, input_var_ap, input_var_fp ⟩
      rcases input_preState with ⟨ input_pc, input_ap, input_fp ⟩
      simp only [circuit_norm, explicit_provable_type, State.mk.injEq] at h_input
      simp only [h_input] at h_fetch
      simp only
      cases h : fetchInstruction program input_pc
      · simp only [h] at h_fetch
      -- not indenting for heavy interesting case
      simp only [h] at h_fetch
      subst h_fetch
      simp only
      specialize h_decode (by simp only [circuit_norm])
      simp only [one_ne_zero, ↓reduceIte, decodeInstructionSpec] at h_decode
      simp only [circuit_norm, explicit_provable_type]
      cases h2 : decodeInstruction (env.get (i₀ + 2))
      · simp only [h2] at h_decode
      -- not indenting for heavy interesting case
      simp only [h2] at h_decode
      rename_i decoded
      rcases decoded with ⟨ type, addr1', addr2', addr3' ⟩
      simp only at h_decode ⊢
      by_cases h_type : type ≠ 0
      ·
        sorry





      sorry

  completeness := by sorry

/--
Bundle of ADD instruction step circuits.
Takes a vector of inputs with given capacity and executes ADD instructions for each enabled input.
-/
def addStepCircuitsBundle
    (capacity : ℕ)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (inputs : Vector (Var InstructionStepInput (F p)) capacity) : Circuit (F p) Unit := do
  -- Process each input using the formal circuit
  for h : i in [0:capacity] do
    subcircuitWithAssertion (addStepFormalCircuit program h_programSize memory h_memorySize) inputs[i]

-- Future: mulStepCircuitsBundle, loadStateStepCircuitsBundle, storeStateStepCircuitsBundle

end Examples.PicoCairo
