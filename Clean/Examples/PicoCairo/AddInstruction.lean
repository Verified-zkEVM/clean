/-
PicoCairo ADD Instruction Circuit
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Circuit.Subcircuit
import Clean.Examples.PicoCairo.Types
import Clean.Examples.PicoCairo.Helpers
import Clean.Examples.FemtoCairo.FemtoCairo
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.Spec
import Clean.Gadgets.Conditional
import Clean.Gadgets.IsZeroField

namespace Examples.PicoCairo

open Examples.FemtoCairo
open Examples.FemtoCairo.Types
open Examples.FemtoCairo.Spec

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Main circuit for ADD instruction step.
Takes enabled flag, timestamp, and pre-state.
If enabled and instruction at pc is ADD, computes new state and yields trace element.
-/
def addStepCircuitMain
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : Var InstructionStepInput (F p)) : Circuit (F p) Unit := do

  let enabled := input.enabled
  let timestamp := input.timestamp
  let preState := input.preState

  -- Step 1: Check that timestamp + 1 is not zero (prevent overflow)
  -- IsZeroField returns 1 if input is 0, 0 otherwise
  -- We want to assert that the result is 0 (meaning timestamp + 1 ≠ 0)
  let timestampPlusOneIsZero ← subcircuit Gadgets.IsZeroField.circuit (timestamp + 1)
  assertZero timestampPlusOneIsZero

  -- Step 2: Fetch instruction from program memory using FemtoCairo's circuit
  let rawInstruction ← subcircuitWithAssertion (fetchInstructionCircuit program h_programSize) preState.pc

  -- Step 3: Conditionally decode the instruction (returns dummy ADD when disabled)
  let decoded ← subcircuitWithAssertion conditionalDecodeCircuit {
    enabled := enabled,
    rawInstrType := rawInstruction.rawInstrType,
    dummy := dummyADDInstruction
  }

  -- Step 4: Unconditionally assert it's an ADD instruction
  -- When enabled=1, this checks the actual instruction is ADD
  -- When enabled=0, this always passes since dummy is ADD
  assertZero (decoded.instrType.isAdd - 1)

  -- Step 5: Read operands from memory using addressing modes
  let v1 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op1,
    mode := decoded.addr1
  }

  let v2 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op2,
    mode := decoded.addr2
  }

  let v3 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op3,
    mode := decoded.addr3
  }

  -- Step 6: Conditional ADD constraint: v3 = v1 + v2 (only when enabled)
  assertZero (enabled * (v3 - (v1 + v2)))

  -- Step 7: Compute next state (pc increments by 4, ap and fp unchanged for ADD)
  let postPc := preState.pc + 4
  let postAp := preState.ap
  let postFp := preState.fp

  -- Step 8: Conditional yield of new execution trace element
  yieldWhen enabled ⟨"execution", [timestamp + 1, postPc, postAp, postFp]⟩

  return ()

/--
Bundle of ADD instruction step circuits.
Takes a vector of inputs with given capacity and executes ADD instructions for each enabled input.
-/
def addStepCircuitsBundle
    (capacity : ℕ)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (inputs : Vector (Var InstructionStepInput (F p)) capacity) : Circuit (F p) Unit := do
  -- Process each input
  for h : i in [0:capacity] do
    addStepCircuitMain program h_programSize memory h_memorySize inputs[i]
  return ()

-- Future: mulStepCircuitsBundle, loadStateStepCircuitsBundle, storeStateStepCircuitsBundle

/--
ElaboratedCircuit for ADD instruction step.
Takes InstructionStepInput and produces unit (since we yield, not return).
-/
def addStepElaboratedCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) InstructionStepInput unit where
  main := addStepCircuitMain program h_programSize memory h_memorySize
  localLength _ := 29  -- IsZero(2) + fetch(4) + conditionalDecode(8) + 3×readMemory(5)
  yields input env _ := {
    nl | env input.enabled ≠ 0 ∧
         nl = ⟨"execution", [env (input.timestamp + 1),
                             env (input.preState.pc + 4),
                             env input.preState.ap,
                             env input.preState.fp]⟩
  }
  yields_eq := by
    intro input env offset
    simp only [addStepCircuitMain, circuit_norm, Gadgets.IsZeroField.circuit, fetchInstructionCircuit]
    sorry  -- TODO: Prove yields equality

/--
Assumptions for ADD instruction step (for completeness).
Assumes enabled is binary and if enabled, the preState matches the unique execution trace at current timestamp.
Also ensures new timestamp won't overflow.
-/
def addStepAssumptions
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p))) : Prop :=
  IsBool input.enabled ∧
  -- New timestamp should not be zero (prevent overflow)
  input.timestamp + 1 ≠ 0 ∧
  -- If enabled, there's exactly one execution trace at current timestamp matching input state
  (input.enabled = 1 →
    {nl ∈ yielded | nl.name = "execution" ∧
                    ∃ h : nl.values.length = 4,
                    nl.values[0]'(by simp [h]) = input.timestamp} =
    {⟨"execution", [input.timestamp, input.preState.pc, input.preState.ap, input.preState.fp]⟩})

/--
Specification for ADD instruction step (for soundness).
Relates global yields to local yields produced by this step.
-/
def addStepSpec
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p)))
    (output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  -- If enabled and instruction is ADD, we yield the new state
  if input.enabled = 1 then
    -- Check that instruction at PC is actually ADD
    match Spec.fetchInstruction program input.preState.pc with
    | some rawInstr =>
      match Spec.decodeInstruction rawInstr.rawInstrType with
      | some (instrType, addr1, addr2, addr3) =>
        if instrType = 0 then  -- ADD instruction
          -- Read operands
          match Spec.dataMemoryAccess memory rawInstr.op1 addr1 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op2 addr2 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op3 addr3 input.preState.ap input.preState.fp with
          | some v1, some v2, some v3 =>
            -- Check ADD constraint holds and yield new state
            v1 + v2 = v3 ∧
            localYields = {⟨"execution", [input.timestamp + 1,
                                         input.preState.pc + 4,
                                         input.preState.ap,
                                         input.preState.fp]⟩}
          | _, _, _ => localYields = ∅
        else
          localYields = ∅  -- Not an ADD instruction
      | none => localYields = ∅
    | none => localYields = ∅
  else
    localYields = ∅  -- Disabled, no yields

/--
GeneralFormalCircuit for ADD instruction step.
-/
def addStepFormalCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) InstructionStepInput unit where
  elaborated := addStepElaboratedCircuit program h_programSize memory h_memorySize
  Assumptions := addStepAssumptions program h_programSize memory h_memorySize
  Spec := addStepSpec program h_programSize memory h_memorySize
  soundness := by sorry
  completeness := by sorry

end Examples.PicoCairo
