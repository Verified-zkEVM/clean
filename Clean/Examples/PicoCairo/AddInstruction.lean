/-
PicoCairo ADD Instruction Circuit
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Circuit.Subcircuit
import Clean.Circuit.Loops
import Clean.Examples.PicoCairo.Types
import Clean.Examples.PicoCairo.Helpers
import Clean.Examples.FemtoCairo.FemtoCairo
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.Spec
import Clean.Gadgets.Conditional
import Clean.Gadgets.IsZeroField
import Clean.Gadgets.Boolean
import Batteries.Data.Vector.Lemmas

namespace Examples.PicoCairo

open Examples.FemtoCairo
open Examples.FemtoCairo.Types
open Examples.FemtoCairo.Spec

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Main circuit for ADD instruction step.
Takes enabled flag, timestamp, and pre-state.
If enabled and instruction at pc is ADD, computes new state and yields trace element.
-/
def addStepCircuitMain
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : Var InstructionStepInput (F p)) : Circuit (F p) Unit := do

  let enabled := input.enabled
  let timestamp := input.timestamp
  let preState := input.preState

  -- Step 1: Assert enabled is boolean (0 or 1)
  assertBool enabled

  -- Step 1b: Conditionally use the preState from yielded execution trace
  useWhen enabled ⟨"execution", [timestamp, preState.pc, preState.ap, preState.fp]⟩

  -- Step 2: Check that timestamp + 1 is not zero (prevent overflow)
  -- IsZeroField returns 1 if input is 0, 0 otherwise
  -- We want to assert that the result is 0 (meaning timestamp + 1 ≠ 0)
  let timestampPlusOneIsZero ← subcircuit Gadgets.IsZeroField.circuit (timestamp + 1)
  assertZero timestampPlusOneIsZero

  -- Step 3: Fetch instruction from program memory using FemtoCairo's circuit
  let rawInstruction ← subcircuitWithAssertion (fetchInstructionCircuit program h_programSize) preState.pc

  -- Step 4: Conditionally decode the instruction (returns dummy ADD when disabled)
  let decoded ← subcircuitWithAssertion conditionalDecodeCircuit {
    enabled := enabled,
    rawInstrType := rawInstruction.rawInstrType,
    dummy := dummyADDInstruction
  }

  -- Step 5: Unconditionally assert it's an ADD instruction
  -- When enabled=1, this checks the actual instruction is ADD
  -- When enabled=0, this always passes since dummy is ADD
  assertZero (decoded.instrType.isAdd - 1)

  -- Step 6: Read operands from memory using addressing modes
  let v1 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op1,
    mode := decoded.mode1
  }

  let v2 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op2,
    mode := decoded.mode2
  }

  let v3 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op3,
    mode := decoded.mode3
  }

  -- Step 7: Conditional ADD constraint: v3 = v1 + v2 (only when enabled)
  assertZero (enabled * (v3 - (v1 + v2)))

  -- Step 8: Compute next state (pc increments by 4, ap and fp unchanged for ADD)
  let postPc := preState.pc + 4
  let postAp := preState.ap
  let postFp := preState.fp

  -- Step 9: Conditional yield of new execution trace element
  yieldWhen enabled ⟨"execution", [timestamp + 1, postPc, postAp, postFp]⟩

/--
Computes the localYields for a single ADD instruction step.
If enabled, yields the new execution state; otherwise yields nothing.
-/
def addStepLocalYields (input : InstructionStepInput (F p)) : Set (NamedList (F p)) :=
  { nl | input.enabled ≠ 0 ∧
         nl = ⟨"execution", [input.timestamp + 1,
                            input.preState.pc + 4,
                            input.preState.ap,
                            input.preState.fp]⟩ }

/--
ElaboratedCircuit for ADD instruction step.
Takes InstructionStepInput and produces unit (since we yield, not return).
-/
def addStepElaboratedCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) InstructionStepInput unit where
  main := addStepCircuitMain program h_programSize memory h_memorySize
  localLength _ := 29  -- boolean(0) + IsZero(2) + fetch(4) + conditionalDecode(8) + 3×readMemory(5)
  yields input env _ := addStepLocalYields (eval env input)
  yields_eq := by
    intro input env offset
    simp only [addStepLocalYields, addStepCircuitMain, circuit_norm, Gadgets.IsZeroField.circuit, fetchInstructionCircuit, conditionalDecodeCircuit, conditionalDecodeElaborated,
      readFromMemoryCircuit, NamedList.eval]
    aesop

/--
Assumptions for ADD instruction step (for completeness).
Ensures the instruction can be decoded, new timestamp won't overflow, and PC is in bounds.
-/
def addStepAssumptions
    {programSize : ℕ} [NeZero programSize]
    (input : InstructionStepInput (F p)) (_yielded : Set (NamedList (F p))) : Prop :=
  IsBool input.enabled ∧
  -- New timestamp should not be zero (prevent overflow)
  input.timestamp + 1 ≠ 0 ∧
  ZMod.val (input.preState.pc) + 3 < programSize

/--
Specification for ADD instruction step (for soundness).
The circuit already ensures fetch/decode succeed and instruction is ADD.
This spec verifies the ADD constraint and correct state transition.
-/
def addStepSpec
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  -- If enabled (circuit enforces binary), circuit ensures it's ADD, so we just specify the yields
  if input.enabled = 1 then
    -- Timestamp must not overflow
    input.timestamp + 1 ≠ 0 ∧
    -- The preState must be in the yielded set
    ⟨"execution", [input.timestamp, input.preState.pc, input.preState.ap, input.preState.fp]⟩ ∈ yielded ∧
    -- Circuit guarantees: fetch succeeds, decode succeeds, instruction is ADD
    -- We need to verify the ADD operation and state transition
    match Spec.fetchInstruction program input.preState.pc with
    | some rawInstr =>
      match Spec.decodeInstruction rawInstr.rawInstrType with
      | some (instrType, mode1, mode2, mode3) =>
        if instrType = 0 then  -- Must be ADD
          -- Read operands
          match Spec.dataMemoryAccess memory rawInstr.op1 mode1 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op2 mode2 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op3 mode3 input.preState.ap input.preState.fp with
          | some v1, some v2, some v3 =>
            -- ADD constraint must hold and we yield new state
            v1 + v2 = v3 ∧
            localYields = {⟨"execution", [input.timestamp + 1,
                                         input.preState.pc + 4,
                                         input.preState.ap,
                                         input.preState.fp]⟩}
          | _, _, _ => False  -- Circuit would fail if reads fail
        else
          False  -- Circuit would fail if not ADD
      | none => False  -- Circuit would fail if decode fails
    | none => False  -- Circuit would fail if fetch fails
  else
    localYields = ∅  -- Disabled, no yields

/--
GeneralFormalCircuit for ADD instruction step.
-/
def addStepFormalCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) InstructionStepInput unit where
  elaborated := addStepElaboratedCircuit program h_programSize memory h_memorySize
  Assumptions := addStepAssumptions (programSize := programSize)
  Spec := addStepSpec program memory
  soundness := by
    circuit_proof_start [addStepSpec, addStepElaboratedCircuit, addStepCircuitMain,
      assertBool, Gadgets.IsZeroField.circuit, Gadgets.IsZeroField.Assumptions, Gadgets.IsZeroField.Spec,
      fetchInstructionCircuit, conditionalDecodeCircuit, readFromMemoryCircuit]
    rcases h_holds with ⟨ h_bool, h_holds ⟩
    rcases h_bool with h_zero | h_one
    · simp only [h_zero, addStepLocalYields]
      aesop
    · subst h_one
      simp only [↓reduceIte, addStepLocalYields]
      rcases h_holds with ⟨ h_use, h_iszero, h_nonzero, h_fetch, h_decode, h_isadd, h_read1, h_read2, h_read3, h_add ⟩
      simp only [ne_eq, one_ne_zero, not_false_eq_true, forall_const] at h_use
      -- Prove timestamp doesn't overflow
      constructor
      · aesop
      constructor
      · aesop
      -- manual decomposition because State is not ProvableStruct
      rcases input_var_preState with ⟨ input_var_pc, input_var_ap, input_var_fp ⟩
      rcases input_preState with ⟨ input_pc, input_ap, input_fp ⟩
      simp only [circuit_norm, explicit_provable_type, State.mk.injEq] at h_input
      simp only [h_input] at h_fetch
      simp only
      cases h : fetchInstruction program input_pc
      · simp only [h] at h_fetch
      -- not indenting for heavy interesting case
      simp only [h] at h_fetch
      subst h_fetch
      simp only
      specialize h_decode (by simp only [circuit_norm])
      simp only [one_ne_zero, ↓reduceIte, decodeInstructionSpec] at h_decode
      simp only [circuit_norm, explicit_provable_type]
      cases h2 : decodeInstruction (env.get (i₀ + 2))
      · simp only [h2] at h_decode
      -- not indenting for heavy interesting case
      simp only [h2] at h_decode
      rename_i decoded
      rcases decoded with ⟨ type, mode1', mode2', mode3' ⟩
      simp only at h_decode ⊢
      simp only [circuit_norm, explicit_provable_type] at h_decode h_isadd
      rcases h_decode with ⟨ h_decode_type, h_decode ⟩
      -- there should be a tactic for naming outputs of elaborated circuits
      cases decoded : @ElaboratedCircuit.output (F p) ConditionalDecodeInput DecodedInstruction (instFieldFOfFactPrime p)
        ProvableType.fromStruct ProvableType.fromStruct conditionalDecodeElaborated
        { enabled := input_var_enabled, rawInstrType := var { index := i₀ + 2 }, dummy := dummyADDInstruction }
          (i₀ + 2 + 4)
      rename_i decoded_instr_type decoded_mode1 decoded_mode2 decoded_mode3
      simp only [decoded] at h_decode_type h_isadd h_read1 h_read2 h_read3 h_decode
      cases decoded_instr_type
      simp only at h_decode_type h_isadd
      simp only [DecodedInstructionType.val] at h_decode_type
      rw [if_pos] at h_decode_type
      swap
      · grind
      subst h_decode_type
      simp only [↓reduceIte]
      specialize h_read1 (by aesop)
      specialize h_read2 (by aesop)
      specialize h_read3 (by aesop)
      rcases h_decode with ⟨ h_correct, h_mode1', h_correct1, h_mode2', h_correct2, h_mode3', h_correct3 ⟩
      cases h_access1 : dataMemoryAccess memory (env.get (i₀ + 2 + 1)) mode1' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read1
        subst h_mode1'
        simp_all
      rename_i v1
      cases h_access2 : dataMemoryAccess memory (env.get (i₀ + 2 + 1 + 1)) mode2' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read2
        subst h_mode2'
        simp_all
      rename_i v2
      cases h_access3 : dataMemoryAccess memory (env.get (i₀ + 2 + 1 + 1 + 1)) mode3' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read3
        subst h_mode3'
        simp_all
      rename_i v3
      simp only
      and_intros
      · simp only [circuit_norm, explicit_provable_type] at h_read1
        subst h_mode1'
        simp only [h_access1] at h_read1
        subst h_read1
        simp only [circuit_norm, explicit_provable_type] at h_read2
        subst h_mode2'
        simp only [h_access2] at h_read2
        subst h_read2
        simp only [circuit_norm, explicit_provable_type] at h_read3
        subst h_mode3'
        simp only [h_access3] at h_read3
        subst h_read3
        grind
      · simp_all

  -- Postponed: assumptions are missing about well-formedness of the program, etc.
  -- Yield/use is more interesting in soundness.
  completeness := by sorry

/--
Bundle of ADD instruction step circuits.
Takes a vector of inputs with given capacity and executes ADD instructions for each enabled input.
-/
def addStepCircuitsBundle
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (inputs : Var (ProvableVector InstructionStepInput capacity) (F p)) : Circuit (F p) Unit := do
  let _ ← Circuit.mapFinRange capacity fun i =>
    subcircuitWithAssertion (addStepFormalCircuit program h_programSize memory h_memorySize) inputs[i.val]
  return ()

/--
Elaborated circuit for ADD instruction bundle.
-/
def addStepCircuitsBundleElaborated
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) (ProvableVector InstructionStepInput capacity) unit where
  main := addStepCircuitsBundle capacity program h_programSize memory h_memorySize
  localLength _ := capacity * 29  -- Each step uses 29 locals
  localLength_eq := by
    intros input offset
    simp only [circuit_norm, addStepCircuitsBundle]
    congr 1
  yields inputs env offset :=
    ⋃ i : Fin capacity, addStepLocalYields (eval env inputs[i])
  yields_eq := by
    intros inputs env offset
    simp only [circuit_norm, addStepCircuitsBundle]
    ext nl
    simp only [Set.mem_iUnion]
    constructor
    · intro ⟨i, hi⟩
      use i
      simp only [addStepFormalCircuit, addStepElaboratedCircuit, circuit_norm] at hi
      exact hi
    · intro ⟨i, hi⟩
      use i
      simp only [addStepFormalCircuit, addStepElaboratedCircuit, circuit_norm]
      exact hi
  subcircuitsConsistent := by
    intros inputs offset
    simp only [circuit_norm, addStepCircuitsBundle]

/--
Assumptions for the bundle: each input must satisfy the individual step assumptions.
-/
def addStepCircuitsBundleAssumptions
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize]
    (inputs : ProvableVector InstructionStepInput capacity (F p)) (_yielded : Set (NamedList (F p))) : Prop :=
  ∀ i : Fin capacity, addStepAssumptions (programSize := programSize) inputs[i] _yielded

/--
Spec for the bundle: each element satisfies its step spec, and local yields are the union.
-/
def addStepCircuitsBundleSpec
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (inputs : ProvableVector InstructionStepInput capacity (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  (∀ i : Fin capacity, addStepSpec program memory inputs[i] yielded () (addStepLocalYields inputs[i])) ∧
  localYields = ⋃ i : Fin capacity, addStepLocalYields inputs[i]

/--
GeneralFormalCircuit for ADD instruction bundle.
-/
def addStepCircuitsBundleFormalCircuit
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) (ProvableVector InstructionStepInput capacity) unit where
  elaborated := addStepCircuitsBundleElaborated capacity program h_programSize memory h_memorySize
  Assumptions := addStepCircuitsBundleAssumptions capacity (programSize := programSize)
  Spec := addStepCircuitsBundleSpec capacity program memory
  soundness := by
    circuit_proof_start [addStepCircuitsBundleElaborated, addStepCircuitsBundleSpec]
    simp only [addStepCircuitsBundle, circuit_norm, addStepFormalCircuit] at h_holds
    and_intros
    · intro i
      specialize h_holds i
      simp only [addStepElaboratedCircuit] at h_holds
      simp only [Fin.eta] at h_holds
      cases iv_h : Vector.get input_var i
      rename_i enabledVar timestampVar preStateVar
      simp only [iv_h] at h_holds
      simp only [← h_input, eval_vector, Vector.getElem_map]
      rw [Vector.get_eq_getElem] at iv_h
      conv =>
        arg 3
        simp only [iv_h]
        simp only [circuit_norm]
      assumption
    · apply Set.iUnion_congr
      intro i
      congr 1
      simp only [← h_input, eval_vector, Vector.getElem_map]
      cases iv_h : Vector.get input_var i
      rename_i enabledVar timestampVar preStateVar
      rw [Vector.get_eq_getElem] at iv_h
      simp only [iv_h]
      conv_rhs =>
        simp only [circuit_norm]
  completeness := sorry

-- Future: mulStepCircuitsBundle, loadStateStepCircuitsBundle, storeStateStepCircuitsBundle

/--
Predicate stating that a named list represents a valid ADD instruction execution.
This captures the relationship between a pre-state, the instruction execution, and the resulting yield.
-/
def IsValidAddExecution
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (preState : State (F p))
    (timestamp : F p)
    (nl : NamedList (F p)) : Prop :=
  ∃ (rawInstr : RawInstruction (F p)) (mode1 mode2 mode3 : ℕ) (v1 v2 v3 : F p),
    Spec.fetchInstruction program preState.pc = some rawInstr ∧
    Spec.decodeInstruction rawInstr.rawInstrType = some (0, mode1, mode2, mode3) ∧
    Spec.dataMemoryAccess memory rawInstr.op1 mode1 preState.ap preState.fp = some v1 ∧
    Spec.dataMemoryAccess memory rawInstr.op2 mode2 preState.ap preState.fp = some v2 ∧
    Spec.dataMemoryAccess memory rawInstr.op3 mode3 preState.ap preState.fp = some v3 ∧
    v1 + v2 = v3 ∧
    nl = ⟨"execution", [timestamp + 1, preState.pc + 4, preState.ap, preState.fp]⟩

/--
Characterization theorem for ADD instruction localYields.
If something is in localYields and the spec holds, we can extract witnesses for all the conditions.
This is useful for inductive reasoning about execution traces.
-/
theorem addStepSpec_localYields_characterization
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p)))
    (localYields : Set (NamedList (F p)))
    (nl : NamedList (F p))
    (h_spec : addStepSpec program memory input yielded () localYields)
    (h_mem : nl ∈ localYields) :
    -- Then we can extract:
    input.enabled = 1 ∧
    input.timestamp + 1 ≠ 0 ∧
    ⟨"execution", [input.timestamp, input.preState.pc, input.preState.ap, input.preState.fp]⟩ ∈ yielded ∧
    IsValidAddExecution program memory input.preState input.timestamp nl := by
  simp only [addStepSpec] at h_spec
  simp only [IsValidAddExecution]
  by_cases h_enabled : input.enabled = 1
  swap -- error case first
  · aesop
  simp only [h_enabled] at *
  simp only [↓reduceIte, ne_eq, if_false_right] at h_spec
  simp only [ne_eq, exists_and_left, existsAndEq, true_and]
  rcases h_spec with ⟨ h_overflow, h_spec ⟩
  constructor
  · simp_all
  rcases h_spec with ⟨ h_use, h_spec ⟩
  constructor
  · simp_all
  cases h_fetched : fetchInstruction program input.preState.pc
  · simp_all
  rename_i rawInstr
  use rawInstr
  constructor
  · rfl
  simp only [h_fetched] at h_spec
  cases h_decoded : decodeInstruction rawInstr.rawInstrType
  · simp_all
  rename_i decoded
  rcases decoded with ⟨ typ, mode1, mode2, mode3 ⟩
  simp only [h_decoded] at h_spec
  use mode1, mode2, mode3
  constructor
  · grind
  cases h_access1 : dataMemoryAccess memory rawInstr.op1 mode1 input.preState.ap input.preState.fp
  · grind
  cases h_access2 : dataMemoryAccess memory rawInstr.op2 mode2 input.preState.ap input.preState.fp
  · grind
  cases h_access3 : dataMemoryAccess memory rawInstr.op3 mode3 input.preState.ap input.preState.fp
  · grind
  rename_i v1 v2 v3
  use v1
  simp only [true_and]
  use v2
  simp only [true_and]
  simp_all

omit p_large_enough in
/--
Theorem stating that IsValidAddExecution implies a valid femtoCairoMachineTransition.
This connects the circuit specification to the machine semantics.
-/
theorem IsValidAddExecution_implies_valid_transition
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (preState : State (F p))
    (timestamp : F p)
    (nl : NamedList (F p))
    (h_valid : IsValidAddExecution program memory preState timestamp nl) :
    ∃ newState : State (F p),
      Spec.femtoCairoMachineTransition program memory preState = some newState ∧
      nl = ⟨"execution", [timestamp + 1, newState.pc, newState.ap, newState.fp]⟩ := by
  simp only [IsValidAddExecution] at h_valid
  rcases h_valid with ⟨rawInstr, mode1, mode2, mode3, v1, v2, v3, h_fetch, h_decode, h_access1, h_access2, h_access3, h_add, h_nl⟩
  use { pc := preState.pc + 4, ap := preState.ap, fp := preState.fp }
  constructor
  · simp only [Spec.femtoCairoMachineTransition, Option.bind_eq_bind, h_fetch]
    simp only [h_decode, Option.bind_some, h_access1, h_access2, h_access3, computeNextState]
    aesop
  · exact h_nl

/--
Characterization theorem for ADD instruction bundle localYields.
Given a bundle spec and a named list in the local yields, we can find which instruction index it came from
and extract witnesses for all the conditions.
-/
theorem addStepCircuitsBundleSpec_localYields_characterization
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (inputs : ProvableVector InstructionStepInput capacity (F p)) (yielded : Set (NamedList (F p)))
    (localYields : Set (NamedList (F p)))
    (nl : NamedList (F p))
    (h_spec : addStepCircuitsBundleSpec capacity program memory inputs yielded () localYields)
    (h_mem : nl ∈ localYields) :
    -- Then we can find an index i such that the conditions hold for inputs[i]
    ∃ (i : Fin capacity),
      inputs[i].enabled = 1 ∧
      inputs[i].timestamp + 1 ≠ 0 ∧
      ⟨"execution", [inputs[i].timestamp, inputs[i].preState.pc, inputs[i].preState.ap, inputs[i].preState.fp]⟩ ∈ yielded ∧
      IsValidAddExecution program memory inputs[i].preState inputs[i].timestamp nl := by
  simp only [addStepCircuitsBundleSpec] at h_spec
  rcases h_spec with ⟨h_all, h_yields⟩
  rw [h_yields] at h_mem
  simp only [Set.mem_iUnion] at h_mem
  rcases h_mem with ⟨i, h_i⟩
  use i
  exact addStepSpec_localYields_characterization program memory inputs[i] yielded (addStepLocalYields inputs[i]) nl (h_all i) h_i

end Examples.PicoCairo
