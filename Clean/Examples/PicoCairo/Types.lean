/-
PicoCairo Types and Data Structures
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Circuit.Provable
import Clean.Examples.FemtoCairo.Types

namespace Examples.PicoCairo

open Examples.FemtoCairo.Types

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
An execution trace element represents a single state in the execution.
We store it as a NamedList with format: ("execution", [timestamp, pc, ap, fp])
-/
structure ExecutionTraceElement (F : Type) where
  timestamp : F
  state : State F

/--
Convert a State to the execution trace NamedList format
-/
def stateToTraceList (timestamp : F p) (state : State (F p)) : NamedList (F p) :=
  ⟨"execution", [timestamp, state.pc, state.ap, state.fp]⟩

/--
Extract State from an execution trace NamedList
Assumes the format is correct: ("execution", [timestamp, pc, ap, fp])
-/
def traceListToState (nl : NamedList (F p)) : Option (F p × State (F p)) :=
  if h : nl.name = "execution" ∧ nl.values.length = 4 then
    have h0 : 0 < nl.values.length := by simp [h.2]
    have h1 : 1 < nl.values.length := by simp [h.2]
    have h2 : 2 < nl.values.length := by simp [h.2]
    have h3 : 3 < nl.values.length := by simp [h.2]
    some (nl.values[0], {
      pc := nl.values[1],
      ap := nl.values[2],
      fp := nl.values[3]
    })
  else
    none

/--
Check if a NamedList is a valid execution trace element
-/
def isValidTraceElement (nl : NamedList (F p)) : Prop :=
  nl.name = "execution" ∧ nl.values.length = 4

/--
Input structure for instruction step circuits.
Contains all information needed to potentially execute one instruction.
-/
structure InstructionStepInput (F : Type) where
  enabled : F  -- Non-zero to execute this step
  timestamp : F
  preState : State F

instance : ProvableStruct InstructionStepInput where
  components := [field, field, State]
  toComponents := fun { enabled, timestamp, preState } =>
    .cons enabled (.cons timestamp (.cons preState .nil))
  fromComponents := fun (.cons enabled (.cons timestamp (.cons preState .nil))) =>
    { enabled, timestamp, preState }

instance : NonEmptyProvableType InstructionStepInput where
  nonempty := by
    decide

/--
Bundle configuration specifying how many of each instruction type
-/
structure BundleConfig where
  numAdds : ℕ
  numMuls : ℕ
  numLoads : ℕ
  numStores : ℕ

/--
Default bundle configuration with N of each instruction type
-/
def defaultBundleConfig (N : ℕ) : BundleConfig :=
  { numAdds := N, numMuls := N, numLoads := N, numStores := N }

end Examples.PicoCairo
