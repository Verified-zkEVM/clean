/-
PicoCairo Instruction Step Circuits
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Circuit.Subcircuit
import Clean.Examples.PicoCairo.Types
import Clean.Examples.PicoCairo.Helpers
import Clean.Examples.FemtoCairo.FemtoCairo
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.Spec
import Clean.Gadgets.Conditional

namespace Examples.PicoCairo

open Examples.FemtoCairo
open Examples.FemtoCairo.Types
open Examples.FemtoCairo.Spec

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
ADD instruction step circuit.
Takes enabled flag, timestamp, and pre-state.
If enabled and instruction at pc is ADD, computes new state and yields trace element.
-/
def addStepCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : Var InstructionStepInput (F p)) : Circuit (F p) Unit := do

  let enabled := input.enabled
  let timestamp := input.timestamp
  let preState := input.preState

  -- Step 1: Fetch instruction from program memory using FemtoCairo's circuit
  let rawInstruction ← subcircuitWithAssertion (fetchInstructionCircuit program h_programSize) preState.pc

  -- Step 2: Conditionally decode the instruction (returns dummy ADD when disabled)
  let decoded ← conditionalDecode enabled rawInstruction.rawInstrType dummyADDInstruction

  -- Step 3: Unconditionally assert it's an ADD instruction
  -- When enabled=1, this checks the actual instruction is ADD
  -- When enabled=0, this always passes since dummy is ADD
  assertZero (decoded.instrType.isAdd - 1)

  -- Step 4: Read operands from memory using addressing modes
  let v1 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op1,
    mode := decoded.addr1
  }

  let v2 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op2,
    mode := decoded.addr2
  }

  let v3 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op3,
    mode := decoded.addr3
  }

  -- Step 5: Conditional ADD constraint: v3 = v1 + v2 (only when enabled)
  assertZero (enabled * (v3 - (v1 + v2)))

  -- Step 6: Compute next state (pc increments by 4, ap and fp unchanged for ADD)
  let postPc := preState.pc + 4
  let postAp := preState.ap
  let postFp := preState.fp

  -- Step 7: Conditional yield of new execution trace element
  yieldWhen enabled ⟨"execution", [timestamp + 1, postPc, postAp, postFp]⟩

  return ()

/--
Bundle of ADD instruction step circuits.
Takes a vector of inputs with given capacity and executes ADD instructions for each enabled input.
-/
def addStepCircuitsBundle
    (capacity : ℕ)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (inputs : Vector (Var InstructionStepInput (F p)) capacity) : Circuit (F p) Unit := do
  -- Process each input
  for h : i in [0:capacity] do
    addStepCircuit program h_programSize memory h_memorySize inputs[i]
  return ()

-- Future: mulStepCircuitsBundle, loadStateStepCircuitsBundle, storeStateStepCircuitsBundle

end Examples.PicoCairo
