/-
PicoCairo StoreState Instruction Circuit
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Circuit.Subcircuit
import Clean.Circuit.Loops
import Clean.Examples.PicoCairo.Types
import Clean.Examples.PicoCairo.Helpers
import Clean.Examples.FemtoCairo.FemtoCairo
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.Spec
import Clean.Gadgets.Conditional
import Clean.Gadgets.IsZeroField
import Clean.Gadgets.Boolean
import Batteries.Data.Vector.Lemmas

namespace Examples.PicoCairo

open Examples.FemtoCairo
open Examples.FemtoCairo.Types
open Examples.FemtoCairo.Spec

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Main circuit for StoreState instruction step.
Takes enabled flag, timestamp, and pre-state.
If enabled and instruction at pc is StoreState, enforces that operands match state values and yields trace element.
-/
def storeStateStepCircuitMain
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : Var InstructionStepInput (F p)) : Circuit (F p) Unit := do

  let enabled := input.enabled
  let timestamp := input.timestamp
  let preState := input.preState

  -- Step 1: Assert enabled is boolean (0 or 1)
  assertBool enabled

  -- Step 1b: Conditionally use the preState from yielded execution trace
  useWhen enabled ⟨"execution", [timestamp, preState.pc, preState.ap, preState.fp]⟩

  -- Step 2: Check that timestamp + 1 is not zero (prevent overflow)
  let timestampPlusOneIsZero ← subcircuit Gadgets.IsZeroField.circuit (timestamp + 1)
  assertZero timestampPlusOneIsZero

  -- Step 3: Fetch instruction from program memory
  let rawInstr ← subcircuitWithAssertion (fetchInstructionCircuit program h_programSize) preState.pc

  -- Step 4: Conditionally decode instruction (only when enabled)
  let decoded ← subcircuitWithAssertion conditionalDecodeCircuit {
    enabled := enabled,
    rawInstrType := rawInstr.rawInstrType,
    dummy := dummyStoreStateInstruction
  }

  -- Step 5: Assert this is a StoreState instruction (type = 2)
  assertZero (decoded.instrType.isStoreState + (-1))

  -- Step 6: Read values from operands 1, 2, 3
  let v1 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstr.op1,
    mode := decoded.mode1
  }

  let v2 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstr.op2,
    mode := decoded.mode2
  }

  let v3 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstr.op3,
    mode := decoded.mode3
  }

  -- Step 7: StoreState constraint: v1 must equal pc, v2 must equal ap, v3 must equal fp
  -- These are conditional constraints that only apply when enabled
  assertZero (enabled * (v1 - preState.pc))
  assertZero (enabled * (v2 - preState.ap))
  assertZero (enabled * (v3 - preState.fp))

  -- Step 8: Yield new execution state (pc advances by 4, ap and fp unchanged)
  yieldWhen enabled ⟨"execution", [timestamp + 1, preState.pc + 4, preState.ap, preState.fp]⟩

/--
Computes the localYields for a single StoreState instruction step.
If enabled, yields the new execution state; otherwise yields nothing.
-/
def storeStateStepLocalYields (input : InstructionStepInput (F p)) : Set (NamedList (F p)) :=
  { nl | input.enabled ≠ 0 ∧
         nl = ⟨"execution", [input.timestamp + 1,
                            input.preState.pc + 4,
                            input.preState.ap,
                            input.preState.fp]⟩ }

def storeStateStepElaboratedCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) InstructionStepInput unit where
  main := storeStateStepCircuitMain program h_programSize memory h_memorySize
  localLength _ := 29  -- boolean(0) + IsZero(2) + fetch(4) + conditionalDecode(8) + 3×readMemory(5)
  yields input env _ := storeStateStepLocalYields (eval env input)
  yields_eq := by
    intro input env offset
    simp only [storeStateStepLocalYields, storeStateStepCircuitMain, circuit_norm, Gadgets.IsZeroField.circuit, fetchInstructionCircuit, conditionalDecodeCircuit, conditionalDecodeElaborated,
      readFromMemoryCircuit, NamedList.eval]
    aesop

/--
Assumptions for StoreState instruction step (for completeness).
-/
def storeStateStepAssumptions
    {programSize : ℕ} [NeZero programSize]
    (input : InstructionStepInput (F p)) (_yielded : Set (NamedList (F p))) : Prop :=
  IsBool input.enabled ∧
  input.timestamp + 1 ≠ 0 ∧
  ZMod.val (input.preState.pc) + 3 < programSize

/--
Spec for StoreState instruction step (for soundness).
Checks that:
1. If enabled, preState is in yielded execution trace
2. Instruction at pc is valid and is StoreState
3. Operands v1, v2, v3 read correctly and match pc, ap, fp
4. New state is yielded with pc+4, unchanged ap and fp
-/
def storeStateStepSpec
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  if input.enabled = 1 then
    -- Timestamp must not overflow
    input.timestamp + 1 ≠ 0 ∧
    -- When enabled, must have preState in yielded set
    ⟨"execution", [input.timestamp, input.preState.pc, input.preState.ap, input.preState.fp]⟩ ∈ yielded ∧
    match fetchInstruction program input.preState.pc with
    | some rawInstr =>
      match decodeInstruction rawInstr.rawInstrType with
      | some (type, mode1, mode2, mode3) =>
        if type = 2 then
          -- StoreState: type = 2
          match Spec.dataMemoryAccess memory rawInstr.op1 mode1 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op2 mode2 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op3 mode3 input.preState.ap input.preState.fp with
          | some v1, some v2, some v3 =>
            -- StoreState constraint must hold: v1 = pc, v2 = ap, v3 = fp
            v1 = input.preState.pc ∧
            v2 = input.preState.ap ∧
            v3 = input.preState.fp ∧
            localYields = {⟨"execution", [input.timestamp + 1,
                                         input.preState.pc + 4,
                                         input.preState.ap,
                                         input.preState.fp]⟩}
          | _, _, _ => False
        else False
      | none => False
    | none => False
  else
    -- When disabled, no yields
    localYields = ∅

/--
GeneralFormalCircuitUsingYields for StoreState instruction step.
-/
def storeStateStepFormalCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuitUsingYields (F p) InstructionStepInput unit where
  elaborated := storeStateStepElaboratedCircuit program h_programSize memory h_memorySize
  Assumptions := storeStateStepAssumptions (programSize := programSize)
  Spec := storeStateStepSpec program memory

  soundness := by
    circuit_proof_start [storeStateStepSpec, storeStateStepElaboratedCircuit, storeStateStepCircuitMain,
      assertBool, Gadgets.IsZeroField.circuit, Gadgets.IsZeroField.Assumptions, Gadgets.IsZeroField.Spec,
      fetchInstructionCircuit, conditionalDecodeCircuit, readFromMemoryCircuit]
    rcases h_holds with ⟨ h_bool, h_holds ⟩
    rcases h_bool with h_zero | h_one
    · simp only [h_zero, storeStateStepLocalYields]
      subst h_zero
      simp_all only [ne_eq, not_true_eq_false, IsEmpty.forall_iff, id_eq, ↓reduceIte, DecodedInstruction.mk.injEq,
        zero_mul, and_self, and_true, true_and, zero_ne_one, false_and, Set.setOf_false]
    · subst h_one
      simp only [↓reduceIte, storeStateStepLocalYields]
      rcases h_holds with ⟨ h_use, h_iszero, h_nonzero, h_fetch, h_decode, h_isstore, h_read1, h_read2, h_read3, h_v1, h_v2, h_v3 ⟩
      simp only [ne_eq, one_ne_zero, not_false_eq_true, forall_const] at h_use
      constructor
      · simp_all only [id_eq, right_eq_ite_iff, zero_ne_one, imp_false, one_ne_zero, ↓reduceIte, one_mul, ne_eq,
        not_false_eq_true]
      constructor
      · simp_all only [id_eq, right_eq_ite_iff, zero_ne_one, imp_false, one_ne_zero, ↓reduceIte, one_mul]
        obtain ⟨left, right⟩ := h_input
        obtain ⟨left_1, right⟩ := right
        subst right left_1
        exact h_use
      clear h_use
      -- manual decomposition because State is not ProvableStruct
      rcases input_var_preState with ⟨ input_var_pc, input_var_ap, input_var_fp ⟩
      rcases input_preState with ⟨ input_pc, input_ap, input_fp ⟩
      simp only [circuit_norm, explicit_provable_type, State.mk.injEq] at h_input
      simp only [h_input] at h_fetch
      simp only
      cases h : fetchInstruction program input_pc
      · simp only [h] at h_fetch
      -- not indenting for heavy interesting case
      simp only [h] at h_fetch
      subst h_fetch
      simp only
      specialize h_decode (by simp only [circuit_norm])
      simp only [one_ne_zero, ↓reduceIte, decodeInstructionSpec] at h_decode
      simp only [circuit_norm, explicit_provable_type]
      cases h2 : decodeInstruction (env.get (i₀ + 2))
      · simp only [h2] at h_decode
      -- not indenting for heavy interesting case
      simp only [h2] at h_decode
      rename_i decoded
      rcases decoded with ⟨ type, mode1', mode2', mode3' ⟩
      simp only at h_decode ⊢
      simp only [circuit_norm, explicit_provable_type] at h_decode h_isstore
      rcases h_decode with ⟨ h_decode_type, h_decode ⟩
      -- there should be a tactic for naming outputs of elaborated circuits
      cases decoded : @ElaboratedCircuit.output (F p) ConditionalDecodeInput DecodedInstruction (instFieldFOfFactPrime p)
        ProvableType.fromStruct ProvableType.fromStruct conditionalDecodeElaborated
        { enabled := input_var_enabled, rawInstrType := var { index := i₀ + 2 }, dummy := dummyStoreStateInstruction } (i₀ + 2 + 4)
      rename_i decoded_instr_type decoded_mode1 decoded_mode2 decoded_mode3
      simp only [decoded] at h_decode_type h_isstore h_read1 h_read2 h_read3 h_decode
      cases decoded_instr_type
      simp only at h_decode_type h_isstore
      simp only [DecodedInstructionType.val] at h_decode_type
      rw [if_neg] at h_decode_type
      swap
      · simp only at h_decode
        rcases h_decode with ⟨ h_encoded_correctly, h_decode ⟩
        clear h_iszero h_nonzero h_v1 h_v2 h_v3 h_read1 h_read2 h_read3 h_decode
        subst h_decode_type
        rcases h_encoded_correctly with h_encoded_add | h_encoded_mul | h_encoded_store | h_encoded_load
        · simp_all only [not_true_eq_false, zero_add, neg_eq_zero, one_ne_zero]
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [zero_ne_one, not_false_eq_true]
      rw [if_neg] at h_decode_type
      swap
      · simp only at h_decode
        rcases h_decode with ⟨ h_encoded_correctly, h_decode ⟩
        clear h_iszero h_nonzero h_v1 h_v2 h_v3 h_read1 h_read2 h_read3 h_decode
        subst h_decode_type
        rcases h_encoded_correctly with h_encoded_add | h_encoded_mul | h_encoded_store | h_encoded_load
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [not_true_eq_false, zero_add, neg_eq_zero, one_ne_zero]
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [zero_ne_one, not_false_eq_true]
      rw [if_pos] at h_decode_type
      swap
      · grind
      subst h_decode_type
      simp only [↓reduceIte]
      specialize h_read1 (by aesop)
      specialize h_read2 (by aesop)
      specialize h_read3 (by aesop)
      rcases h_decode with ⟨ h_correct, h_mode1', h_correct1, h_mode2', h_correct2, h_mode3', h_correct3 ⟩
      cases h_access1 : dataMemoryAccess memory (env.get (i₀ + 2 + 1)) mode1' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read1
        subst h_mode1'
        simp_all
      rename_i v1
      cases h_access2 : dataMemoryAccess memory (env.get (i₀ + 2 + 1 + 1)) mode2' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read2
        subst h_mode2'
        simp_all
      rename_i v2
      cases h_access3 : dataMemoryAccess memory (env.get (i₀ + 2 + 1 + 1 + 1)) mode3' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read3
        subst h_mode3'
        simp_all
      rename_i v3
      subst h_mode1' h_mode2' h_mode3'
      simp only [circuit_norm, explicit_provable_type] at h_read1 h_read2 h_read3 h_v1 h_v2 h_v3
      constructor
      · grind only
      constructor
      · grind only
      constructor
      · grind only
      · simp_all

  -- Postponed: assumptions are missing about well-formedness of the program, etc.
  -- Yield/use is more interesting in soundness.
  completeness := by sorry

/--
Predicate stating that a named list represents a valid StoreState instruction execution.
This captures the relationship between a pre-state, the instruction execution, and the resulting yield.
-/
def IsValidStoreStateExecution
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (preState : State (F p))
    (timestamp : F p)
    (nl : NamedList (F p)) : Prop :=
  ∃ (rawInstr : RawInstruction (F p)) (mode1 mode2 mode3 : ℕ) (v1 v2 v3 : F p),
    Spec.fetchInstruction program preState.pc = some rawInstr ∧
    Spec.decodeInstruction rawInstr.rawInstrType = some (2, mode1, mode2, mode3) ∧
    Spec.dataMemoryAccess memory rawInstr.op1 mode1 preState.ap preState.fp = some v1 ∧
    Spec.dataMemoryAccess memory rawInstr.op2 mode2 preState.ap preState.fp = some v2 ∧
    Spec.dataMemoryAccess memory rawInstr.op3 mode3 preState.ap preState.fp = some v3 ∧
    v1 = preState.pc ∧
    v2 = preState.ap ∧
    v3 = preState.fp ∧
    nl = ⟨"execution", [timestamp + 1, preState.pc + 4, preState.ap, preState.fp]⟩

/--
Characterization theorem for StoreState instruction localYields.
If something is in localYields and the spec holds, we can extract witnesses for all the conditions.
This is useful for inductive reasoning about execution traces.
-/
theorem storeStateStepSpec_localYields_characterization
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p)))
    (localYields : Set (NamedList (F p)))
    (nl : NamedList (F p))
    (h_spec : storeStateStepSpec program memory input yielded () localYields)
    (h_mem : nl ∈ localYields) :
    input.enabled = 1 ∧
    input.timestamp + 1 ≠ 0 ∧
    ⟨"execution", [input.timestamp, input.preState.pc, input.preState.ap, input.preState.fp]⟩ ∈ yielded ∧
    IsValidStoreStateExecution program memory input.preState input.timestamp nl := by
  simp only [storeStateStepSpec] at h_spec
  simp only [IsValidStoreStateExecution]
  by_cases h_enabled : input.enabled = 1
  swap -- error case first
  · aesop
  simp only [h_enabled] at *
  simp only [↓reduceIte, ne_eq, if_false_right] at h_spec
  simp only [ne_eq, exists_and_left, existsAndEq, true_and]
  rcases h_spec with ⟨ h_overflow, h_spec ⟩
  constructor
  · simp_all
  rcases h_spec with ⟨ h_use, h_spec ⟩
  constructor
  · simp_all
  cases h_fetched : fetchInstruction program input.preState.pc
  · simp_all
  rename_i rawInstr
  use rawInstr
  constructor
  · rfl
  simp only [h_fetched] at h_spec
  cases h_decoded : decodeInstruction rawInstr.rawInstrType
  · simp_all
  rename_i decoded
  rcases decoded with ⟨ typ, mode1, mode2, mode3 ⟩
  simp only [h_decoded] at h_spec
  use mode1, mode2, mode3
  constructor
  · grind
  cases h_access1 : dataMemoryAccess memory rawInstr.op1 mode1 input.preState.ap input.preState.fp
  · grind
  cases h_access2 : dataMemoryAccess memory rawInstr.op2 mode2 input.preState.ap input.preState.fp
  · grind
  cases h_access3 : dataMemoryAccess memory rawInstr.op3 mode3 input.preState.ap input.preState.fp
  · grind
  rename_i v1 v2 v3
  simp_all

omit p_large_enough in
/--
Theorem: If IsValidStoreStateExecution holds, then there exists a valid femtoCairoMachineTransition.
This connects the circuit specification to the machine semantics.
-/
theorem IsValidStoreStateExecution_implies_valid_transition
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (preState : State (F p))
    (timestamp : F p)
    (nl : NamedList (F p))
    (h_valid : IsValidStoreStateExecution program memory preState timestamp nl) :
    ∃ newState : State (F p),
      Spec.femtoCairoMachineTransition program memory preState = some newState ∧
      nl = ⟨"execution", [timestamp + 1, newState.pc, newState.ap, newState.fp]⟩ := by
  simp only [IsValidStoreStateExecution] at h_valid
  rcases h_valid with ⟨rawInstr, mode1, mode2, mode3, v1, v2, v3, h_fetch, h_decode, h_access1, h_access2, h_access3, h_v1, h_v2, h_v3, h_nl⟩
  use { pc := preState.pc + 4, ap := preState.ap, fp := preState.fp }
  constructor
  · simp only [Spec.femtoCairoMachineTransition, Option.bind_eq_bind, h_fetch]
    simp only [h_decode, Option.bind_some, h_access1, h_access2, h_access3, computeNextState]
    aesop
  · exact h_nl

/--
Bundle of StoreState instruction step circuits.
Takes a vector of inputs with given capacity and executes StoreState instructions for each enabled input.
-/
def storeStateStepCircuitsBundle
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (inputs : Var (ProvableVector InstructionStepInput capacity) (F p)) : Circuit (F p) Unit := do
  let _ ← Circuit.mapFinRange capacity fun i =>
    subcircuitWithAssertionUsingYields (storeStateStepFormalCircuit program h_programSize memory h_memorySize) inputs[i.val]

/--
Elaborated circuit for StoreState instruction bundle.
-/
def storeStateStepCircuitsBundleElaborated
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) (ProvableVector InstructionStepInput capacity) unit where
  main := storeStateStepCircuitsBundle capacity program h_programSize memory h_memorySize
  localLength _ := capacity * 29  -- Each step uses 29 locals
  localLength_eq := by
    intros input offset
    simp only [circuit_norm, storeStateStepCircuitsBundle]
    congr 1
  yields inputs env offset :=
    ⋃ i : Fin capacity, storeStateStepLocalYields (eval env inputs[i])
  yields_eq := by
    intros inputs env offset
    simp only [circuit_norm, storeStateStepCircuitsBundle]
    ext nl
    simp only [Set.mem_iUnion]
    constructor
    · intro ⟨i, hi⟩
      use i
      simp only [storeStateStepFormalCircuit, storeStateStepElaboratedCircuit, circuit_norm] at hi
      exact hi
    · intro ⟨i, hi⟩
      use i
      simp only [storeStateStepFormalCircuit, storeStateStepElaboratedCircuit, circuit_norm]
      exact hi
  subcircuitsConsistent := by
    intros inputs offset
    simp only [circuit_norm, storeStateStepCircuitsBundle]

/--
Assumptions for the bundle: each input must satisfy the individual step assumptions.
-/
def storeStateStepCircuitsBundleAssumptions
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize]
    (inputs : ProvableVector InstructionStepInput capacity (F p)) (_yielded : Set (NamedList (F p))) : Prop :=
  ∀ i : Fin capacity, storeStateStepAssumptions (programSize := programSize) inputs[i] _yielded

/--
Spec for the bundle: each element satisfies its step spec, and local yields are the union.
-/
def storeStateStepCircuitsBundleSpec
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (inputs : ProvableVector InstructionStepInput capacity (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  (∀ i : Fin capacity, storeStateStepSpec program memory inputs[i] yielded () (storeStateStepLocalYields inputs[i])) ∧
  localYields = ⋃ i : Fin capacity, storeStateStepLocalYields inputs[i]

/--
GeneralFormalCircuitUsingYields for StoreState instruction bundle.
-/
def storeStateStepCircuitsBundleFormalCircuit
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuitUsingYields (F p) (ProvableVector InstructionStepInput capacity) unit where
  elaborated := storeStateStepCircuitsBundleElaborated capacity program h_programSize memory h_memorySize
  Assumptions := storeStateStepCircuitsBundleAssumptions capacity (programSize := programSize)
  Spec := storeStateStepCircuitsBundleSpec capacity program memory
  soundness := by
    circuit_proof_start [storeStateStepCircuitsBundleElaborated, storeStateStepCircuitsBundleSpec]
    simp only [storeStateStepCircuitsBundle, circuit_norm, storeStateStepFormalCircuit] at h_holds
    and_intros
    · intro i
      specialize h_holds i
      simp only [storeStateStepElaboratedCircuit] at h_holds
      simp only [Fin.eta] at h_holds
      cases iv_h : Vector.get input_var i
      rename_i enabledVar timestampVar preStateVar
      simp only [iv_h] at h_holds
      simp only [← h_input, eval_vector, Vector.getElem_map]
      rw [Vector.get_eq_getElem] at iv_h
      conv =>
        arg 3
        simp only [iv_h]
        simp only [circuit_norm]
      assumption
    · apply Set.iUnion_congr
      intro i
      congr 1
      simp only [← h_input, eval_vector, Vector.getElem_map]
      cases iv_h : Vector.get input_var i
      rename_i enabledVar timestampVar preStateVar
      rw [Vector.get_eq_getElem] at iv_h
      simp only [iv_h]
      conv_rhs =>
        simp only [circuit_norm]
  completeness := sorry

/--
Characterization theorem for StoreState instruction bundle localYields.
Given a bundle spec and a named list in the local yields, we can find which instruction index it came from
and extract witnesses for all the conditions.
-/
theorem storeStateStepCircuitsBundleSpec_localYields_characterization
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (inputs : ProvableVector InstructionStepInput capacity (F p)) (yielded : Set (NamedList (F p)))
    (localYields : Set (NamedList (F p)))
    (nl : NamedList (F p))
    (h_spec : storeStateStepCircuitsBundleSpec capacity program memory inputs yielded () localYields)
    (h_mem : nl ∈ localYields) :
    -- Then we can find an index i such that the conditions hold for inputs[i]
    ∃ (i : Fin capacity),
      inputs[i].enabled = 1 ∧
      inputs[i].timestamp + 1 ≠ 0 ∧
      ⟨"execution", [inputs[i].timestamp, inputs[i].preState.pc, inputs[i].preState.ap, inputs[i].preState.fp]⟩ ∈ yielded ∧
      IsValidStoreStateExecution program memory inputs[i].preState inputs[i].timestamp nl := by
  simp only [storeStateStepCircuitsBundleSpec] at h_spec
  rcases h_spec with ⟨h_all, h_yields⟩
  rw [h_yields] at h_mem
  simp only [Set.mem_iUnion] at h_mem
  rcases h_mem with ⟨i, h_i⟩
  use i
  exact storeStateStepSpec_localYields_characterization program memory inputs[i] yielded (storeStateStepLocalYields inputs[i]) nl (h_all i) h_i

end Examples.PicoCairo
