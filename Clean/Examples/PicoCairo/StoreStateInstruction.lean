/-
PicoCairo StoreState Instruction Circuit
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Circuit.Subcircuit
import Clean.Examples.PicoCairo.Types
import Clean.Examples.PicoCairo.Helpers
import Clean.Examples.FemtoCairo.FemtoCairo
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.Spec
import Clean.Gadgets.Conditional
import Clean.Gadgets.IsZeroField
import Clean.Gadgets.Boolean

namespace Examples.PicoCairo

open Examples.FemtoCairo
open Examples.FemtoCairo.Types
open Examples.FemtoCairo.Spec

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Main circuit for StoreState instruction step.
Takes enabled flag, timestamp, and pre-state.
If enabled and instruction at pc is StoreState, enforces that operands match state values and yields trace element.
-/
def storeStateStepCircuitMain
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : Var InstructionStepInput (F p)) : Circuit (F p) Unit := do

  let enabled := input.enabled
  let timestamp := input.timestamp
  let preState := input.preState

  -- Step 1: Assert enabled is boolean (0 or 1)
  assertBool enabled

  -- Step 1b: Conditionally use the preState from yielded execution trace
  useWhen enabled ⟨"execution", [timestamp, preState.pc, preState.ap, preState.fp]⟩

  -- Step 2: Check that timestamp + 1 is not zero (prevent overflow)
  let timestampPlusOneIsZero ← subcircuit Gadgets.IsZeroField.circuit (timestamp + 1)
  assertZero timestampPlusOneIsZero

  -- Step 3: Fetch instruction from program memory
  let rawInstr ← subcircuitWithAssertion (fetchInstructionCircuit program h_programSize) preState.pc

  -- Step 4: Conditionally decode instruction (only when enabled)
  let decoded ← subcircuitWithAssertion conditionalDecodeCircuit {
    enabled := enabled,
    rawInstrType := rawInstr.rawInstrType,
    dummy := dummyStoreStateInstruction
  }

  -- Step 5: Assert this is a StoreState instruction (type = 2)
  assertZero (decoded.instrType.isStoreState + (-1))

  -- Step 6: Read values from operands 1, 2, 3
  let v1 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstr.op1,
    mode := decoded.mode1
  }

  let v2 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstr.op2,
    mode := decoded.mode2
  }

  let v3 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstr.op3,
    mode := decoded.mode3
  }

  -- Step 7: StoreState constraint: v1 must equal pc, v2 must equal ap, v3 must equal fp
  -- These are conditional constraints that only apply when enabled
  assertZero (enabled * (v1 - preState.pc))
  assertZero (enabled * (v2 - preState.ap))
  assertZero (enabled * (v3 - preState.fp))

  -- Step 8: Yield new execution state (pc advances by 4, ap and fp unchanged)
  yieldWhen enabled ⟨"execution", [timestamp + 1, preState.pc + 4, preState.ap, preState.fp]⟩

def storeStateStepElaboratedCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) InstructionStepInput unit where
  main := storeStateStepCircuitMain program h_programSize memory h_memorySize
  localLength _ := 29  -- boolean(0) + IsZero(2) + fetch(4) + conditionalDecode(8) + 3×readMemory(5)
  yields input env _ := {
    nl | env input.enabled ≠ 0 ∧
         nl = ⟨"execution", [env (input.timestamp + 1),
                             env (input.preState.pc + 4),
                             env input.preState.ap,
                             env input.preState.fp]⟩
  }
  yields_eq := by
    intro input env offset
    simp only [storeStateStepCircuitMain, circuit_norm, Gadgets.IsZeroField.circuit, fetchInstructionCircuit, conditionalDecodeCircuit, conditionalDecodeElaborated,
      readFromMemoryCircuit, NamedList.eval]
    aesop

/--
Assumptions for StoreState instruction step (for completeness).
-/
def storeStateStepAssumptions
    {programSize : ℕ} [NeZero programSize]
    (input : InstructionStepInput (F p)) (_yielded : Set (NamedList (F p))) : Prop :=
  IsBool input.enabled ∧
  input.timestamp + 1 ≠ 0 ∧
  ZMod.val (input.preState.pc) + 3 < programSize

/--
Spec for StoreState instruction step (for soundness).
Checks that:
1. If enabled, preState is in yielded execution trace
2. Instruction at pc is valid and is StoreState
3. Operands v1, v2, v3 read correctly and match pc, ap, fp
4. New state is yielded with pc+4, unchanged ap and fp
-/
def storeStateStepSpec
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  if input.enabled ≠ 0 then
    -- When enabled, must have preState in yielded set
    ⟨"execution", [input.timestamp, input.preState.pc, input.preState.ap, input.preState.fp]⟩ ∈ yielded ∧
    match fetchInstruction program input.preState.pc with
    | some rawInstr =>
      match decodeInstruction rawInstr.rawInstrType with
      | some (type, mode1, mode2, mode3) =>
        if type = 2 then
          -- StoreState: type = 2
          match Spec.dataMemoryAccess memory rawInstr.op1 mode1 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op2 mode2 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op3 mode3 input.preState.ap input.preState.fp with
          | some v1, some v2, some v3 =>
            -- StoreState constraint must hold: v1 = pc, v2 = ap, v3 = fp
            v1 = input.preState.pc ∧
            v2 = input.preState.ap ∧
            v3 = input.preState.fp ∧
            localYields = {⟨"execution", [input.timestamp + 1,
                                         input.preState.pc + 4,
                                         input.preState.ap,
                                         input.preState.fp]⟩}
          | _, _, _ => False
        else False
      | none => False
    | none => False
  else
    -- When disabled, no yields
    localYields = ∅

/--
GeneralFormalCircuit for StoreState instruction step.
-/
def storeStateStepFormalCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) InstructionStepInput unit where
  elaborated := storeStateStepElaboratedCircuit program h_programSize memory h_memorySize
  Assumptions := storeStateStepAssumptions (programSize := programSize)
  Spec := storeStateStepSpec program memory

  soundness := by
    circuit_proof_start [storeStateStepSpec, storeStateStepElaboratedCircuit, storeStateStepCircuitMain,
      assertBool, Gadgets.IsZeroField.circuit, Gadgets.IsZeroField.Assumptions, Gadgets.IsZeroField.Spec,
      fetchInstructionCircuit, conditionalDecodeCircuit, readFromMemoryCircuit]
    rcases h_holds with ⟨ h_bool, h_holds ⟩
    rcases h_bool with h_zero | h_one
    · simp only [h_zero, ↓reduceIte, ne_eq, not_true_eq_false, false_and, Set.setOf_false]
    · subst h_one
      simp only [↓reduceIte, ne_eq, one_ne_zero, not_false_eq_true, true_and,
        Set.setOf_eq_eq_singleton, Set.singleton_eq_singleton_iff, NamedList.mk.injEq,
        List.cons.injEq, add_left_inj, and_true]
      rcases h_holds with ⟨ h_use, h_iszero, h_nonzero, h_fetch, h_decode, h_isstore, h_read1, h_read2, h_read3, h_v1, h_v2, h_v3 ⟩
      simp only [ne_eq, one_ne_zero, not_false_eq_true, forall_const] at h_use
      constructor
      · simp_all only [id_eq, right_eq_ite_iff, zero_ne_one, imp_false, one_ne_zero, ↓reduceIte, one_mul]
        obtain ⟨left, right⟩ := h_input
        obtain ⟨left_1, right⟩ := right
        subst right left_1
        exact h_use
      clear h_use
      -- manual decomposition because State is not ProvableStruct
      rcases input_var_preState with ⟨ input_var_pc, input_var_ap, input_var_fp ⟩
      rcases input_preState with ⟨ input_pc, input_ap, input_fp ⟩
      simp only [circuit_norm, explicit_provable_type, State.mk.injEq] at h_input
      simp only [h_input] at h_fetch
      simp only
      cases h : fetchInstruction program input_pc
      · simp only [h] at h_fetch
      -- not indenting for heavy interesting case
      simp only [h] at h_fetch
      subst h_fetch
      simp only
      specialize h_decode (by simp only [circuit_norm])
      simp only [one_ne_zero, ↓reduceIte, decodeInstructionSpec] at h_decode
      simp only [circuit_norm, explicit_provable_type]
      cases h2 : decodeInstruction (env.get (i₀ + 2))
      · simp only [h2] at h_decode
      -- not indenting for heavy interesting case
      simp only [h2] at h_decode
      rename_i decoded
      rcases decoded with ⟨ type, mode1', mode2', mode3' ⟩
      simp only at h_decode ⊢
      simp only [circuit_norm, explicit_provable_type] at h_decode h_isstore
      rcases h_decode with ⟨ h_decode_type, h_decode ⟩
      -- there should be a tactic for naming outputs of elaborated circuits
      cases decoded : @ElaboratedCircuit.output (F p) ConditionalDecodeInput DecodedInstruction (instFieldFOfFactPrime p)
        ProvableType.fromStruct ProvableType.fromStruct conditionalDecodeElaborated
        { enabled := input_var_enabled, rawInstrType := var { index := i₀ + 2 }, dummy := dummyStoreStateInstruction } (i₀ + 2 + 4)
      rename_i decoded_instr_type decoded_mode1 decoded_mode2 decoded_mode3
      simp only [decoded] at h_decode_type h_isstore h_read1 h_read2 h_read3 h_decode
      cases decoded_instr_type
      simp only at h_decode_type h_isstore
      simp only [DecodedInstructionType.val] at h_decode_type
      -- For StoreState: isAdd=0, isMul=0, so we reach else-else branch
      -- That returns 2 + (if isStoreState = 1 then 0 else ...)
      -- Since isStoreState=1 (from h_isstore), this gives 2, which equals type
      rw [if_neg] at h_decode_type
      swap
      · simp only at h_decode
        rcases h_decode with ⟨ h_encoded_correctly, h_decode ⟩
        clear h_iszero h_nonzero h_v1 h_v2 h_v3 h_read1 h_read2 h_read3 h_decode
        subst h_decode_type
        rcases h_encoded_correctly with h_encoded_add | h_encoded_mul | h_encoded_store | h_encoded_load
        · simp_all only [not_true_eq_false, zero_add, neg_eq_zero, one_ne_zero]
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [zero_ne_one, not_false_eq_true]
      rw [if_neg] at h_decode_type
      swap
      · simp only at h_decode
        rcases h_decode with ⟨ h_encoded_correctly, h_decode ⟩
        clear h_iszero h_nonzero h_v1 h_v2 h_v3 h_read1 h_read2 h_read3 h_decode
        subst h_decode_type
        rcases h_encoded_correctly with h_encoded_add | h_encoded_mul | h_encoded_store | h_encoded_load
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [not_true_eq_false, zero_add, neg_eq_zero, one_ne_zero]
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [zero_ne_one, not_false_eq_true]
      rw [if_pos] at h_decode_type
      swap
      · grind
      subst h_decode_type
      simp only [↓reduceIte]
      specialize h_read1 (by aesop)
      specialize h_read2 (by aesop)
      specialize h_read3 (by aesop)
      rcases h_decode with ⟨ h_correct, h_mode1', h_correct1, h_mode2', h_correct2, h_mode3', h_correct3 ⟩
      cases h_access1 : dataMemoryAccess memory (env.get (i₀ + 2 + 1)) mode1' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read1
        subst h_mode1'
        simp_all
      rename_i v1
      cases h_access2 : dataMemoryAccess memory (env.get (i₀ + 2 + 1 + 1)) mode2' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read2
        subst h_mode2'
        simp_all
      rename_i v2
      cases h_access3 : dataMemoryAccess memory (env.get (i₀ + 2 + 1 + 1 + 1)) mode3' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read3
        subst h_mode3'
        simp_all
      rename_i v3
      subst h_mode1' h_mode2' h_mode3'
      simp only [circuit_norm, explicit_provable_type] at h_read1 h_read2 h_read3 h_v1 h_v2 h_v3
      constructor
      · grind only
      constructor
      · grind only
      constructor
      · grind only
      · simp_all

  -- Postponed: assumptions are missing about well-formedness of the program, etc.
  -- Yield/use is more interesting in soundness.
  completeness := by sorry

/--
Bundle of StoreState instruction step circuits.
Takes a vector of inputs with given capacity and executes StoreState instructions for each enabled input.
-/
def storeStateStepCircuitsBundle
    (capacity : ℕ)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (inputs : Vector (Var InstructionStepInput (F p)) capacity) : Circuit (F p) Unit := do
  -- Process each input using the formal circuit
  for h : i in [0:capacity] do
    subcircuitWithAssertion (storeStateStepFormalCircuit program h_programSize memory h_memorySize) inputs[i]

end Examples.PicoCairo
