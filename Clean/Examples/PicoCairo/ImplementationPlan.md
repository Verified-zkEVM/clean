# PicoCairo ADD Instruction Implementation Plan

*Generated by Claude*

## Overview

This document outlines the implementation plan for the ADD instruction in PicoCairo, focusing on conditional execution using the `enabled` flag.

## Key Design Principle

**All assertions and constraints must be conditional on the `enabled` flag** - they should only be enforced when `enabled ≠ 0`.

## Implementation Components

### 1. Conditional Decode Helper

```lean
/--
Helper to conditionally select between two values based on enabled flag.
Returns: enabled * whenEnabled + (1 - enabled) * whenDisabled
-/
def conditionalSelect (enabled : Var field (F p)) (whenEnabled whenDisabled : Expression (F p)) : Expression (F p) :=
  enabled * whenEnabled + (1 - enabled) * whenDisabled
```

### 2. Dummy ADD Instruction Definition

```lean
/--
A dummy ADD instruction with immediate addressing for all operands.
Used as default when instruction is disabled.
-/
def dummyADDInstruction : DecodedInstruction (F p) := {
  instrType := {
    isAdd := 1,
    isMul := 0,
    isStoreState := 0,
    isLoadState := 0
  },
  addr1 := {
    isImmediate := 1,
    isDoubleAddressing := 0,
    isApRelative := 0,
    isFpRelative := 0
  },
  addr2 := {
    isImmediate := 1,
    isDoubleAddressing := 0,
    isApRelative := 0,
    isFpRelative := 0
  },
  addr3 := {
    isImmediate := 1,
    isDoubleAddressing := 0,
    isApRelative := 0,
    isFpRelative := 0
  }
}
```

### 3. Conditional Decode Circuit (Optional - for full implementation)

```lean
def conditionalDecodeInstructionCircuit
    (dummyOutput : DecodedInstruction (F p)) :
    GeneralFormalCircuit (F p) (field × field) DecodedInstruction where
  main := fun (enabled, instruction) => do
    -- Get actual decode result
    let actualDecoded ← decodeInstructionCircuit instruction

    -- Return: enabled * actualDecoded + (1 - enabled) * dummyOutput
    -- (Implementation details omitted for brevity)

  Assumptions := fun (enabled, instruction) _ =>
    enabled = 0 ∨ enabled = 1  -- enabled is boolean

  Spec := fun (enabled, instruction) _ output _ =>
    if enabled = 0 then
      output = dummyOutput
    else
      decodeInstructionCircuit.Spec instruction _ output _
```

### 4. Simple ADD Step Circuit Implementation

```lean
def addStepCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : Var InstructionStepInput (F p)) : Circuit (F p) Unit := do

  let enabled := input.enabled
  let timestamp := input.timestamp
  let preState := input.preState

  -- Step 1: Fetch instruction from program memory
  let rawInstrType ← witness fun eval => program <| Fin.ofNat _ (eval preState.pc).val
  let op1 ← witness fun eval => program <| Fin.ofNat _ (eval (preState.pc + 1)).val
  let op2 ← witness fun eval => program <| Fin.ofNat _ (eval (preState.pc + 2)).val
  let op3 ← witness fun eval => program <| Fin.ofNat _ (eval (preState.pc + 3)).val

  -- Step 2: Conditionally check it's ADD (type 0)
  assertZero (enabled * rawInstrType)

  -- Step 3: Read operands from memory (simple immediate addressing)
  let v1 ← witness fun eval => memory <| Fin.ofNat _ (eval op1).val
  let v2 ← witness fun eval => memory <| Fin.ofNat _ (eval op2).val
  let v3 ← witness fun eval => memory <| Fin.ofNat _ (eval op3).val

  -- Step 4: Conditional ADD constraint
  assertZero (enabled * (v3 - (v1 + v2)))

  -- Step 5: Compute next state
  let postState : Var (FemtoCairo.Types.State (F p)) := {
    pc := preState.pc + 4,
    ap := preState.ap,
    fp := preState.fp
  }

  -- Step 6: Conditional yield
  yield enabled ⟨"execution", [timestamp + 1, postState.pc, postState.ap, postState.fp]⟩
```

## Conditional Execution Patterns

### Pattern 1: Conditional Assertion
```lean
-- Instead of: assertZero expr
-- Use: assertZero (enabled * expr)
```

### Pattern 2: Conditional Selection
```lean
-- To select between values based on enabled:
let value := enabled * enabledValue + (1 - enabled) * disabledValue
```

### Pattern 3: Conditional Yield
```lean
-- The yield operation already supports enabled parameter:
yield enabled ⟨name, values⟩
```

## Implementation Phases

### Phase 1: Basic Implementation (Current)
1. Implement simple ADD circuit without FemtoCairo integration
2. Use direct witness generation for instruction fetch
3. Assume immediate addressing only
4. Test with simple examples

### Phase 2: FemtoCairo Integration (Future)
1. Import and reuse `fetchInstructionCircuit`
2. Implement `conditionalDecodeInstructionCircuit`
3. Reuse `readFromMemoryCircuit` with addressing modes
4. Support full instruction set

### Phase 3: Complete Bundle (Future)
1. Add MUL, LOAD_STATE, STORE_STATE circuits
2. Implement full execution bundle
3. Add witness generation helpers
4. Create comprehensive tests

## Testing Strategy

### Test Case 1: Enabled ADD
```lean
-- Input:
enabled = 1
preState = { pc = 0, ap = 100, fp = 200 }
program[0] = 0  -- ADD instruction
program[1] = 10 -- op1 address
program[2] = 11 -- op2 address
program[3] = 12 -- op3 address
memory[10] = 5
memory[11] = 7
memory[12] = 12

-- Expected:
Yields: ("execution", [1, 4, 100, 200])
Constraint: 12 = 5 + 7 ✓
```

### Test Case 2: Disabled ADD
```lean
-- Input:
enabled = 0
preState = { pc = 0, ap = 100, fp = 200 }
program[0] = 99 -- Not ADD (doesn't matter)
-- Other values arbitrary

-- Expected:
No yields
No constraints enforced
```

## Key Invariants

1. **Enabled Boolean**: Assumption that `enabled ∈ {0, 1}`
2. **Conditional Constraints**: All assertions multiplied by `enabled`
3. **Safe Fetching**: Instruction fetch works regardless of `enabled`
4. **Dummy Safety**: When disabled, dummy values don't affect correctness

## Future Extensions

1. **Full Instruction Set**: Extend pattern to MUL, LOAD_STATE, STORE_STATE
2. **Addressing Modes**: Support all FemtoCairo addressing modes
3. **Memory Consistency**: Add memory write tracking
4. **Formal Verification**: Prove soundness and completeness theorems
5. **Optimizations**: Reduce constraint count when disabled

## Code Reuse from FemtoCairo

### Can Reuse Directly
- `fetchInstructionCircuit` - Safe to use even when disabled
- `ReadOnlyTableFromFunction` - For program/memory tables

### Need Conditional Wrapper
- `decodeInstructionCircuit` - Wrap to return dummy when disabled
- `readFromMemoryCircuit` - Works with dummy addressing modes

### Need Reimplementation
- State transition logic - Simplified for PicoCairo
- Constraint system - All constraints must be conditional
- Yield mechanism - New in PicoCairo

## Notes

- This plan prioritizes simplicity over completeness for initial implementation
- The GeneralFormalCircuit approach provides better formal guarantees but is more complex
- Starting with Circuit monad implementation allows faster prototyping
- The conditional execution pattern can be extended to all instruction types