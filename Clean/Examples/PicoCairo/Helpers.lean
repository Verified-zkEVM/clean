/-
PicoCairo Helper Functions
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Circuit.Subcircuit
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.FemtoCairo
import Clean.Gadgets.Conditional

namespace Examples.PicoCairo

open Examples.FemtoCairo
open Examples.FemtoCairo.Types

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Conditionally decode instruction based on enabled flag.
When enabled is 0, returns the provided dummy instruction.
When enabled is 1, returns the actual decoded instruction.
-/
def conditionalDecode
    (enabled : Expression (F p))
    (rawInstrType : Expression (F p))
    (dummy : Var DecodedInstruction (F p)) :
    Circuit (F p) (Var DecodedInstruction (F p)) := do

  -- Decode the actual instruction
  let actualDecoded ← subcircuitWithAssertion decodeInstructionCircuit rawInstrType

  -- Use conditional gadget to select between actual and dummy based on enabled
  let result ← subcircuit Gadgets.Conditional.circuit {
    selector := enabled,
    ifTrue := actualDecoded,
    ifFalse := dummy
  }

  return result

/--
Create a dummy ADD instruction with immediate addressing for all operands.
-/
def dummyADDInstruction : Var DecodedInstruction (F p) := {
  instrType := {
    isAdd := 1,
    isMul := 0,
    isStoreState := 0,
    isLoadState := 0
  },
  addr1 := {
    isImmediate := 1,
    isDoubleAddressing := 0,
    isApRelative := 0,
    isFpRelative := 0
  },
  addr2 := {
    isImmediate := 1,
    isDoubleAddressing := 0,
    isApRelative := 0,
    isFpRelative := 0
  },
  addr3 := {
    isImmediate := 1,
    isDoubleAddressing := 0,
    isApRelative := 0,
    isFpRelative := 0
  }
}

end Examples.PicoCairo