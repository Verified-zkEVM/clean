/-
PicoCairo Helper Functions
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Circuit.Subcircuit
import Clean.Circuit.Provable
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.FemtoCairo
import Clean.Examples.FemtoCairo.Spec
import Clean.Gadgets.Conditional

namespace Examples.PicoCairo

open Examples.FemtoCairo
open Examples.FemtoCairo.Types

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Input structure for conditional decode circuit.
Contains enabled flag, raw instruction type, and dummy instruction to use when disabled.
-/
structure ConditionalDecodeInput (F : Type) where
  enabled : F
  rawInstrType : F
  dummy : DecodedInstruction F

instance : ProvableStruct ConditionalDecodeInput where
  components := [field, field, DecodedInstruction]
  toComponents := fun { enabled, rawInstrType, dummy } =>
    .cons enabled (.cons rawInstrType (.cons dummy .nil))
  fromComponents := fun (.cons enabled (.cons rawInstrType (.cons dummy .nil))) =>
    { enabled, rawInstrType, dummy }

/--
Main circuit for conditionally decoding instruction based on enabled flag.
When enabled is 0, returns the provided dummy instruction.
When enabled is 1, returns the actual decoded instruction.
-/
def conditionalDecodeMain
    (input : Var ConditionalDecodeInput (F p)) :
    Circuit (F p) (Var DecodedInstruction (F p)) := do
  let enabled := input.enabled
  let rawInstrType := input.rawInstrType
  let dummy := input.dummy

  -- Decode the actual instruction
  let actualDecoded ← subcircuitWithAssertion decodeInstructionCircuit rawInstrType

  -- Use conditional gadget to select between actual and dummy based on enabled
  let result ← subcircuit Gadgets.Conditional.circuit {
    selector := enabled,
    ifTrue := actualDecoded,
    ifFalse := dummy
  }

  return result

/--
ElaboratedCircuit for conditional decode.
-/
def conditionalDecodeElaborated :
    ElaboratedCircuit (F p) ConditionalDecodeInput DecodedInstruction where
  main := conditionalDecodeMain
  localLength _ := 8  -- Same as decodeInstructionCircuit since Conditional adds 0
  yields_eq := by simp [conditionalDecodeMain, circuit_norm, decodeInstructionCircuit, decodeInstructionElaborated, Gadgets.Conditional.circuit]

/--
Conditional decode circuit as GeneralFormalCircuit.
Takes ConditionalDecodeInput and returns decoded instruction or dummy.
-/
def conditionalDecodeCircuit :
    GeneralFormalCircuit (F p) ConditionalDecodeInput DecodedInstruction where
  elaborated := conditionalDecodeElaborated
  Assumptions := fun input _ =>
    IsBool input.enabled ∧ input.rawInstrType.val < 256
  Spec := fun input yielded output localYields =>
    IsBool input.enabled →
    if input.enabled = 0 then
      output = input.dummy
    else
      decodeInstructionSpec input.rawInstrType yielded output localYields
  soundness := by
    circuit_proof_start [conditionalDecodeElaborated, conditionalDecodeMain, Gadgets.Conditional.circuit, Gadgets.Conditional.Assumptions]
    intro h_assumptions
    rcases h_holds with ⟨ h_decode, h_conditional ⟩
    specialize h_conditional h_assumptions
    simp only [Gadgets.Conditional.Spec] at h_conditional
    simp only [h_conditional]
    rcases h_assumptions with h_zero | h_one
    · aesop
    · simp_all only [id_eq, ↓reduceIte, DecodedInstruction.mk.injEq, one_ne_zero]
      simp only [decodeInstructionCircuit, decodeInstructionElaborated] at h_decode
      exact h_decode
  completeness := by
    circuit_proof_all [conditionalDecodeElaborated, conditionalDecodeMain, decodeInstructionCircuit, Gadgets.Conditional.circuit, Gadgets.Conditional.Assumptions]

/--
Create a dummy ADD instruction with immediate addressing for all operands.
-/
def dummyADDInstruction : Var DecodedInstruction (F p) := {
  instrType := {
    isAdd := Expression.const 1,
    isMul := Expression.const 0,
    isStoreState := Expression.const 0,
    isLoadState := Expression.const 0
  },
  mode1 := {
    isImmediate := Expression.const 1,
    isDoubleAddressing := Expression.const 0,
    isApRelative := Expression.const 0,
    isFpRelative := Expression.const 0
  },
  mode2 := {
    isImmediate := Expression.const 1,
    isDoubleAddressing := Expression.const 0,
    isApRelative := Expression.const 0,
    isFpRelative := Expression.const 0
  },
  mode3 := {
    isImmediate := Expression.const 1,
    isDoubleAddressing := Expression.const 0,
    isApRelative := Expression.const 0,
    isFpRelative := Expression.const 0
  }
}

end Examples.PicoCairo
