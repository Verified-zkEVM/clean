# PicoCairo: Yield-Based Cairo Execution Traces

*Generated by Claude*

## Overview

PicoCairo is an alternative approach to proving Cairo execution traces. While FemtoCairo uses table-based lookups to represent execution traces, PicoCairo uses yielded execution states. Each step of execution is expressed as a yielded element of the form `("execution", [timestamp, pc, ap, fp])`.

## Architecture

### Core Concepts

1. **Execution Trace as Yields**: Each execution step is represented as a yielded NamedList:
   ```lean
   yield ("execution", [timestamp, pc, ap, fp])
   ```

2. **Instruction-Specific Circuits**: Each Cairo instruction type has its own circuit that:
   - Takes an `enabled` flag, timestamp, and pre-state as input
   - Verifies the instruction at pc matches its type
   - Computes the post-state according to instruction semantics
   - Conditionally yields the new state when `enabled ≠ 0`

3. **Execution Bundle**: A fixed collection of instruction circuits:
   - N copies of ADD instruction circuit
   - N copies of MUL instruction circuit
   - N copies of LOAD_STATE instruction circuit
   - N copies of STORE_STATE instruction circuit

4. **Trace Validation**: The user circuit yields an initial state and uses a final state, with the bundle providing the intermediate execution steps.

## File Structure

- `Types.lean`: Core data structures including ExecutionTraceElement and conversion utilities
- `InstructionSteps.lean`: Individual circuits for each instruction type (ADD, MUL, STORE_STATE, LOAD_STATE)
- `ExecutionBundle.lean`: Bundle containing N copies of each instruction type
- `TraceExecution.lean`: Main circuit connecting initial state, bundle, and final state

## Implementation Plan

### Phase 1: Core Types and Infrastructure
- Define ExecutionTraceElement structure
- Create State ↔ NamedList conversion functions
- Set up basic project structure with necessary imports

### Phase 2: Instruction Step Circuits
Each instruction circuit follows this pattern:
```lean
def addStepCircuit (program memory : ...)
  (enabled : Var (Expression (F p)))
  (timestamp : Var (F p))
  (pre_state : Var (State (F p))) : Circuit (F p) Unit := do
  -- Fetch and verify instruction
  -- Perform memory accesses
  -- Compute new state
  -- Conditionally yield when enabled ≠ 0
```

### Phase 3: Bundle Architecture
```lean
def executionBundle (N : ℕ) (program memory : ...) : Circuit (F p) Unit := do
  -- N copies of ADD instruction
  for i in [0:N] do
    addStepCircuit program memory enabled_add[i] timestamp_add[i] state_add[i]

  -- N copies of MUL instruction
  for i in [0:N] do
    mulStepCircuit program memory enabled_mul[i] timestamp_mul[i] state_mul[i]

  -- N copies of LOAD_STATE instruction
  for i in [0:N] do
    loadStateStepCircuit program memory enabled_load[i] timestamp_load[i] state_load[i]

  -- N copies of STORE_STATE instruction
  for i in [0:N] do
    storeStateStepCircuit program memory enabled_store[i] timestamp_store[i] state_store[i]
```

### Phase 4: Main Execution Circuit
```lean
def executionCircuitMain : Circuit (F p) Unit := do
  -- Yield initial state
  yield ("execution", [0, initial_pc, initial_ap, initial_fp])

  -- Run bundle (proves intermediate steps)
  executionBundle N program memory

  -- Use final state
  use ("execution", [final_timestamp, final_pc, final_ap, final_fp])
```

### Phase 5: Correctness Proofs
- **Soundness**: If circuit is satisfiable, the yielded trace represents a valid Cairo execution
- **Instruction Correctness**: Each instruction circuit correctly implements Cairo semantics
- **Trace Validity**: The sequence of yielded states follows valid transitions

## Key Design Decisions

- **Read-only Memory**: Like FemtoCairo, memory is immutable
- **Sparse Traces**: No continuity requirement - allows gaps in timestamps
- **Modular Instructions**: Each instruction type has its own circuit for clarity
- **Conditional Execution**: Uses Clean's new conditional yield feature with `enabled` parameter
- **Fixed Bundle Size**: 4N total instruction slots (N of each type)

## Usage Example

```lean
-- Prove execution from initial to final state
def proveExecution (program memory : ...) : Circuit (F p) Unit := do
  -- Set up initial state
  let initial_state := State.mk 0 0 0  -- pc=0, ap=0, fp=0

  -- Yield starting point
  yield ("execution", [0, initial_state.pc, initial_state.ap, initial_state.fp])

  -- Bundle handles intermediate steps (N of each instruction type)
  executionBundle 250 program memory  -- Total of 1000 instruction slots

  -- Consume expected final state
  use ("execution", [n, final_pc, final_ap, final_fp])
```

## Future Extensions

- Support for additional Cairo instructions
- Optimized witness generation for long executions
- Memory consistency verification across the trace
- Integration with other proof systems
- Explore the possibility of dropping timestamps from the yielded tuples