/-
PicoCairo Execution Bundle
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Utils.Vector
import Clean.Examples.PicoCairo.Types
import Clean.Examples.PicoCairo.AddInstruction
import Clean.Examples.PicoCairo.MulInstruction
import Clean.Examples.PicoCairo.StoreStateInstruction
import Clean.Examples.PicoCairo.LoadStateInstruction
import Clean.Examples.FemtoCairo.Spec

namespace Examples.PicoCairo

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Instruction capacities for the execution bundle.
Groups all instruction type capacities with their NeZero constraints.
-/
structure InstructionCapacities where
  addCapacity : ℕ
  mulCapacity : ℕ
  storeStateCapacity : ℕ
  loadStateCapacity : ℕ
  addCapacity_nz : NeZero addCapacity
  mulCapacity_nz : NeZero mulCapacity
  storeStateCapacity_nz : NeZero storeStateCapacity
  loadStateCapacity_nz : NeZero loadStateCapacity

instance (capacities : InstructionCapacities) : NeZero capacities.addCapacity := capacities.addCapacity_nz
instance (capacities : InstructionCapacities) : NeZero capacities.mulCapacity := capacities.mulCapacity_nz
instance (capacities : InstructionCapacities) : NeZero capacities.storeStateCapacity := capacities.storeStateCapacity_nz
instance (capacities : InstructionCapacities) : NeZero capacities.loadStateCapacity := capacities.loadStateCapacity_nz

/--
Bundled instruction inputs for all instruction types.
Groups the input vectors for ADD, MUL, StoreState, and LoadState instructions.
-/
structure BundledInstructionInputs (capacities : InstructionCapacities) (F : Type) where
  addInputs : ProvableVector InstructionStepInput capacities.addCapacity F
  mulInputs : ProvableVector InstructionStepInput capacities.mulCapacity F
  storeStateInputs : ProvableVector InstructionStepInput capacities.storeStateCapacity F
  loadStateInputs : ProvableVector InstructionStepInput capacities.loadStateCapacity F

instance (capacities : InstructionCapacities) : ProvableStruct (BundledInstructionInputs capacities) where
  components := [
    ProvableVector InstructionStepInput capacities.addCapacity,
    ProvableVector InstructionStepInput capacities.mulCapacity,
    ProvableVector InstructionStepInput capacities.storeStateCapacity,
    ProvableVector InstructionStepInput capacities.loadStateCapacity
  ]
  toComponents := fun { addInputs, mulInputs, storeStateInputs, loadStateInputs } =>
    .cons addInputs (.cons mulInputs (.cons storeStateInputs (.cons loadStateInputs .nil)))
  fromComponents := fun (.cons addInputs (.cons mulInputs (.cons storeStateInputs (.cons loadStateInputs .nil)))) =>
    { addInputs, mulInputs, storeStateInputs, loadStateInputs }

instance (capacities : InstructionCapacities) : NonEmptyProvableType (BundledInstructionInputs capacities) where
  nonempty := by
    simp only [size, circuit_norm]
    simp only [List.sum_cons, List.sum_nil, add_zero, Nat.reduceAdd, gt_iff_lt, add_pos_iff,
      Nat.ofNat_pos, mul_pos_iff_of_pos_right]
    have : NeZero capacities.addCapacity := inferInstance
    rcases this
    omega

/--
Main execution bundle that combines all instruction type bundles.
Includes ADD, MUL, StoreState, and LoadState instructions.
-/
def executionBundleMain
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (inputs : Var (BundledInstructionInputs capacities) (F p)) :
    Circuit (F p) Unit := do

  -- Execute ADD instruction bundle
  AddInstruction.Bundle.circuit capacities.addCapacity program h_programSize memory h_memorySize inputs.addInputs

  -- Execute MUL instruction bundle
  MulInstruction.Bundle.circuit capacities.mulCapacity program h_programSize memory h_memorySize inputs.mulInputs

  -- Execute StoreState instruction bundle
  storeStateStepCircuitsBundleFormalCircuit capacities.storeStateCapacity program h_programSize memory h_memorySize inputs.storeStateInputs

  -- Execute LoadState instruction bundle
  loadStateStepCircuitsBundleFormalCircuit capacities.loadStateCapacity program h_programSize memory h_memorySize inputs.loadStateInputs

/--
Elaborated circuit for the execution bundle.
The localYields are the union of yields from all instruction bundles.
-/
def executionBundleElaborated
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) (BundledInstructionInputs capacities) unit where
  main := executionBundleMain capacities program h_programSize memory h_memorySize
  localLength _ :=
    capacities.addCapacity * 29 +
    capacities.mulCapacity * 29 +
    capacities.storeStateCapacity * 29 +
    capacities.loadStateCapacity * 29
  localLength_eq := by
    intros input offset
    simp only [circuit_norm, executionBundleMain]
    simp only [AddInstruction.Bundle.circuit, AddInstruction.Bundle.elaborated]
    simp only [MulInstruction.Bundle.circuit, MulInstruction.Bundle.elaborated]
    simp only [storeStateStepCircuitsBundleFormalCircuit, storeStateStepCircuitsBundleElaborated]
    simp only [loadStateStepCircuitsBundleFormalCircuit, loadStateStepCircuitsBundleElaborated]
    omega
  yields inputs env offset :=
    (AddInstruction.Bundle.elaborated capacities.addCapacity program h_programSize memory h_memorySize).yields
      inputs.addInputs env offset ∪
    (MulInstruction.Bundle.elaborated capacities.mulCapacity program h_programSize memory h_memorySize).yields
      inputs.mulInputs env (offset + capacities.addCapacity * 29) ∪
    (storeStateStepCircuitsBundleElaborated capacities.storeStateCapacity program h_programSize memory h_memorySize).yields
      inputs.storeStateInputs env (offset + capacities.addCapacity * 29 + capacities.mulCapacity * 29) ∪
    (loadStateStepCircuitsBundleElaborated capacities.loadStateCapacity program h_programSize memory h_memorySize).yields
      inputs.loadStateInputs env (offset + capacities.addCapacity * 29 + capacities.mulCapacity * 29 + capacities.storeStateCapacity * 29)
  yields_eq := by
    intros inputs env offset
    simp only [circuit_norm, executionBundleMain]
    aesop
  subcircuitsConsistent := by
    intros inputs offset
    simp only [circuit_norm, executionBundleMain]
    omega

/--
Assumptions for the execution bundle: each instruction bundle must satisfy its assumptions.
-/
def executionBundleAssumptions
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize]
    (inputs : BundledInstructionInputs capacities (F p)) (_yielded : Set (NamedList (F p))) : Prop :=
  AddInstruction.Bundle.assumptions capacities.addCapacity (programSize := programSize) inputs.addInputs _yielded ∧
  MulInstruction.Bundle.assumptions capacities.mulCapacity (programSize := programSize) inputs.mulInputs _yielded ∧
  storeStateStepCircuitsBundleAssumptions capacities.storeStateCapacity (programSize := programSize) inputs.storeStateInputs _yielded ∧
  loadStateStepCircuitsBundleAssumptions capacities.loadStateCapacity (programSize := programSize) inputs.loadStateInputs _yielded

/--
Spec for the execution bundle: each instruction bundle must satisfy its spec,
and the local yields are the union of all bundle yields.
-/
def executionBundleSpec
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (inputs : BundledInstructionInputs capacities (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  ∃ (addLocalYields mulLocalYields storeStateLocalYields loadStateLocalYields : Set (NamedList (F p))),
    AddInstruction.Bundle.spec capacities.addCapacity program memory inputs.addInputs yielded () addLocalYields ∧
    MulInstruction.Bundle.spec capacities.mulCapacity program memory inputs.mulInputs yielded () mulLocalYields ∧
    storeStateStepCircuitsBundleSpec capacities.storeStateCapacity program memory inputs.storeStateInputs yielded () storeStateLocalYields ∧
    loadStateStepCircuitsBundleSpec capacities.loadStateCapacity program memory inputs.loadStateInputs yielded () loadStateLocalYields ∧
    localYields = addLocalYields ∪ mulLocalYields ∪ storeStateLocalYields ∪ loadStateLocalYields

/--
Formal circuit for the execution bundle.
-/
def executionBundleFormalCircuit
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuitUsingYields (F p) (BundledInstructionInputs capacities) unit where
  elaborated := executionBundleElaborated capacities program h_programSize memory h_memorySize
  Assumptions := executionBundleAssumptions capacities (programSize := programSize)
  Spec := executionBundleSpec capacities program memory
  soundness := by
    circuit_proof_start [executionBundleSpec, executionBundleElaborated, executionBundleMain]
    simp only [AddInstruction.Bundle.circuit, AddInstruction.Bundle.elaborated] at h_holds
    simp only [MulInstruction.Bundle.circuit, MulInstruction.Bundle.elaborated] at h_holds
    simp only [storeStateStepCircuitsBundleFormalCircuit, storeStateStepCircuitsBundleElaborated] at h_holds
    simp only [loadStateStepCircuitsBundleFormalCircuit, loadStateStepCircuitsBundleElaborated] at h_holds
    use ⋃ (i : Fin capacities.addCapacity), AddInstruction.localYields (eval env input_var.addInputs[i])
    use ⋃ (i : Fin capacities.mulCapacity), MulInstruction.localYields (eval env input_var.mulInputs[i])
    use ⋃ (i : Fin capacities.storeStateCapacity), storeStateStepLocalYields (eval env input_var.storeStateInputs[i])
    use ⋃ (i : Fin capacities.loadStateCapacity), loadStateStepLocalYields (eval env input_var.loadStateInputs[i]) env (i₀ + capacities.addCapacity * 29 + capacities.mulCapacity * 29 + capacities.storeStateCapacity * 29 + i * 29)
    aesop
  completeness := sorry

/--
Predicate stating that a named list represents a valid instruction execution
from any of the four instruction types (ADD, MUL, StoreState, or LoadState).
-/
def IsValidInstructionExecution
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (preState : FemtoCairo.Types.State (F p))
    (timestamp : F p)
    (nl : NamedList (F p)) : Prop :=
  AddInstruction.Bundle.IsValidAddExecution program memory preState timestamp nl ∨
  MulInstruction.Bundle.IsValidMulExecution program memory preState timestamp nl ∨
  IsValidStoreStateExecution program memory preState timestamp nl ∨
  IsValidLoadStateExecution program memory preState timestamp nl

/--
Characterization theorem for execution bundle localYields.
Given a bundle spec and a named list in the local yields, we can find which instruction it came from
and extract witnesses showing it's a valid instruction execution.
-/
theorem executionBundleSpec_localYields_characterization
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (inputs : BundledInstructionInputs capacities (F p)) (yielded : Set (NamedList (F p)))
    (localYields : Set (NamedList (F p)))
    (nl : NamedList (F p))
    (h_spec : executionBundleSpec capacities program memory inputs yielded () localYields)
    (h_mem : nl ∈ localYields) :
    -- We can find which instruction type and which index within that type
    ∃ (preState : FemtoCairo.Types.State (F p)) (timestamp : F p),
      -- One of the instruction inputs has this preState and timestamp
      ((∃ (i : Fin capacities.addCapacity), inputs.addInputs[i].preState = preState ∧ inputs.addInputs[i].timestamp = timestamp ∧ inputs.addInputs[i].enabled = 1) ∨
       (∃ (i : Fin capacities.mulCapacity), inputs.mulInputs[i].preState = preState ∧ inputs.mulInputs[i].timestamp = timestamp ∧ inputs.mulInputs[i].enabled = 1) ∨
       (∃ (i : Fin capacities.storeStateCapacity), inputs.storeStateInputs[i].preState = preState ∧ inputs.storeStateInputs[i].timestamp = timestamp ∧ inputs.storeStateInputs[i].enabled = 1) ∨
       (∃ (i : Fin capacities.loadStateCapacity), inputs.loadStateInputs[i].preState = preState ∧ inputs.loadStateInputs[i].timestamp = timestamp ∧ inputs.loadStateInputs[i].enabled = 1)) ∧
      -- The timestamp doesn't overflow
      timestamp + 1 ≠ 0 ∧
      -- The previous state was yielded
      ⟨"execution", [timestamp, preState.pc, preState.ap, preState.fp]⟩ ∈ yielded ∧
      -- And this is a valid execution from one of the four instruction types
      IsValidInstructionExecution program memory preState timestamp nl := by
  simp only [executionBundleSpec] at h_spec
  rcases h_spec with ⟨addLocalYields, mulLocalYields, storeStateLocalYields, loadStateLocalYields, h_add, h_mul, h_store, h_load, h_union⟩
  rw [h_union] at h_mem
  simp only [Set.mem_union] at h_mem
  rcases h_mem with ((h_mem | h_mem) | h_mem) | h_mem
  -- Case 1: ADD instruction
  · have ⟨i, h_enabled, h_overflow, h_yielded, h_valid⟩ := AddInstruction.Bundle.spec_localYields_characterization_bundle capacities.addCapacity program memory inputs.addInputs yielded addLocalYields nl h_add h_mem
    use inputs.addInputs[i].preState, inputs.addInputs[i].timestamp
    constructor
    · left
      use i
    constructor
    · exact h_overflow
    constructor
    · exact h_yielded
    · simp only [IsValidInstructionExecution]
      left
      exact h_valid
  -- Case 2: MUL instruction
  · have ⟨i, h_enabled, h_overflow, h_yielded, h_valid⟩ := MulInstruction.Bundle.spec_localYields_characterization_bundle capacities.mulCapacity program memory inputs.mulInputs yielded mulLocalYields nl h_mul h_mem
    use inputs.mulInputs[i].preState, inputs.mulInputs[i].timestamp
    constructor
    · right; left
      use i
    constructor
    · exact h_overflow
    constructor
    · exact h_yielded
    · simp only [IsValidInstructionExecution]
      right; left
      exact h_valid
  -- Case 3: StoreState instruction
  · have ⟨i, h_enabled, h_overflow, h_yielded, h_valid⟩ := storeStateStepCircuitsBundleSpec_localYields_characterization capacities.storeStateCapacity program memory inputs.storeStateInputs yielded storeStateLocalYields nl h_store h_mem
    use inputs.storeStateInputs[i].preState, inputs.storeStateInputs[i].timestamp
    constructor
    · right; right; left
      use i
    constructor
    · exact h_overflow
    constructor
    · exact h_yielded
    · simp only [IsValidInstructionExecution]
      right; right; left
      exact h_valid
  -- Case 4: LoadState instruction
  · have ⟨i, h_enabled, h_overflow, h_yielded, h_valid⟩ := loadStateStepCircuitsBundleSpec_localYields_characterization capacities.loadStateCapacity program memory inputs.loadStateInputs yielded loadStateLocalYields nl h_load h_mem
    use inputs.loadStateInputs[i].preState, inputs.loadStateInputs[i].timestamp
    constructor
    · right; right; right
      use i
    constructor
    · exact h_overflow
    constructor
    · exact h_yielded
    · simp only [IsValidInstructionExecution]
      right; right; right
      exact h_valid

omit p_large_enough in
/--
Theorem stating that IsValidInstructionExecution implies a valid femtoCairoMachineTransition.
This connects the circuit specification to the machine semantics.
-/
theorem IsValidInstructionExecution_implies_valid_transition
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (preState : FemtoCairo.Types.State (F p))
    (timestamp : F p)
    (nl : NamedList (F p))
    (h_valid : IsValidInstructionExecution program memory preState timestamp nl) :
    ∃ newState : FemtoCairo.Types.State (F p),
      FemtoCairo.Spec.femtoCairoMachineTransition program memory preState = some newState ∧
      nl = ⟨"execution", [timestamp + 1, newState.pc, newState.ap, newState.fp]⟩ := by
  simp only [IsValidInstructionExecution] at h_valid
  rcases h_valid with h_valid | h_valid | h_valid | h_valid
  -- Case 1: ADD instruction
  · exact AddInstruction.Bundle.IsValidAddExecution_implies_valid_transition program memory preState timestamp nl h_valid
  -- Case 2: MUL instruction
  · exact MulInstruction.Bundle.IsValidMulExecution_implies_valid_transition program memory preState timestamp nl h_valid
  -- Case 3: StoreState instruction
  · exact IsValidStoreStateExecution_implies_valid_transition program memory preState timestamp nl h_valid
  -- Case 4: LoadState instruction
  · exact IsValidLoadStateExecution_implies_valid_transition program memory preState timestamp nl h_valid

/--
Combined theorem: from execution bundle spec to valid machine transition.
This directly shows that any named list in the execution bundle's local yields
corresponds to a valid machine state transition.
-/
theorem executionBundleSpec_implies_valid_transition
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (inputs : BundledInstructionInputs capacities (F p)) (yielded : Set (NamedList (F p)))
    (localYields : Set (NamedList (F p)))
    (nl : NamedList (F p))
    (h_spec : executionBundleSpec capacities program memory inputs yielded () localYields)
    (h_mem : nl ∈ localYields) :
    ∃ (preState newState : FemtoCairo.Types.State (F p)) (timestamp : F p),
      -- One of the instruction inputs has this preState and timestamp
      ((∃ (i : Fin capacities.addCapacity), inputs.addInputs[i].preState = preState ∧ inputs.addInputs[i].timestamp = timestamp ∧ inputs.addInputs[i].enabled = 1) ∨
       (∃ (i : Fin capacities.mulCapacity), inputs.mulInputs[i].preState = preState ∧ inputs.mulInputs[i].timestamp = timestamp ∧ inputs.mulInputs[i].enabled = 1) ∨
       (∃ (i : Fin capacities.storeStateCapacity), inputs.storeStateInputs[i].preState = preState ∧ inputs.storeStateInputs[i].timestamp = timestamp ∧ inputs.storeStateInputs[i].enabled = 1) ∨
       (∃ (i : Fin capacities.loadStateCapacity), inputs.loadStateInputs[i].preState = preState ∧ inputs.loadStateInputs[i].timestamp = timestamp ∧ inputs.loadStateInputs[i].enabled = 1)) ∧
      -- The timestamp doesn't overflow
      timestamp + 1 ≠ 0 ∧
      -- The previous state was yielded
      ⟨"execution", [timestamp, preState.pc, preState.ap, preState.fp]⟩ ∈ yielded ∧
      -- The transition is valid
      FemtoCairo.Spec.femtoCairoMachineTransition program memory preState = some newState ∧
      -- And the named list represents the new state
      nl = ⟨"execution", [timestamp + 1, newState.pc, newState.ap, newState.fp]⟩ := by
  have ⟨preState, timestamp, h_input, h_overflow, h_yielded, h_valid⟩ :=
    executionBundleSpec_localYields_characterization capacities program memory inputs yielded localYields nl h_spec h_mem
  have ⟨newState, h_transition, h_nl⟩ :=
    IsValidInstructionExecution_implies_valid_transition program memory preState timestamp nl h_valid
  exact ⟨preState, newState, timestamp, h_input, h_overflow, h_yielded, h_transition, h_nl⟩

end Examples.PicoCairo
