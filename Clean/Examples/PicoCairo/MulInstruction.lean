/-
PicoCairo MUL Instruction Circuit
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Circuit.Subcircuit
import Clean.Examples.PicoCairo.Types
import Clean.Examples.PicoCairo.Helpers
import Clean.Examples.FemtoCairo.FemtoCairo
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.Spec
import Clean.Gadgets.Conditional
import Clean.Gadgets.IsZeroField
import Clean.Gadgets.Boolean

namespace Examples.PicoCairo

open Examples.FemtoCairo
open Examples.FemtoCairo.Types
open Examples.FemtoCairo.Spec

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Main circuit for MUL instruction step.
Takes enabled flag, timestamp, and pre-state.
If enabled and instruction at pc is MUL, computes new state and yields trace element.
-/
def mulStepCircuitMain
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : Var InstructionStepInput (F p)) : Circuit (F p) Unit := do

  let enabled := input.enabled
  let timestamp := input.timestamp
  let preState := input.preState

  -- Step 1: Assert enabled is boolean (0 or 1)
  assertBool enabled

  -- Step 1b: Conditionally use the preState from yielded execution trace
  useWhen enabled ⟨"execution", [timestamp, preState.pc, preState.ap, preState.fp]⟩

  -- Step 2: Check that timestamp + 1 is not zero (prevent overflow)
  -- IsZeroField returns 1 if input is 0, 0 otherwise
  -- We want to assert that the result is 0 (meaning timestamp + 1 ≠ 0)
  let timestampPlusOneIsZero ← subcircuit Gadgets.IsZeroField.circuit (timestamp + 1)
  assertZero timestampPlusOneIsZero

  -- Step 3: Fetch instruction from program memory using FemtoCairo's circuit
  let rawInstruction ← subcircuitWithAssertion (fetchInstructionCircuit program h_programSize) preState.pc

  -- Step 4: Conditionally decode the instruction (returns dummy MUL when disabled)
  let decoded ← subcircuitWithAssertion conditionalDecodeCircuit {
    enabled := enabled,
    rawInstrType := rawInstruction.rawInstrType,
    dummy := dummyMULInstruction
  }

  -- Step 5: Unconditionally assert it's a MUL instruction
  -- When enabled=1, this checks the actual instruction is MUL
  -- When enabled=0, this always passes since dummy is MUL
  assertZero (decoded.instrType.isMul - 1)

  -- Step 6: Read operands from memory using addressing modes
  let v1 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op1,
    mode := decoded.mode1
  }

  let v2 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op2,
    mode := decoded.mode2
  }

  let v3 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op3,
    mode := decoded.mode3
  }

  -- Step 7: Conditional MUL constraint: v3 = v1 * v2 (only when enabled)
  assertZero (enabled * (v3 - (v1 * v2)))

  -- Step 8: Yield the new execution state
  yieldWhen enabled ⟨"execution", [timestamp + 1, preState.pc + 4, preState.ap, preState.fp]⟩

/--
Elaborated circuit for MUL instruction step.
-/
def mulStepElaboratedCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) InstructionStepInput unit where
  main := mulStepCircuitMain program h_programSize memory h_memorySize
  localLength _ := 29  -- boolean(0) + IsZero(2) + fetch(4) + conditionalDecode(8) + 3×readMemory(5)
  yields input env _ := {
    nl | env input.enabled ≠ 0 ∧
         nl = ⟨"execution", [env (input.timestamp + 1),
                             env (input.preState.pc + 4),
                             env input.preState.ap,
                             env input.preState.fp]⟩
  }
  yields_eq := by
    intro input env offset
    simp only [mulStepCircuitMain, circuit_norm, Gadgets.IsZeroField.circuit, fetchInstructionCircuit, conditionalDecodeCircuit, conditionalDecodeElaborated,
      readFromMemoryCircuit, NamedList.eval]
    aesop

/--
Assumptions for MUL instruction step (for completeness).
Ensures the instruction can be decoded, new timestamp won't overflow, and PC is in bounds.
-/
def mulStepAssumptions
    {programSize : ℕ} [NeZero programSize]
    (input : InstructionStepInput (F p)) (_yielded : Set (NamedList (F p))) : Prop :=
  IsBool input.enabled ∧
  -- New timestamp should not be zero (prevent overflow)
  input.timestamp + 1 ≠ 0 ∧
  ZMod.val (input.preState.pc) + 3 < programSize

/--
Specification for MUL instruction step (for soundness).
The circuit already ensures fetch/decode succeed and instruction is MUL.
This spec verifies the MUL constraint and correct state transition.
-/
def mulStepSpec
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  -- If enabled (circuit enforces binary), circuit ensures it's MUL, so we just specify the yields
  if input.enabled = 1 then
    -- Timestamp must not overflow
    input.timestamp + 1 ≠ 0 ∧
    -- The preState must be in the yielded set
    ⟨"execution", [input.timestamp, input.preState.pc, input.preState.ap, input.preState.fp]⟩ ∈ yielded ∧
    -- We need to verify the MUL operation and state transition
    match Spec.fetchInstruction program input.preState.pc with
    | some rawInstr =>
      match Spec.decodeInstruction rawInstr.rawInstrType with
      | some (instrType, mode1, mode2, mode3) =>
        if instrType = 1 then  -- Must be MUL
          -- Read operands
          match Spec.dataMemoryAccess memory rawInstr.op1 mode1 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op2 mode2 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op3 mode3 input.preState.ap input.preState.fp with
          | some v1, some v2, some v3 =>
            -- MUL constraint must hold and we yield new state
            v1 * v2 = v3 ∧
            localYields = {⟨"execution", [input.timestamp + 1,
                                         input.preState.pc + 4,
                                         input.preState.ap,
                                         input.preState.fp]⟩}
          | _, _, _ => False
        else False
      | none => False
    | none => False
  else
    -- When disabled, no yields
    localYields = ∅

/--
GeneralFormalCircuit for MUL instruction step.
-/
def mulStepFormalCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) InstructionStepInput unit where
  elaborated := mulStepElaboratedCircuit program h_programSize memory h_memorySize
  Assumptions := mulStepAssumptions (programSize := programSize)
  Spec := mulStepSpec program memory
  soundness := by
    circuit_proof_start [mulStepSpec, mulStepElaboratedCircuit, mulStepCircuitMain,
      assertBool, Gadgets.IsZeroField.circuit, Gadgets.IsZeroField.Assumptions, Gadgets.IsZeroField.Spec,
      fetchInstructionCircuit, conditionalDecodeCircuit, readFromMemoryCircuit]
    rcases h_holds with ⟨ h_bool, h_holds ⟩
    rcases h_bool with h_zero | h_one
    · simp only [h_zero, zero_ne_one, ↓reduceIte, ne_eq, not_true_eq_false, false_and, Set.setOf_false]
    · subst h_one
      simp only [↓reduceIte, ne_eq, one_ne_zero, not_false_eq_true, true_and,
        Set.setOf_eq_eq_singleton, Set.singleton_eq_singleton_iff, NamedList.mk.injEq,
        List.cons.injEq, add_left_inj, and_true]
      rcases h_holds with ⟨ h_use, h_iszero, h_nonzero, h_fetch, h_decode, h_ismul, h_read1, h_read2, h_read3, h_mul ⟩
      simp only [ne_eq, one_ne_zero, not_false_eq_true, forall_const] at h_use
      constructor
      · aesop
      constructor
      · aesop
      -- manual decomposition because State is not ProvableStruct
      rcases input_var_preState with ⟨ input_var_pc, input_var_ap, input_var_fp ⟩
      rcases input_preState with ⟨ input_pc, input_ap, input_fp ⟩
      simp only [circuit_norm, explicit_provable_type, State.mk.injEq] at h_input
      simp only [h_input] at h_fetch
      simp only
      cases h : fetchInstruction program input_pc
      · simp only [h] at h_fetch
      -- not indenting for heavy interesting case
      simp only [h] at h_fetch
      subst h_fetch
      simp only
      specialize h_decode (by simp only [circuit_norm])
      simp only [one_ne_zero, ↓reduceIte, decodeInstructionSpec] at h_decode
      simp only [circuit_norm, explicit_provable_type]
      cases h2 : decodeInstruction (env.get (i₀ + 2))
      · simp only [h2] at h_decode
      -- not indenting for heavy interesting case
      simp only [h2] at h_decode
      rename_i decoded
      rcases decoded with ⟨ type, mode1', mode2', mode3' ⟩
      simp only at h_decode ⊢
      simp only [circuit_norm, explicit_provable_type] at h_decode h_ismul
      rcases h_decode with ⟨ h_decode_type, h_decode ⟩
      -- there should be a tactic for naming outputs of elaborated circuits
      cases decoded : @ElaboratedCircuit.output (F p) ConditionalDecodeInput DecodedInstruction (instFieldFOfFactPrime p)
        ProvableType.fromStruct ProvableType.fromStruct conditionalDecodeElaborated
        { enabled := input_var_enabled, rawInstrType := var { index := i₀ + 2 }, dummy := dummyMULInstruction } (i₀ + 2 + 4)
      rename_i decoded_instr_type decoded_mode1 decoded_mode2 decoded_mode3
      simp only [decoded] at h_decode_type h_ismul h_read1 h_read2 h_read3 h_decode
      cases decoded_instr_type
      simp only at h_decode_type h_ismul
      simp only [DecodedInstructionType.val] at h_decode_type
      rw [if_neg] at h_decode_type
      swap
      · simp only at h_decode
        rcases h_decode with ⟨ h_encoded_correctly, h_decode ⟩
        rcases h_encoded_correctly with h_encoded_add | h_encoded_mul | h_encoded_store | h_encoded_load
        · subst h_decode_type
          simp_all only [id_eq, right_eq_ite_iff, zero_ne_one, imp_false, one_mul, ↓reduceIte, not_true_eq_false,
            zero_add, neg_eq_zero, one_ne_zero]
        · subst h_decode_type
          simp_all only [id_eq, right_eq_ite_iff, zero_ne_one, imp_false, one_mul, ↓reduceIte, not_false_eq_true]
        · subst h_decode_type
          simp_all only [id_eq, right_eq_ite_iff, zero_ne_one, imp_false, one_mul, ↓reduceIte, not_false_eq_true]
        · subst h_decode_type
          simp_all only [id_eq, right_eq_ite_iff, zero_ne_one, imp_false, one_mul, ↓reduceIte, not_false_eq_true]
      rw [if_pos] at h_decode_type
      swap
      · grind
      subst h_decode_type
      simp only [↓reduceIte]
      specialize h_read1 (by aesop)
      specialize h_read2 (by aesop)
      specialize h_read3 (by aesop)
      rcases h_decode with ⟨ h_correct, h_mode1', h_correct1, h_mode2', h_correct2, h_mode3', h_correct3 ⟩
      cases h_access1 : dataMemoryAccess memory (env.get (i₀ + 2 + 1)) mode1' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read1
        subst h_mode1'
        simp_all
      rename_i v1
      cases h_access2 : dataMemoryAccess memory (env.get (i₀ + 2 + 1 + 1)) mode2' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read2
        subst h_mode2'
        simp_all
      rename_i v2
      cases h_access3 : dataMemoryAccess memory (env.get (i₀ + 2 + 1 + 1 + 1)) mode3' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read3
        subst h_mode3'
        simp_all
      rename_i v3
      simp only
      and_intros
      · simp only [circuit_norm, explicit_provable_type] at h_read1
        subst h_mode1'
        simp only [h_access1] at h_read1
        subst h_read1
        simp only [circuit_norm, explicit_provable_type] at h_read2
        subst h_mode2'
        simp only [h_access2] at h_read2
        subst h_read2
        simp only [circuit_norm, explicit_provable_type] at h_read3
        subst h_mode3'
        simp only [h_access3] at h_read3
        subst h_read3
        grind
      · simp_all
      · simp_all
      · simp_all

  -- Postponed: assumptions are missing about well-formedness of the program, etc.
  -- Yield/use is more interesting in soundness.
  completeness := by sorry

/--
Bundle of MUL instruction step circuits.
Takes a vector of inputs with given capacity and executes MUL instructions for each enabled input.
-/
def mulStepCircuitsBundle
    (capacity : ℕ)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (inputs : Vector (Var InstructionStepInput (F p)) capacity) : Circuit (F p) Unit := do
  -- Process each input using the formal circuit
  for h : i in [0:capacity] do
    subcircuitWithAssertion (mulStepFormalCircuit program h_programSize memory h_memorySize) inputs[i]

end Examples.PicoCairo
