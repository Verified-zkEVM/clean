/-
PicoCairo MUL Instruction Circuit
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Circuit.Subcircuit
import Clean.Circuit.Loops
import Clean.Examples.PicoCairo.Types
import Clean.Examples.PicoCairo.Helpers
import Clean.Examples.FemtoCairo.FemtoCairo
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.Spec
import Clean.Gadgets.Conditional
import Clean.Gadgets.IsZeroField
import Clean.Gadgets.Boolean
import Batteries.Data.Vector.Lemmas

namespace Examples.PicoCairo

open Examples.FemtoCairo
open Examples.FemtoCairo.Types
open Examples.FemtoCairo.Spec

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Main circuit for MUL instruction step.
Takes enabled flag, timestamp, and pre-state.
If enabled and instruction at pc is MUL, computes new state and yields trace element.
-/
def mulStepCircuitMain
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : Var InstructionStepInput (F p)) : Circuit (F p) Unit := do

  let enabled := input.enabled
  let timestamp := input.timestamp
  let preState := input.preState

  -- Step 1: Assert enabled is boolean (0 or 1)
  assertBool enabled

  -- Step 1b: Conditionally use the preState from yielded execution trace
  useWhen enabled ⟨"execution", [timestamp, preState.pc, preState.ap, preState.fp]⟩

  -- Step 2: Check that timestamp + 1 is not zero (prevent overflow)
  -- IsZeroField returns 1 if input is 0, 0 otherwise
  -- We want to assert that the result is 0 (meaning timestamp + 1 ≠ 0)
  let timestampPlusOneIsZero ← subcircuit Gadgets.IsZeroField.circuit (timestamp + 1)
  assertZero timestampPlusOneIsZero

  -- Step 3: Fetch instruction from program memory using FemtoCairo's circuit
  let rawInstruction ← subcircuitWithAssertion (fetchInstructionCircuit program h_programSize) preState.pc

  -- Step 4: Conditionally decode the instruction (returns dummy MUL when disabled)
  let decoded ← subcircuitWithAssertion conditionalDecodeCircuit {
    enabled := enabled,
    rawInstrType := rawInstruction.rawInstrType,
    dummy := dummyMULInstruction
  }

  -- Step 5: Unconditionally assert it's a MUL instruction
  -- When enabled=1, this checks the actual instruction is MUL
  -- When enabled=0, this always passes since dummy is MUL
  assertZero (decoded.instrType.isMul - 1)

  -- Step 6: Read operands from memory using addressing modes
  let v1 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op1,
    mode := decoded.mode1
  }

  let v2 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op2,
    mode := decoded.mode2
  }

  let v3 ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstruction.op3,
    mode := decoded.mode3
  }

  -- Step 7: Conditional MUL constraint: v3 = v1 * v2 (only when enabled)
  assertZero (enabled * (v3 - (v1 * v2)))

  -- Step 8: Yield the new execution state
  yieldWhen enabled ⟨"execution", [timestamp + 1, preState.pc + 4, preState.ap, preState.fp]⟩

/--
Computes the localYields for a single MUL instruction step.
If enabled, yields the new execution state; otherwise yields nothing.
-/
def mulStepLocalYields (input : InstructionStepInput (F p)) : Set (NamedList (F p)) :=
  { nl | input.enabled ≠ 0 ∧
         nl = ⟨"execution", [input.timestamp + 1,
                            input.preState.pc + 4,
                            input.preState.ap,
                            input.preState.fp]⟩ }

/--
Elaborated circuit for MUL instruction step.
-/
def mulStepElaboratedCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) InstructionStepInput unit where
  main := mulStepCircuitMain program h_programSize memory h_memorySize
  localLength _ := 29  -- boolean(0) + IsZero(2) + fetch(4) + conditionalDecode(8) + 3×readMemory(5)
  yields input env _ := mulStepLocalYields (eval env input)
  yields_eq := by
    intro input env offset
    simp only [mulStepLocalYields, mulStepCircuitMain, circuit_norm, Gadgets.IsZeroField.circuit, fetchInstructionCircuit, conditionalDecodeCircuit, conditionalDecodeElaborated,
      readFromMemoryCircuit, NamedList.eval]
    aesop

/--
Assumptions for MUL instruction step (for completeness).
Ensures the instruction can be decoded, new timestamp won't overflow, and PC is in bounds.
-/
def mulStepAssumptions
    {programSize : ℕ} [NeZero programSize]
    (input : InstructionStepInput (F p)) (_yielded : Set (NamedList (F p))) : Prop :=
  IsBool input.enabled ∧
  -- New timestamp should not be zero (prevent overflow)
  input.timestamp + 1 ≠ 0 ∧
  ZMod.val (input.preState.pc) + 3 < programSize

/--
Specification for MUL instruction step (for soundness).
The circuit already ensures fetch/decode succeed and instruction is MUL.
This spec verifies the MUL constraint and correct state transition.
-/
def mulStepSpec
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  -- If enabled (circuit enforces binary), circuit ensures it's MUL, so we just specify the yields
  if input.enabled = 1 then
    -- Timestamp must not overflow
    input.timestamp + 1 ≠ 0 ∧
    -- The preState must be in the yielded set
    ⟨"execution", [input.timestamp, input.preState.pc, input.preState.ap, input.preState.fp]⟩ ∈ yielded ∧
    -- We need to verify the MUL operation and state transition
    match Spec.fetchInstruction program input.preState.pc with
    | some rawInstr =>
      match Spec.decodeInstruction rawInstr.rawInstrType with
      | some (instrType, mode1, mode2, mode3) =>
        if instrType = 1 then  -- Must be MUL
          -- Read operands
          match Spec.dataMemoryAccess memory rawInstr.op1 mode1 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op2 mode2 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op3 mode3 input.preState.ap input.preState.fp with
          | some v1, some v2, some v3 =>
            -- MUL constraint must hold and we yield new state
            v1 * v2 = v3 ∧
            localYields = {⟨"execution", [input.timestamp + 1,
                                         input.preState.pc + 4,
                                         input.preState.ap,
                                         input.preState.fp]⟩}
          | _, _, _ => False
        else False
      | none => False
    | none => False
  else
    -- When disabled, no yields
    localYields = ∅

/--
GeneralFormalCircuit for MUL instruction step.
-/
def mulStepFormalCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) InstructionStepInput unit where
  elaborated := mulStepElaboratedCircuit program h_programSize memory h_memorySize
  Assumptions := mulStepAssumptions (programSize := programSize)
  Spec := mulStepSpec program memory
  soundness := by
    circuit_proof_start [mulStepSpec, mulStepElaboratedCircuit, mulStepCircuitMain,
      assertBool, Gadgets.IsZeroField.circuit, Gadgets.IsZeroField.Assumptions, Gadgets.IsZeroField.Spec,
      fetchInstructionCircuit, conditionalDecodeCircuit, readFromMemoryCircuit]
    rcases h_holds with ⟨ h_bool, h_holds ⟩
    rcases h_bool with h_zero | h_one
    · simp only [h_zero, mulStepLocalYields]
      aesop
    · subst h_one
      simp only [↓reduceIte, mulStepLocalYields]
      rcases h_holds with ⟨ h_use, h_iszero, h_nonzero, h_fetch, h_decode, h_ismul, h_read1, h_read2, h_read3, h_mul ⟩
      simp only [ne_eq, one_ne_zero, not_false_eq_true, forall_const] at h_use
      constructor
      · aesop
      constructor
      · aesop
      -- manual decomposition because State is not ProvableStruct
      rcases input_var_preState with ⟨ input_var_pc, input_var_ap, input_var_fp ⟩
      rcases input_preState with ⟨ input_pc, input_ap, input_fp ⟩
      simp only [circuit_norm, explicit_provable_type, State.mk.injEq] at h_input
      simp only [h_input] at h_fetch
      simp only
      cases h : fetchInstruction program input_pc
      · simp only [h] at h_fetch
      -- not indenting for heavy interesting case
      simp only [h] at h_fetch
      subst h_fetch
      simp only
      specialize h_decode (by simp only [circuit_norm])
      simp only [one_ne_zero, ↓reduceIte, decodeInstructionSpec] at h_decode
      simp only [circuit_norm, explicit_provable_type]
      cases h2 : decodeInstruction (env.get (i₀ + 2))
      · simp only [h2] at h_decode
      -- not indenting for heavy interesting case
      simp only [h2] at h_decode
      rename_i decoded
      rcases decoded with ⟨ type, mode1', mode2', mode3' ⟩
      simp only at h_decode ⊢
      simp only [circuit_norm, explicit_provable_type] at h_decode h_ismul
      rcases h_decode with ⟨ h_decode_type, h_decode ⟩
      -- there should be a tactic for naming outputs of elaborated circuits
      cases decoded : @ElaboratedCircuit.output (F p) ConditionalDecodeInput DecodedInstruction (instFieldFOfFactPrime p)
        ProvableType.fromStruct ProvableType.fromStruct conditionalDecodeElaborated
        { enabled := input_var_enabled, rawInstrType := var { index := i₀ + 2 }, dummy := dummyMULInstruction } (i₀ + 2 + 4)
      rename_i decoded_instr_type decoded_mode1 decoded_mode2 decoded_mode3
      simp only [decoded] at h_decode_type h_ismul h_read1 h_read2 h_read3 h_decode
      cases decoded_instr_type
      simp only at h_decode_type h_ismul
      simp only [DecodedInstructionType.val] at h_decode_type
      rw [if_neg] at h_decode_type
      swap
      · simp only at h_decode
        rcases h_decode with ⟨ h_encoded_correctly, h_decode ⟩
        rcases h_encoded_correctly with h_encoded_add | h_encoded_mul | h_encoded_store | h_encoded_load
        · subst h_decode_type
          simp_all only [id_eq, right_eq_ite_iff, zero_ne_one, imp_false, one_mul, ↓reduceIte, not_true_eq_false,
            zero_add, neg_eq_zero, one_ne_zero]
        · subst h_decode_type
          simp_all only [id_eq, right_eq_ite_iff, zero_ne_one, imp_false, one_mul, ↓reduceIte, not_false_eq_true]
        · subst h_decode_type
          simp_all only [id_eq, right_eq_ite_iff, zero_ne_one, imp_false, one_mul, ↓reduceIte, not_false_eq_true]
        · subst h_decode_type
          simp_all only [id_eq, right_eq_ite_iff, zero_ne_one, imp_false, one_mul, ↓reduceIte, not_false_eq_true]
      rw [if_pos] at h_decode_type
      swap
      · grind
      subst h_decode_type
      simp only [↓reduceIte]
      specialize h_read1 (by aesop)
      specialize h_read2 (by aesop)
      specialize h_read3 (by aesop)
      rcases h_decode with ⟨ h_correct, h_mode1', h_correct1, h_mode2', h_correct2, h_mode3', h_correct3 ⟩
      cases h_access1 : dataMemoryAccess memory (env.get (i₀ + 2 + 1)) mode1' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read1
        subst h_mode1'
        simp_all
      rename_i v1
      cases h_access2 : dataMemoryAccess memory (env.get (i₀ + 2 + 1 + 1)) mode2' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read2
        subst h_mode2'
        simp_all
      rename_i v2
      cases h_access3 : dataMemoryAccess memory (env.get (i₀ + 2 + 1 + 1 + 1)) mode3' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read3
        subst h_mode3'
        simp_all
      rename_i v3
      simp only
      and_intros
      · simp only [circuit_norm, explicit_provable_type] at h_read1
        subst h_mode1'
        simp only [h_access1] at h_read1
        subst h_read1
        simp only [circuit_norm, explicit_provable_type] at h_read2
        subst h_mode2'
        simp only [h_access2] at h_read2
        subst h_read2
        simp only [circuit_norm, explicit_provable_type] at h_read3
        subst h_mode3'
        simp only [h_access3] at h_read3
        subst h_read3
        grind
      · simp_all

  -- Postponed: assumptions are missing about well-formedness of the program, etc.
  -- Yield/use is more interesting in soundness.
  completeness := by sorry

/--
Predicate stating that a named list represents a valid MUL instruction execution.
This captures the relationship between a pre-state, the instruction execution, and the resulting yield.
-/
def IsValidMulExecution
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (preState : State (F p))
    (timestamp : F p)
    (nl : NamedList (F p)) : Prop :=
  ∃ (rawInstr : RawInstruction (F p)) (mode1 mode2 mode3 : ℕ) (v1 v2 v3 : F p),
    Spec.fetchInstruction program preState.pc = some rawInstr ∧
    Spec.decodeInstruction rawInstr.rawInstrType = some (1, mode1, mode2, mode3) ∧
    Spec.dataMemoryAccess memory rawInstr.op1 mode1 preState.ap preState.fp = some v1 ∧
    Spec.dataMemoryAccess memory rawInstr.op2 mode2 preState.ap preState.fp = some v2 ∧
    Spec.dataMemoryAccess memory rawInstr.op3 mode3 preState.ap preState.fp = some v3 ∧
    v1 * v2 = v3 ∧
    nl = ⟨"execution", [timestamp + 1, preState.pc + 4, preState.ap, preState.fp]⟩

/--
Characterization theorem for MUL instruction localYields.
If something is in localYields and the spec holds, we can extract witnesses for all the conditions.
This is useful for inductive reasoning about execution traces.
-/
theorem mulStepSpec_localYields_characterization
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p)))
    (localYields : Set (NamedList (F p)))
    (nl : NamedList (F p))
    (h_spec : mulStepSpec program memory input yielded () localYields)
    (h_mem : nl ∈ localYields) :
    -- Then we can extract:
    input.enabled = 1 ∧
    input.timestamp + 1 ≠ 0 ∧
    ⟨"execution", [input.timestamp, input.preState.pc, input.preState.ap, input.preState.fp]⟩ ∈ yielded ∧
    IsValidMulExecution program memory input.preState input.timestamp nl := by
  simp only [mulStepSpec] at h_spec
  simp only [IsValidMulExecution]
  by_cases h_enabled : input.enabled = 1
  swap -- error case first
  · aesop
  simp only [h_enabled] at *
  simp only [↓reduceIte, ne_eq, if_false_right] at h_spec
  simp only [ne_eq, exists_and_left, existsAndEq, true_and]
  rcases h_spec with ⟨ h_overflow, h_spec ⟩
  constructor
  · simp_all
  rcases h_spec with ⟨ h_use, h_spec ⟩
  constructor
  · simp_all
  cases h_fetched : fetchInstruction program input.preState.pc
  · simp_all
  rename_i rawInstr
  use rawInstr
  constructor
  · rfl
  simp only [h_fetched] at h_spec
  cases h_decoded : decodeInstruction rawInstr.rawInstrType
  · simp_all
  rename_i decoded
  rcases decoded with ⟨ typ, mode1, mode2, mode3 ⟩
  simp only [h_decoded] at h_spec
  use mode1, mode2, mode3
  constructor
  · grind
  cases h_access1 : dataMemoryAccess memory rawInstr.op1 mode1 input.preState.ap input.preState.fp
  · grind
  cases h_access2 : dataMemoryAccess memory rawInstr.op2 mode2 input.preState.ap input.preState.fp
  · grind
  cases h_access3 : dataMemoryAccess memory rawInstr.op3 mode3 input.preState.ap input.preState.fp
  · grind
  rename_i v1 v2 v3
  use v1
  simp only [true_and]
  use v2
  simp only [true_and]
  simp_all

omit p_large_enough in
/--
Theorem stating that IsValidMulExecution implies a valid femtoCairoMachineTransition.
This connects the circuit specification to the machine semantics.
-/
theorem IsValidMulExecution_implies_valid_transition
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (preState : State (F p))
    (timestamp : F p)
    (nl : NamedList (F p))
    (h_valid : IsValidMulExecution program memory preState timestamp nl) :
    ∃ newState : State (F p),
      Spec.femtoCairoMachineTransition program memory preState = some newState ∧
      nl = ⟨"execution", [timestamp + 1, newState.pc, newState.ap, newState.fp]⟩ := by
  simp only [IsValidMulExecution] at h_valid
  rcases h_valid with ⟨rawInstr, mode1, mode2, mode3, v1, v2, v3, h_fetch, h_decode, h_access1, h_access2, h_access3, h_mul, h_nl⟩
  use { pc := preState.pc + 4, ap := preState.ap, fp := preState.fp }
  constructor
  · simp only [Spec.femtoCairoMachineTransition, Option.bind_eq_bind, h_fetch]
    simp only [h_decode, Option.bind_some, h_access1, h_access2, h_access3, computeNextState]
    aesop
  · exact h_nl

/--
Bundle of MUL instruction step circuits.
Takes a vector of inputs with given capacity and executes MUL instructions for each enabled input.
-/
def mulStepCircuitsBundle
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (inputs : Var (ProvableVector InstructionStepInput capacity) (F p)) : Circuit (F p) Unit := do
  let _ ← Circuit.mapFinRange capacity fun i =>
    subcircuitWithAssertion (mulStepFormalCircuit program h_programSize memory h_memorySize) inputs[i.val]
  return ()

/--
Elaborated circuit for MUL instruction bundle.
-/
def mulStepCircuitsBundleElaborated
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) (ProvableVector InstructionStepInput capacity) unit where
  main := mulStepCircuitsBundle capacity program h_programSize memory h_memorySize
  localLength _ := capacity * 29  -- Each step uses 29 locals
  localLength_eq := by
    intros input offset
    simp only [circuit_norm, mulStepCircuitsBundle]
    congr 1
  yields inputs env offset :=
    ⋃ i : Fin capacity, mulStepLocalYields (eval env inputs[i])
  yields_eq := by
    intros inputs env offset
    simp only [circuit_norm, mulStepCircuitsBundle]
    ext nl
    simp only [Set.mem_iUnion]
    constructor
    · intro ⟨i, hi⟩
      use i
      simp only [mulStepFormalCircuit, mulStepElaboratedCircuit, circuit_norm] at hi
      exact hi
    · intro ⟨i, hi⟩
      use i
      simp only [mulStepFormalCircuit, mulStepElaboratedCircuit, circuit_norm]
      exact hi
  subcircuitsConsistent := by
    intros inputs offset
    simp only [circuit_norm, mulStepCircuitsBundle]

/--
Assumptions for the bundle: each input must satisfy the individual step assumptions.
-/
def mulStepCircuitsBundleAssumptions
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize]
    (inputs : ProvableVector InstructionStepInput capacity (F p)) (_yielded : Set (NamedList (F p))) : Prop :=
  ∀ i : Fin capacity, mulStepAssumptions (programSize := programSize) inputs[i] _yielded

/--
Spec for the bundle: each element satisfies its step spec, and local yields are the union.
-/
def mulStepCircuitsBundleSpec
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (inputs : ProvableVector InstructionStepInput capacity (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  (∀ i : Fin capacity, mulStepSpec program memory inputs[i] yielded () (mulStepLocalYields inputs[i])) ∧
  localYields = ⋃ i : Fin capacity, mulStepLocalYields inputs[i]

/--
GeneralFormalCircuit for MUL instruction bundle.
-/
def mulStepCircuitsBundleFormalCircuit
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) (ProvableVector InstructionStepInput capacity) unit where
  elaborated := mulStepCircuitsBundleElaborated capacity program h_programSize memory h_memorySize
  Assumptions := mulStepCircuitsBundleAssumptions capacity (programSize := programSize)
  Spec := mulStepCircuitsBundleSpec capacity program memory
  soundness := by
    circuit_proof_start [mulStepCircuitsBundleElaborated, mulStepCircuitsBundleSpec]
    simp only [mulStepCircuitsBundle, circuit_norm, mulStepFormalCircuit] at h_holds
    and_intros
    · intro i
      specialize h_holds i
      simp only [mulStepElaboratedCircuit] at h_holds
      simp only [Fin.eta] at h_holds
      cases iv_h : Vector.get input_var i
      rename_i enabledVar timestampVar preStateVar
      simp only [iv_h] at h_holds
      simp only [← h_input, eval_vector, Vector.getElem_map]
      rw [Vector.get_eq_getElem] at iv_h
      conv =>
        arg 3
        simp only [iv_h]
        simp only [circuit_norm]
      assumption
    · apply Set.iUnion_congr
      intro i
      congr 1
      simp only [← h_input, eval_vector, Vector.getElem_map]
      cases iv_h : Vector.get input_var i
      rename_i enabledVar timestampVar preStateVar
      rw [Vector.get_eq_getElem] at iv_h
      simp only [iv_h]
      conv_rhs =>
        simp only [circuit_norm]
  completeness := sorry

/--
Characterization theorem for MUL instruction bundle localYields.
Given a bundle spec and a named list in the local yields, we can find which instruction index it came from
and extract witnesses for all the conditions.
-/
theorem mulStepCircuitsBundleSpec_localYields_characterization
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (inputs : ProvableVector InstructionStepInput capacity (F p)) (yielded : Set (NamedList (F p)))
    (localYields : Set (NamedList (F p)))
    (nl : NamedList (F p))
    (h_spec : mulStepCircuitsBundleSpec capacity program memory inputs yielded () localYields)
    (h_mem : nl ∈ localYields) :
    -- Then we can find an index i such that the conditions hold for inputs[i]
    ∃ (i : Fin capacity),
      inputs[i].enabled = 1 ∧
      inputs[i].timestamp + 1 ≠ 0 ∧
      ⟨"execution", [inputs[i].timestamp, inputs[i].preState.pc, inputs[i].preState.ap, inputs[i].preState.fp]⟩ ∈ yielded ∧
      IsValidMulExecution program memory inputs[i].preState inputs[i].timestamp nl := by
  simp only [mulStepCircuitsBundleSpec] at h_spec
  rcases h_spec with ⟨h_all, h_yields⟩
  rw [h_yields] at h_mem
  simp only [Set.mem_iUnion] at h_mem
  rcases h_mem with ⟨i, h_i⟩
  use i
  exact mulStepSpec_localYields_characterization program memory inputs[i] yielded (mulStepLocalYields inputs[i]) nl (h_all i) h_i

end Examples.PicoCairo
