/-
PicoCairo Trace Execution Main Circuit
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Circuit.StructuralLemmas
import Clean.Utils.Vector
import Clean.Examples.PicoCairo.Types
import Clean.Examples.PicoCairo.ExecutionBundle
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.Spec

namespace Examples.PicoCairo

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Input structure for the execution circuit, bundling all parameters.
-/
structure ExecutionCircuitInput (capacities : InstructionCapacities) (F : Type) where
  initialState : FemtoCairo.Types.State F
  finalTimestamp : F
  finalState : FemtoCairo.Types.State F
  bundledInputs : BundledInstructionInputs capacities F

instance (capacities : InstructionCapacities) : ProvableStruct (ExecutionCircuitInput capacities) where
  components := [
    FemtoCairo.Types.State,
    field,
    FemtoCairo.Types.State,
    BundledInstructionInputs capacities
  ]
  toComponents := fun { initialState, finalTimestamp, finalState, bundledInputs } =>
    .cons initialState (.cons finalTimestamp (.cons finalState (.cons bundledInputs .nil)))
  fromComponents := fun (.cons initialState (.cons finalTimestamp (.cons finalState (.cons bundledInputs .nil)))) =>
    { initialState, finalTimestamp, finalState, bundledInputs }

/--
Main execution circuit that proves a trace from initial to final state.
Yields the initial state, runs the execution bundle, and uses the final state.
-/
def executionCircuitMain
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : Var (ExecutionCircuitInput capacities) (F p)) :
    Circuit (F p) Unit := do

  -- Yield initial state at timestamp 0
  yield ⟨"execution", [Expression.const 0, input.initialState.pc,
                        input.initialState.ap, input.initialState.fp]⟩

  -- Run the execution bundle (proves intermediate steps)
  executionBundleFormalCircuit capacities program h_programSize memory h_memorySize input.bundledInputs

  -- Use the expected final state
  use ⟨"execution", [input.finalTimestamp, input.finalState.pc,
                     input.finalState.ap, input.finalState.fp]⟩

  return ()

/--
Assumptions for the execution circuit: same as execution bundle assumptions.
-/
def executionCircuitAssumptions
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize]
    (input : ExecutionCircuitInput capacities (F p)) (yielded : Set (NamedList (F p))) : Prop :=
  executionBundleAssumptions capacities (programSize := programSize) input.bundledInputs yielded

/--
Spec for the execution circuit: yields initial state, execution bundle spec holds, uses final state.
The local yields are the union of the initial state yield and the execution bundle's local yields.
-/
def executionCircuitSpec
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : ExecutionCircuitInput capacities (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  ∃ (bundleLocalYields : Set (NamedList (F p))),
    -- Execution bundle spec holds
    executionBundleSpec capacities program memory input.bundledInputs yielded () bundleLocalYields ∧
    -- Final state is used (must be in yielded)
    ⟨"execution", [input.finalTimestamp, input.finalState.pc, input.finalState.ap, input.finalState.fp]⟩ ∈ yielded ∧
    -- Local yields are the initial state plus bundle local yields
    localYields = {⟨"execution", [0, input.initialState.pc, input.initialState.ap, input.initialState.fp]⟩} ∪ bundleLocalYields

/--
Elaborated circuit for the execution circuit.
-/
def executionCircuitElaborated
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) (ExecutionCircuitInput capacities) unit where
  main := executionCircuitMain capacities program h_programSize memory h_memorySize
  localLength input_var :=
    (executionBundleFormalCircuit capacities program h_programSize memory h_memorySize).elaborated.localLength input_var.bundledInputs
  yields input_var env i₀ :=
    let initialState := eval env input_var.initialState
    {⟨"execution", [0, initialState.pc, initialState.ap, initialState.fp]⟩} ∪
    (executionBundleFormalCircuit capacities program h_programSize memory h_memorySize).elaborated.yields input_var.bundledInputs env i₀
  output input_var env := ()
  localLength_eq := by
    intro input_var n
    simp only [executionCircuitMain, circuit_norm]
  yields_eq := by
    intro input_var env i₀
    simp only [executionCircuitMain, circuit_norm]
    ext nl
    simp only [Set.mem_union, Set.mem_setOf_eq, Set.mem_singleton_iff]
    constructor
    · intro h
      rcases h with h_yield | h_bundle
      · left
        rcases h_yield with ⟨h_eq, _⟩
        simp only [NamedList.eval] at h_eq
        exact h_eq
      · right
        exact h_bundle
    · intro h
      rcases h with h_eq | h_bundle
      · left
        constructor
        · simp only [NamedList.eval]
          exact h_eq
        · norm_num
      · right
        exact h_bundle
  output_eq := by
    intro input_var env
    simp only [executionCircuitMain, circuit_norm]

/--
Formal circuit for the execution circuit, packaging everything together.
-/
def executionCircuitFormalCircuit
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) (ExecutionCircuitInput capacities) unit where
  elaborated := executionCircuitElaborated capacities program h_programSize memory h_memorySize
  Assumptions := executionCircuitAssumptions capacities (programSize := programSize)
  Spec := executionCircuitSpec capacities program memory
  soundness := by
    circuit_proof_start [executionCircuitSpec, executionCircuitElaborated, executionCircuitMain]
    -- Extract the bundle spec from h_holds
    obtain ⟨h_bundle_spec, h_final_used⟩ := h_holds
    -- The bundle local yields are exactly what the bundle circuit yields
    use (executionBundleFormalCircuit capacities program h_programSize memory h_memorySize).elaborated.yields input_var.bundledInputs env i₀
    constructor
    · -- Bundle spec holds
      rw [← h_input]
      simp only [eval]
      exact h_bundle_spec
    constructor
    · -- Final state is in yielded
      have := h_final_used (by norm_num)
      simp only [NamedList.eval] at this
      rw [← h_input]
      simp only [eval]
      exact this
    · -- Local yields equality
      rw [← h_input]
  completeness := by sorry

/--
Lemma: All elements in localYields have the form "execution" with a 4-element list.
-/
theorem executionCircuitSpec_localYields_structure
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : ExecutionCircuitInput capacities (F p))
    (yielded : Set (NamedList (F p)))
    (localYields : Set (NamedList (F p)))
    (nl : NamedList (F p))
    (h_spec : executionCircuitSpec capacities program memory input yielded () localYields)
    (h_mem : nl ∈ localYields) :
    ∃ (timestamp pc ap fp : F p),
      nl = ⟨"execution", [timestamp, pc, ap, fp]⟩ := by
  -- Extract bundle local yields from spec
  obtain ⟨bundleLocalYields, h_bundle_spec, h_final_used, h_local_yields⟩ := h_spec
  rw [h_local_yields] at h_mem
  simp only [Set.mem_union, Set.mem_singleton_iff] at h_mem
  rcases h_mem with h_initial | h_bundle
  · -- Case 1: nl is the initial state
    use 0, input.initialState.pc, input.initialState.ap, input.initialState.fp
  · -- Case 2: nl is from bundle local yields
    -- Use executionBundleSpec_localYields_characterization
    have ⟨preState, timestamp, h_input_match, h_overflow, h_yielded, h_valid⟩ :=
      executionBundleSpec_localYields_characterization capacities program memory input.bundledInputs yielded bundleLocalYields nl h_bundle_spec h_bundle
    -- Use IsValidInstructionExecution_implies_valid_transition
    have ⟨newState, h_transition, h_nl⟩ :=
      IsValidInstructionExecution_implies_valid_transition program memory preState timestamp nl h_valid
    use timestamp + 1, newState.pc, newState.ap, newState.fp

/--
Theorem: Every element in localYields represents a state in the execution from initialState.
This shows that the spec implies all local yields correspond to reachable states.
-/
theorem executionCircuitSpec_localYields_reachable
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : ExecutionCircuitInput capacities (F p))
    (yielded : Set (NamedList (F p)))
    (localYields : Set (NamedList (F p)))
    (nl : NamedList (F p))
    (h_spec : executionCircuitSpec capacities program memory input yielded () localYields)
    (h_mem : nl ∈ localYields)
    (h_yielded_eq : localYields = yielded) :
    ∃ (timestamp : F p) (state : FemtoCairo.Types.State (F p)) (steps : ℕ),
      timestamp = steps ∧
      steps < p ∧
      FemtoCairo.Spec.femtoCairoMachineBoundedExecution program memory (some input.initialState) steps = some state ∧
      nl = ⟨"execution", [timestamp, state.pc, state.ap, state.fp]⟩ := by
  -- First, use the structure lemma to get the timestamp
  have ⟨timestamp, pc, ap, fp, h_nl_structure⟩ :=
    executionCircuitSpec_localYields_structure capacities program memory input yielded localYields nl h_spec h_mem
  -- Now do induction on timestamp.val
  -- Generalize timestamp, pc, ap, fp, and nl before induction so IH is more flexible
  generalize h_timestamp_val : timestamp.val = n
  revert timestamp pc ap fp nl h_nl_structure h_mem h_timestamp_val
  induction n with
  | zero =>
    intro nl h_mem timestamp pc ap fp h_nl_structure h_timestamp_val
    obtain ⟨bundleLocalYields, h_bundle_spec, h_final_used, h_local_yields⟩ := h_spec
    rw [h_local_yields] at h_mem
    simp only [Set.mem_union, Set.mem_singleton_iff] at h_mem
    rcases h_mem with h_initial | h_bundle
    · -- nl is the initial state
      use 0, input.initialState, 0
      constructor
      · simp
      constructor
      · exact Nat.zero_lt_of_lt p_large_enough.out
      constructor
      · simp [FemtoCairo.Spec.femtoCairoMachineBoundedExecution]
      · exact h_initial
    · -- nl is from bundle but has timestamp.val = 0
      -- This is impossible: bundle yields have timestamp = preTimestamp + 1 ≠ 0
      have ⟨preState, newState, preTimestamp, h_input_match, h_overflow, h_preState_yielded, h_transition, h_nl_eq⟩ :=
        executionBundleSpec_implies_valid_transition capacities program memory input.bundledInputs yielded bundleLocalYields nl h_bundle_spec h_bundle

      -- From h_nl_eq, we know nl has timestamp = preTimestamp + 1
      rw [h_nl_structure] at h_nl_eq
      injection h_nl_eq with _ h_values_eq
      have h_timestamp_eq : timestamp = preTimestamp + 1 := by
        have := congrArg List.head? h_values_eq
        simp at this
        exact this

      -- But timestamp.val = 0 means timestamp = 0
      have h_timestamp_zero : timestamp = 0 := by
        apply ZMod.val_injective
        rw [h_timestamp_val]
        simp

      -- So preTimestamp + 1 = 0, contradicting h_overflow
      rw [h_timestamp_zero] at h_timestamp_eq
      exact absurd h_timestamp_eq.symm h_overflow
  | succ t IH =>
    intro nl h_mem timestamp pc ap fp h_nl_structure h_timestamp_val
    obtain ⟨bundleLocalYields, h_bundle_spec, h_final_used, h_local_yields⟩ := h_spec
    rw [h_local_yields] at h_mem
    simp only [Set.mem_union, Set.mem_singleton_iff] at h_mem
    rcases h_mem with h_initial | h_bundle
    · -- nl is the initial state, but timestamp.val = t + 1 ≠ 0, contradiction
      rw [h_nl_structure] at h_initial
      injection h_initial with _ h_values_eq
      have h_timestamp_zero : timestamp = 0 := by
        have := congrArg List.head? h_values_eq
        simp at this
        exact this
      -- Now we have timestamp.val = t + 1 and timestamp = 0, so 0 = t + 1 at the Nat level, contradiction
      simp [h_timestamp_zero] at h_timestamp_val
    · -- nl is from bundle local yields
      -- Use the combined theorem to get preState, newState, and transition
      have ⟨preState, newState, preTimestamp, h_input_match, h_overflow, h_preState_yielded, h_transition, h_nl_eq⟩ :=
        executionBundleSpec_implies_valid_transition capacities program memory input.bundledInputs yielded bundleLocalYields nl h_bundle_spec h_bundle

      -- From h_nl_eq and h_nl_structure, extract equalities
      rw [h_nl_structure] at h_nl_eq
      injection h_nl_eq with _ h_values_eq

      -- Extract timestamp = preTimestamp + 1
      have h_timestamp_eq : timestamp = preTimestamp + 1 := by
        have := congrArg List.head? h_values_eq
        simp at this
        exact this

      -- Extract pc = newState.pc, ap = newState.ap, fp = newState.fp
      have h_pc_eq : pc = newState.pc := by
        have := congrArg (fun l => l.tail?.bind List.head?) h_values_eq
        simp at this
        exact this
      have h_ap_eq : ap = newState.ap := by
        have := congrArg (fun l => l.tail?.bind (·.tail?.bind List.head?)) h_values_eq
        simp at this
        exact this
      have h_fp_eq : fp = newState.fp := by
        have := congrArg (fun l => l.tail?.bind (·.tail?.bind (·.tail?.bind List.head?))) h_values_eq
        simp at this
        exact this

      -- First show preTimestamp.val = t
      have h_preTimestamp_val : preTimestamp.val = t := by
        have h_eq : (preTimestamp + 1).val = t + 1 := by
          rw [← h_timestamp_eq, h_timestamp_val]
        -- Use h_overflow to show no overflow occurred
        have h_no_overflow : preTimestamp.val + (1 : F p).val < p := by
          simp only [ZMod.val_one]
          by_contra h_not
          push_neg at h_not
          -- If preTimestamp.val + 1 ≥ p, and preTimestamp.val < p, then preTimestamp.val + 1 = p
          have h_val_eq : preTimestamp.val + 1 = p := by
            have : preTimestamp.val < p := ZMod.val_lt preTimestamp
            omega
          -- Then (preTimestamp + 1).val = 0
          have : (preTimestamp + 1).val = 0 := by
            have h_le : p ≤ preTimestamp.val + (1 : F p).val := by simp only [ZMod.val_one]; omega
            rw [ZMod.val_add_of_le h_le]
            simp only [ZMod.val_one, h_val_eq]
            simp
          -- But h_eq says (preTimestamp + 1).val = t + 1, contradiction
          rw [this] at h_eq
          omega
        rw [ZMod.val_add_of_lt h_no_overflow] at h_eq
        simp only [ZMod.val_one] at h_eq
        omega

      -- Use IH to show preState is reachable
      have h_preState_in_localYields : ⟨"execution", [preTimestamp, preState.pc, preState.ap, preState.fp]⟩ ∈ localYields := by
        rw [h_yielded_eq]
        exact h_preState_yielded

      have ⟨preTimestamp', preState', preSteps, h_preTimestamp_eq, h_preSteps_lt, h_preState_reach, h_preState_nl⟩ :=
        IH _ h_preState_in_localYields preTimestamp preState.pc preState.ap preState.fp rfl h_preTimestamp_val

      -- Now extend by one transition to get newState
      have h_lt : t + 1 < p := by
        rw [← h_timestamp_val]
        exact ZMod.val_lt timestamp

      use timestamp, newState, (t + 1)
      constructor
      · apply ZMod.val_injective
        rw [h_timestamp_val]
        rw [ZMod.val_cast_of_lt h_lt]
      constructor
      · exact h_lt
      constructor
      · -- Extract that preState' = preState and preTimestamp' = preTimestamp
        have h_preTimestamp'_eq : preTimestamp' = preTimestamp := by
          have := congrArg (fun nl => nl.values.head?) h_preState_nl
          simp at this
          exact this.symm
        have h_preState'_eq : preState' = preState := by
          have h_pc : preState'.pc = preState.pc := by
            have := congrArg (fun nl => nl.values.tail?.bind List.head?) h_preState_nl
            simp at this
            exact this.symm
          have h_ap : preState'.ap = preState.ap := by
            have := congrArg (fun nl => nl.values.tail?.bind (·.tail?.bind List.head?)) h_preState_nl
            simp at this
            exact this.symm
          have h_fp : preState'.fp = preState.fp := by
            have := congrArg (fun nl => nl.values.tail?.bind (·.tail?.bind (·.tail?.bind List.head?))) h_preState_nl
            simp at this
            exact this.symm
          cases preState'; cases preState
          simp at h_pc h_ap h_fp
          simp [h_pc, h_ap, h_fp]
        -- Now we have:
        -- h_preState_reach : BoundedExecution ... preSteps = some preState'
        -- h_preState'_eq : preState' = preState
        -- h_transition : MachineTransition ... preState = some newState
        -- h_preTimestamp_eq : preTimestamp' = ↑preSteps
        -- h_preTimestamp'_eq : preTimestamp' = preTimestamp
        -- h_preTimestamp_val : preTimestamp.val = t
        -- Need to show preSteps = t
        have h_preSteps_eq : preSteps = t := by
          have : preTimestamp'.val = preSteps := by
            rw [h_preTimestamp_eq]
            exact ZMod.val_cast_of_lt h_preSteps_lt
          rw [h_preTimestamp'_eq, h_preTimestamp_val] at this
          exact this.symm
        -- Use femtoCairoMachineBoundedExecution_succ
        rw [← h_preSteps_eq]
        apply FemtoCairo.Spec.femtoCairoMachineBoundedExecution_succ (state := preState)
        · rw [← h_preState'_eq]
          exact h_preState_reach
        · exact h_transition
      · rw [h_nl_structure]
        simp only [h_timestamp_eq, h_pc_eq, h_ap_eq, h_fp_eq]

/--
**Execution Circuit with Proven Reachability** 🎉

This is a strengthened version of executionCircuitFormalCircuit that proves:
If localYields = yielded (i.e., the circuit doesn't use any external yields),
then the final state is reachable from the initial state via valid Cairo execution.

The spec states: there exists a number of steps and a valid execution trace such that
starting from initialState and executing for that many steps reaches finalState.

This is the main soundness theorem for PicoCairo's yield-based execution traces!
-/
def executionCircuitProvenReachability
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) (ExecutionCircuitInput capacities) unit :=
  (executionCircuitFormalCircuit capacities program h_programSize memory h_memorySize).weakenSpec
    (fun input yielded _output localYields =>
      -- Assume localYields = yielded
      localYields = yielded →
      -- Then the final state is reachable from initial state
      ∃ (steps : ℕ),
        steps < p ∧
        FemtoCairo.Spec.femtoCairoMachineBoundedExecution program memory (some input.initialState) steps = some input.finalState)
    (by
      intro input yielded output localYields h_strong_spec h_yielded_eq
      -- Use the reachability theorem we proved
      obtain ⟨bundleLocalYields, h_bundle_spec, h_final_used, h_local_yields⟩ := h_strong_spec
      -- The final state element is in localYields (since localYields = yielded)
      have h_final_in_localYields : ⟨"execution", [input.finalTimestamp, input.finalState.pc, input.finalState.ap, input.finalState.fp]⟩ ∈ localYields := by
        rw [h_yielded_eq]
        exact h_final_used
      -- Reconstruct the spec for the reachability theorem
      have h_spec : executionCircuitSpec capacities program memory input yielded () localYields :=
        ⟨bundleLocalYields, h_bundle_spec, h_final_used, h_local_yields⟩
      -- Apply the reachability theorem
      have ⟨timestamp, state, steps, h_timestamp_eq, h_steps_lt, h_reach, h_nl_eq⟩ :=
        executionCircuitSpec_localYields_reachable capacities program memory input yielded localYields
          ⟨"execution", [input.finalTimestamp, input.finalState.pc, input.finalState.ap, input.finalState.fp]⟩
          h_spec h_final_in_localYields h_yielded_eq
      -- Extract that state = finalState
      injection h_nl_eq with _ h_values_eq
      have h_pc_eq : state.pc = input.finalState.pc := by
        have := congrArg (fun l => l.tail?.bind List.head?) h_values_eq
        simp at this
        exact this.symm
      have h_ap_eq : state.ap = input.finalState.ap := by
        have := congrArg (fun l => l.tail?.bind (·.tail?.bind List.head?)) h_values_eq
        simp at this
        exact this.symm
      have h_fp_eq : state.fp = input.finalState.fp := by
        have := congrArg (fun l => l.tail?.bind (·.tail?.bind (·.tail?.bind List.head?))) h_values_eq
        simp at this
        exact this.symm
      use steps
      constructor
      · exact h_steps_lt
      · aesop)

end Examples.PicoCairo
