/-
PicoCairo Trace Execution Main Circuit
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Utils.Vector
import Clean.Examples.PicoCairo.Types
import Clean.Examples.PicoCairo.ExecutionBundle
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.Spec

namespace Examples.PicoCairo

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Input structure for the execution circuit, bundling all parameters.
-/
structure ExecutionCircuitInput (capacities : InstructionCapacities) (F : Type) where
  initialState : FemtoCairo.Types.State F
  finalTimestamp : F
  finalState : FemtoCairo.Types.State F
  bundledInputs : BundledInstructionInputs capacities F

instance (capacities : InstructionCapacities) : ProvableStruct (ExecutionCircuitInput capacities) where
  components := [
    FemtoCairo.Types.State,
    field,
    FemtoCairo.Types.State,
    BundledInstructionInputs capacities
  ]
  toComponents := fun { initialState, finalTimestamp, finalState, bundledInputs } =>
    .cons initialState (.cons finalTimestamp (.cons finalState (.cons bundledInputs .nil)))
  fromComponents := fun (.cons initialState (.cons finalTimestamp (.cons finalState (.cons bundledInputs .nil)))) =>
    { initialState, finalTimestamp, finalState, bundledInputs }

/--
Main execution circuit that proves a trace from initial to final state.
Yields the initial state, runs the execution bundle, and uses the final state.
-/
def executionCircuitMain
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : Var (ExecutionCircuitInput capacities) (F p)) :
    Circuit (F p) Unit := do

  -- Yield initial state at timestamp 0
  yield ⟨"execution", [Expression.const 0, input.initialState.pc,
                        input.initialState.ap, input.initialState.fp]⟩

  -- Run the execution bundle (proves intermediate steps)
  executionBundleFormalCircuit capacities program h_programSize memory h_memorySize input.bundledInputs

  -- Use the expected final state
  use ⟨"execution", [input.finalTimestamp, input.finalState.pc,
                     input.finalState.ap, input.finalState.fp]⟩

  return ()

/--
Assumptions for the execution circuit: same as execution bundle assumptions.
-/
def executionCircuitAssumptions
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize]
    (input : ExecutionCircuitInput capacities (F p)) (yielded : Set (NamedList (F p))) : Prop :=
  executionBundleAssumptions capacities (programSize := programSize) input.bundledInputs yielded

/--
Spec for the execution circuit: yields initial state, execution bundle spec holds, uses final state.
The local yields are the union of the initial state yield and the execution bundle's local yields.
-/
def executionCircuitSpec
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : ExecutionCircuitInput capacities (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  ∃ (bundleLocalYields : Set (NamedList (F p))),
    -- Execution bundle spec holds
    executionBundleSpec capacities program memory input.bundledInputs yielded () bundleLocalYields ∧
    -- Final state is used (must be in yielded)
    ⟨"execution", [input.finalTimestamp, input.finalState.pc, input.finalState.ap, input.finalState.fp]⟩ ∈ yielded ∧
    -- Local yields are the initial state plus bundle local yields
    localYields = {⟨"execution", [0, input.initialState.pc, input.initialState.ap, input.initialState.fp]⟩} ∪ bundleLocalYields

/--
Elaborated circuit for the execution circuit.
-/
def executionCircuitElaborated
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) (ExecutionCircuitInput capacities) unit where
  main := executionCircuitMain capacities program h_programSize memory h_memorySize
  localLength input_var :=
    (executionBundleFormalCircuit capacities program h_programSize memory h_memorySize).elaborated.localLength input_var.bundledInputs
  yields input_var env i₀ :=
    let initialState := eval env input_var.initialState
    {⟨"execution", [0, initialState.pc, initialState.ap, initialState.fp]⟩} ∪
    (executionBundleFormalCircuit capacities program h_programSize memory h_memorySize).elaborated.yields input_var.bundledInputs env i₀
  output input_var env := ()
  localLength_eq := by sorry
  yields_eq := by sorry
  output_eq := by sorry

/--
Formal circuit for the execution circuit, packaging everything together.
-/
def executionCircuitFormalCircuit
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) (ExecutionCircuitInput capacities) unit where
  elaborated := executionCircuitElaborated capacities program h_programSize memory h_memorySize
  Assumptions := executionCircuitAssumptions capacities (programSize := programSize)
  Spec := executionCircuitSpec capacities program memory
  soundness := by sorry
  completeness := by sorry

end Examples.PicoCairo
