/-
PicoCairo Trace Execution Main Circuit
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Utils.Vector
import Clean.Examples.PicoCairo.Types
import Clean.Examples.PicoCairo.ExecutionBundle
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.Spec

namespace Examples.PicoCairo

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Input structure for the execution circuit, bundling all parameters.
-/
structure ExecutionCircuitInput (capacities : InstructionCapacities) (F : Type) where
  initialState : FemtoCairo.Types.State F
  finalTimestamp : F
  finalState : FemtoCairo.Types.State F
  bundledInputs : BundledInstructionInputs capacities F

instance (capacities : InstructionCapacities) : ProvableStruct (ExecutionCircuitInput capacities) where
  components := [
    FemtoCairo.Types.State,
    field,
    FemtoCairo.Types.State,
    BundledInstructionInputs capacities
  ]
  toComponents := fun { initialState, finalTimestamp, finalState, bundledInputs } =>
    .cons initialState (.cons finalTimestamp (.cons finalState (.cons bundledInputs .nil)))
  fromComponents := fun (.cons initialState (.cons finalTimestamp (.cons finalState (.cons bundledInputs .nil)))) =>
    { initialState, finalTimestamp, finalState, bundledInputs }

/--
Main execution circuit that proves a trace from initial to final state.
Yields the initial state, runs the execution bundle, and uses the final state.
-/
def executionCircuitMain
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : Var (ExecutionCircuitInput capacities) (F p)) :
    Circuit (F p) Unit := do

  -- Yield initial state at timestamp 0
  yield ⟨"execution", [Expression.const 0, input.initialState.pc,
                        input.initialState.ap, input.initialState.fp]⟩

  -- Run the execution bundle (proves intermediate steps)
  executionBundleFormalCircuit capacities program h_programSize memory h_memorySize input.bundledInputs

  -- Use the expected final state
  use ⟨"execution", [input.finalTimestamp, input.finalState.pc,
                     input.finalState.ap, input.finalState.fp]⟩

  return ()

/--
Assumptions for the execution circuit: same as execution bundle assumptions.
-/
def executionCircuitAssumptions
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize]
    (input : ExecutionCircuitInput capacities (F p)) (yielded : Set (NamedList (F p))) : Prop :=
  executionBundleAssumptions capacities (programSize := programSize) input.bundledInputs yielded

/--
Spec for the execution circuit: yields initial state, execution bundle spec holds, uses final state.
The local yields are the union of the initial state yield and the execution bundle's local yields.
-/
def executionCircuitSpec
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : ExecutionCircuitInput capacities (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  ∃ (bundleLocalYields : Set (NamedList (F p))),
    -- Execution bundle spec holds
    executionBundleSpec capacities program memory input.bundledInputs yielded () bundleLocalYields ∧
    -- Final state is used (must be in yielded)
    ⟨"execution", [input.finalTimestamp, input.finalState.pc, input.finalState.ap, input.finalState.fp]⟩ ∈ yielded ∧
    -- Local yields are the initial state plus bundle local yields
    localYields = {⟨"execution", [0, input.initialState.pc, input.initialState.ap, input.initialState.fp]⟩} ∪ bundleLocalYields

/--
Elaborated circuit for the execution circuit.
-/
def executionCircuitElaborated
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) (ExecutionCircuitInput capacities) unit where
  main := executionCircuitMain capacities program h_programSize memory h_memorySize
  localLength input_var :=
    (executionBundleFormalCircuit capacities program h_programSize memory h_memorySize).elaborated.localLength input_var.bundledInputs
  yields input_var env i₀ :=
    let initialState := eval env input_var.initialState
    {⟨"execution", [0, initialState.pc, initialState.ap, initialState.fp]⟩} ∪
    (executionBundleFormalCircuit capacities program h_programSize memory h_memorySize).elaborated.yields input_var.bundledInputs env i₀
  output input_var env := ()
  localLength_eq := by
    intro input_var n
    simp only [executionCircuitMain, circuit_norm]
  yields_eq := by
    intro input_var env i₀
    simp only [executionCircuitMain, circuit_norm]
    ext nl
    simp only [Set.mem_union, Set.mem_setOf_eq, Set.mem_singleton_iff]
    constructor
    · intro h
      rcases h with h_yield | h_bundle
      · left
        rcases h_yield with ⟨h_eq, _⟩
        simp only [NamedList.eval] at h_eq
        exact h_eq
      · right
        exact h_bundle
    · intro h
      rcases h with h_eq | h_bundle
      · left
        constructor
        · simp only [NamedList.eval]
          exact h_eq
        · norm_num
      · right
        exact h_bundle
  output_eq := by
    intro input_var env
    simp only [executionCircuitMain, circuit_norm]

/--
Formal circuit for the execution circuit, packaging everything together.
-/
def executionCircuitFormalCircuit
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) (ExecutionCircuitInput capacities) unit where
  elaborated := executionCircuitElaborated capacities program h_programSize memory h_memorySize
  Assumptions := executionCircuitAssumptions capacities (programSize := programSize)
  Spec := executionCircuitSpec capacities program memory
  soundness := by
    circuit_proof_start [executionCircuitSpec, executionCircuitElaborated, executionCircuitMain]
    -- Extract the bundle spec from h_holds
    obtain ⟨h_bundle_spec, h_final_used⟩ := h_holds
    -- The bundle local yields are exactly what the bundle circuit yields
    use (executionBundleFormalCircuit capacities program h_programSize memory h_memorySize).elaborated.yields input_var.bundledInputs env i₀
    constructor
    · -- Bundle spec holds
      rw [← h_input]
      simp only [eval]
      exact h_bundle_spec
    constructor
    · -- Final state is in yielded
      have := h_final_used (by norm_num)
      simp only [NamedList.eval] at this
      rw [← h_input]
      simp only [eval]
      exact this
    · -- Local yields equality
      rw [← h_input]
  completeness := by sorry

/--
Lemma: All elements in localYields have the form "execution" with a 4-element list.
-/
theorem executionCircuitSpec_localYields_structure
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : ExecutionCircuitInput capacities (F p))
    (yielded : Set (NamedList (F p)))
    (localYields : Set (NamedList (F p)))
    (nl : NamedList (F p))
    (h_spec : executionCircuitSpec capacities program memory input yielded () localYields)
    (h_mem : nl ∈ localYields) :
    ∃ (timestamp pc ap fp : F p),
      nl = ⟨"execution", [timestamp, pc, ap, fp]⟩ := by
  -- Extract bundle local yields from spec
  obtain ⟨bundleLocalYields, h_bundle_spec, h_final_used, h_local_yields⟩ := h_spec
  rw [h_local_yields] at h_mem
  simp only [Set.mem_union, Set.mem_singleton_iff] at h_mem
  rcases h_mem with h_initial | h_bundle
  · -- Case 1: nl is the initial state
    use 0, input.initialState.pc, input.initialState.ap, input.initialState.fp
  · -- Case 2: nl is from bundle local yields
    -- Use executionBundleSpec_localYields_characterization
    have ⟨preState, timestamp, h_input_match, h_overflow, h_yielded, h_valid⟩ :=
      executionBundleSpec_localYields_characterization capacities program memory input.bundledInputs yielded bundleLocalYields nl h_bundle_spec h_bundle
    -- Use IsValidInstructionExecution_implies_valid_transition
    have ⟨newState, h_transition, h_nl⟩ :=
      IsValidInstructionExecution_implies_valid_transition program memory preState timestamp nl h_valid
    use timestamp + 1, newState.pc, newState.ap, newState.fp

/--
Theorem: Every element in localYields represents a state in the execution from initialState.
This shows that the spec implies all local yields correspond to reachable states.
-/
theorem executionCircuitSpec_localYields_reachable
    (capacities : InstructionCapacities)
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : ExecutionCircuitInput capacities (F p))
    (yielded : Set (NamedList (F p)))
    (localYields : Set (NamedList (F p)))
    (nl : NamedList (F p))
    (h_spec : executionCircuitSpec capacities program memory input yielded () localYields)
    (h_mem : nl ∈ localYields) :
    ∃ (timestamp : F p) (state : FemtoCairo.Types.State (F p)) (steps : ℕ),
      timestamp = steps ∧
      FemtoCairo.Spec.femtoCairoMachineBoundedExecution program memory (some input.initialState) steps = some state ∧
      nl = ⟨"execution", [timestamp, state.pc, state.ap, state.fp]⟩ := by
  -- Extract bundle local yields from spec
  obtain ⟨bundleLocalYields, h_bundle_spec, h_final_used, h_local_yields⟩ := h_spec
  rw [h_local_yields] at h_mem
  simp only [Set.mem_union, Set.mem_singleton_iff] at h_mem
  rcases h_mem with h_initial | h_bundle
  · -- Case 1: nl is the initial state
    use 0, input.initialState, 0
    constructor
    · simp
    constructor
    · simp [FemtoCairo.Spec.femtoCairoMachineBoundedExecution]
    · exact h_initial
  · -- Case 2: nl is from bundle local yields
    -- Use the execution bundle characterization to get the transition
    have ⟨preState, timestamp, h_input_match, h_overflow, h_yielded, h_valid⟩ :=
      executionBundleSpec_localYields_characterization capacities program memory input.bundledInputs yielded bundleLocalYields nl h_bundle_spec h_bundle
    -- Use the valid instruction execution to get the new state
    have ⟨newState, h_transition, h_nl⟩ :=
      IsValidInstructionExecution_implies_valid_transition program memory preState timestamp nl h_valid
    sorry

end Examples.PicoCairo
