/-
PicoCairo LoadState Instruction Circuit
Generated by Claude
-/

import Clean.Circuit.Basic
import Clean.Circuit.Subcircuit
import Clean.Circuit.Loops
import Clean.Examples.PicoCairo.Types
import Clean.Examples.PicoCairo.Helpers
import Clean.Examples.FemtoCairo.FemtoCairo
import Clean.Examples.FemtoCairo.Types
import Clean.Examples.FemtoCairo.Spec
import Clean.Gadgets.Conditional
import Clean.Gadgets.IsZeroField
import Clean.Gadgets.Boolean
import Batteries.Data.Vector.Lemmas

namespace Examples.PicoCairo

open Examples.FemtoCairo
open Examples.FemtoCairo.Types
open Examples.FemtoCairo.Spec

variable {p : ℕ} [Fact p.Prime] [p_large_enough: Fact (p > 512)]

/--
Main circuit for LoadState instruction step.
Takes enabled flag, timestamp, and pre-state.
If enabled and instruction at pc is LoadState, loads new state from operands and yields trace element.
-/
def loadStateStepCircuitMain
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (input : Var InstructionStepInput (F p)) : Circuit (F p) Unit := do

  let enabled := input.enabled
  let timestamp := input.timestamp
  let preState := input.preState

  -- Step 1: Assert enabled is boolean (0 or 1)
  assertBool enabled

  -- Step 1b: Conditionally use the preState from yielded execution trace
  useWhen enabled ⟨"execution", [timestamp, preState.pc, preState.ap, preState.fp]⟩

  -- Step 2: Check that timestamp + 1 is not zero (prevent overflow)
  let timestampPlusOneIsZero ← subcircuit Gadgets.IsZeroField.circuit (timestamp + 1)
  assertZero timestampPlusOneIsZero

  -- Step 3: Fetch instruction from program memory
  let rawInstr ← subcircuitWithAssertion (fetchInstructionCircuit program h_programSize) preState.pc

  -- Step 4: Conditionally decode instruction (only when enabled)
  let decoded ← subcircuitWithAssertion conditionalDecodeCircuit {
    enabled := enabled,
    rawInstrType := rawInstr.rawInstrType,
    dummy := dummyLoadStateInstruction
  }

  -- Step 5: Assert this is a LoadState instruction (type = 3)
  assertZero (decoded.instrType.isLoadState + (-1))

  -- Step 6: Read values from operands 1, 2, 3 (these will be the new pc, ap, fp)
  let newPc ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstr.op1,
    mode := decoded.mode1
  }

  let newAp ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstr.op2,
    mode := decoded.mode2
  }

  let newFp ← subcircuitWithAssertion (readFromMemoryCircuit memory h_memorySize) {
    state := preState,
    offset := rawInstr.op3,
    mode := decoded.mode3
  }

  -- Step 7: Yield new execution state with loaded pc, ap, fp
  -- Note: For LoadState, the new state comes from the operands
  yieldWhen enabled ⟨"execution", [timestamp + 1, newPc, newAp, newFp]⟩

/--
Computes the localYields for a single LoadState instruction step.
If enabled, yields the new execution state with loaded pc, ap, fp values from the environment.
-/
def loadStateStepLocalYields (input : InstructionStepInput (F p)) (env : Environment (F p)) (offset : ℕ) : Set (NamedList (F p)) :=
  { nl | input.enabled ≠ 0 ∧
         nl = ⟨"execution", [input.timestamp + 1,
                            env.get (offset + 2 + 4 + 8 + 1 + 1 + 1 + 1),
                            env.get (offset + 2 + 4 + 8 + 5 + 1 + 1 + 1 + 1),
                            env.get (offset + 2 + 4 + 8 + 5 + 5 + 1 + 1 + 1 + 1)]⟩ }

def loadStateStepElaboratedCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) InstructionStepInput unit where
  main := loadStateStepCircuitMain program h_programSize memory h_memorySize
  localLength _ := 29  -- boolean(0) + IsZero(2) + fetch(4) + conditionalDecode(8) + 3×readMemory(5)
  yields input env offset := loadStateStepLocalYields (eval env input) env offset
  yields_eq := by
    intro input env offset
    simp only [loadStateStepLocalYields, loadStateStepCircuitMain, circuit_norm, Gadgets.IsZeroField.circuit, fetchInstructionCircuit, conditionalDecodeCircuit, conditionalDecodeElaborated,
      readFromMemoryCircuit, NamedList.eval]
    ext nl
    constructor <;> intro h <;> simp only [Set.mem_setOf_eq] at h ⊢
    · exact ⟨h.2, h.1⟩
    · exact ⟨h.2, h.1⟩

/--
Assumptions for LoadState instruction step (for completeness).
-/
def loadStateStepAssumptions
    {programSize : ℕ} [NeZero programSize]
    (input : InstructionStepInput (F p)) (_yielded : Set (NamedList (F p))) : Prop :=
  IsBool input.enabled ∧
  input.timestamp + 1 ≠ 0 ∧
  ZMod.val (input.preState.pc) + 3 < programSize

/--
Spec for LoadState instruction step (for soundness).
Checks that:
1. If enabled, preState is in yielded execution trace
2. Instruction at pc is valid and is LoadState
3. Operands v1, v2, v3 are read correctly (new pc, ap, fp values)
4. New state is yielded with loaded pc, ap, fp values
-/
def loadStateStepSpec
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  if input.enabled = 1 then
    -- Timestamp must not overflow
    input.timestamp + 1 ≠ 0 ∧
    -- When enabled, must have preState in yielded set
    ⟨"execution", [input.timestamp, input.preState.pc, input.preState.ap, input.preState.fp]⟩ ∈ yielded ∧
    match fetchInstruction program input.preState.pc with
    | some rawInstr =>
      match decodeInstruction rawInstr.rawInstrType with
      | some (type, mode1, mode2, mode3) =>
        if type = 3 then
          -- LoadState: type = 3
          match Spec.dataMemoryAccess memory rawInstr.op1 mode1 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op2 mode2 input.preState.ap input.preState.fp,
                Spec.dataMemoryAccess memory rawInstr.op3 mode3 input.preState.ap input.preState.fp with
          | some newPc, some newAp, some newFp =>
            -- LoadState: new state comes from operands
            localYields = {⟨"execution", [input.timestamp + 1, newPc, newAp, newFp]⟩}
          | _, _, _ => False
        else False
      | none => False
    | none => False
  else
    -- When disabled, no yields
    localYields = ∅

/--
GeneralFormalCircuit for LoadState instruction step.
-/
def loadStateStepFormalCircuit
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) InstructionStepInput unit where
  elaborated := loadStateStepElaboratedCircuit program h_programSize memory h_memorySize
  Assumptions := loadStateStepAssumptions (programSize := programSize)
  Spec := loadStateStepSpec program memory

  soundness := by
    circuit_proof_start [loadStateStepSpec, loadStateStepElaboratedCircuit, loadStateStepCircuitMain,
      assertBool, Gadgets.IsZeroField.circuit, Gadgets.IsZeroField.Assumptions, Gadgets.IsZeroField.Spec,
      fetchInstructionCircuit, conditionalDecodeCircuit, readFromMemoryCircuit]
    rcases h_holds with ⟨ h_bool, h_holds ⟩
    rcases h_bool with h_zero | h_one
    · simp only [h_zero, loadStateStepLocalYields]
      aesop
    · subst h_one
      simp only [↓reduceIte, loadStateStepLocalYields]
      rcases h_holds with ⟨ h_use, h_iszero, h_nonzero, h_fetch, h_decode, h_isload, h_read1, h_read2, h_read3 ⟩
      simp only [ne_eq, one_ne_zero, not_false_eq_true, forall_const] at h_use
      constructor
      · aesop
      constructor
      · simp_all only [id_eq, right_eq_ite_iff, zero_ne_one, imp_false, one_ne_zero, ↓reduceIte]
        obtain ⟨left, right⟩ := h_input
        obtain ⟨left_1, right⟩ := right
        subst right left_1
        exact h_use
      clear h_use
      -- manual decomposition because State is not ProvableStruct
      rcases input_var_preState with ⟨ input_var_pc, input_var_ap, input_var_fp ⟩
      rcases input_preState with ⟨ input_pc, input_ap, input_fp ⟩
      simp only [circuit_norm, explicit_provable_type, State.mk.injEq] at h_input
      simp only [h_input] at h_fetch
      simp only
      cases h : fetchInstruction program input_pc
      · simp only [h] at h_fetch
      -- not indenting for heavy interesting case
      simp only [h] at h_fetch
      subst h_fetch
      simp only
      specialize h_decode (by simp only [circuit_norm])
      simp only [one_ne_zero, ↓reduceIte, decodeInstructionSpec] at h_decode
      simp only [circuit_norm, explicit_provable_type]
      cases h2 : decodeInstruction (env.get (i₀ + 2))
      · simp only [h2] at h_decode
      -- not indenting for heavy interesting case
      simp only [h2] at h_decode
      rename_i decoded
      rcases decoded with ⟨ type, mode1', mode2', mode3' ⟩
      simp only at h_decode ⊢
      simp only [circuit_norm, explicit_provable_type] at h_decode h_isload
      rcases h_decode with ⟨ h_decode_type, h_decode ⟩
      -- there should be a tactic for naming outputs of elaborated circuits
      cases decoded : @ElaboratedCircuit.output (F p) ConditionalDecodeInput DecodedInstruction (instFieldFOfFactPrime p)
        ProvableType.fromStruct ProvableType.fromStruct conditionalDecodeElaborated
        { enabled := input_var_enabled, rawInstrType := var { index := i₀ + 2 }, dummy := dummyLoadStateInstruction } (i₀ + 2 + 4)
      rename_i decoded_instr_type decoded_mode1 decoded_mode2 decoded_mode3
      simp only [decoded] at h_decode_type h_isload h_read1 h_read2 h_read3 h_decode
      cases decoded_instr_type
      simp only at h_decode_type h_isload
      simp only [DecodedInstructionType.val] at h_decode_type
      -- For LoadState: isAdd=0, isMul=0, isStoreState=0, so we reach the final else branch
      -- That returns 3, which equals type
      rw [if_neg] at h_decode_type
      swap
      · simp only at h_decode
        rcases h_decode with ⟨ h_encoded_correctly, h_decode ⟩
        clear h_iszero h_nonzero h_read1 h_read2 h_read3 h_decode
        subst h_decode_type
        rcases h_encoded_correctly with h_encoded_add | h_encoded_mul | h_encoded_store | h_encoded_load
        · simp_all only [not_true_eq_false, zero_add, neg_eq_zero, one_ne_zero]
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [zero_ne_one, not_false_eq_true]
      rw [if_neg] at h_decode_type
      swap
      · simp only at h_decode
        rcases h_decode with ⟨ h_encoded_correctly, h_decode ⟩
        clear h_iszero h_nonzero h_read1 h_read2 h_read3 h_decode
        subst h_decode_type
        rcases h_encoded_correctly with h_encoded_add | h_encoded_mul | h_encoded_store | h_encoded_load
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [not_true_eq_false, zero_add, neg_eq_zero, one_ne_zero]
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [zero_ne_one, not_false_eq_true]
      rw [if_neg] at h_decode_type
      swap
      · simp only at h_decode
        rcases h_decode with ⟨ h_encoded_correctly, h_decode ⟩
        clear h_iszero h_nonzero h_read1 h_read2 h_read3 h_decode
        subst h_decode_type
        rcases h_encoded_correctly with h_encoded_add | h_encoded_mul | h_encoded_store | h_encoded_load
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [zero_ne_one, not_false_eq_true]
        · simp_all only [not_true_eq_false, zero_add, neg_eq_zero, one_ne_zero]
        · simp_all only [zero_ne_one, not_false_eq_true]
      subst h_decode_type
      simp only [↓reduceIte]
      specialize h_read1 (by aesop)
      specialize h_read2 (by aesop)
      specialize h_read3 (by aesop)
      rcases h_decode with ⟨ h_correct, h_mode1', h_correct1, h_mode2', h_correct2, h_mode3', h_correct3 ⟩
      cases h_access1 : dataMemoryAccess memory (env.get (i₀ + 2 + 1)) mode1' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read1
        subst h_mode1'
        simp_all
      rename_i newPc
      cases h_access2 : dataMemoryAccess memory (env.get (i₀ + 2 + 1 + 1)) mode2' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read2
        subst h_mode2'
        simp_all
      rename_i newAp
      cases h_access3 : dataMemoryAccess memory (env.get (i₀ + 2 + 1 + 1 + 1)) mode3' input_ap input_fp
      · simp only [circuit_norm, explicit_provable_type] at h_read3
        subst h_mode3'
        simp_all
      rename_i newFp
      subst h_mode1' h_mode2' h_mode3'
      simp only [circuit_norm, explicit_provable_type] at h_read1 h_read2 h_read3
      simp only [conditionalDecodeElaborated] at h_read1 h_read2 h_read3
      simp only [h_access1, h_access2, h_access3] at h_read1 h_read2 h_read3
      simp_all

  -- Postponed: assumptions are missing about well-formedness of the program, etc.
  -- Yield/use is more interesting in soundness.
  completeness := by sorry

/--
Predicate stating that a named list represents a valid LoadState instruction execution.
This captures the relationship between a pre-state, the instruction execution, and the resulting yield.
-/
def IsValidLoadStateExecution
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (preState : State (F p))
    (timestamp : F p)
    (nl : NamedList (F p)) : Prop :=
  ∃ (rawInstr : RawInstruction (F p)) (mode1 mode2 mode3 : ℕ) (newPc newAp newFp : F p),
    Spec.fetchInstruction program preState.pc = some rawInstr ∧
    Spec.decodeInstruction rawInstr.rawInstrType = some (3, mode1, mode2, mode3) ∧
    Spec.dataMemoryAccess memory rawInstr.op1 mode1 preState.ap preState.fp = some newPc ∧
    Spec.dataMemoryAccess memory rawInstr.op2 mode2 preState.ap preState.fp = some newAp ∧
    Spec.dataMemoryAccess memory rawInstr.op3 mode3 preState.ap preState.fp = some newFp ∧
    nl = ⟨"execution", [timestamp + 1, newPc, newAp, newFp]⟩

/--
Characterization theorem for LoadState instruction localYields.
If something is in localYields and the spec holds, we can extract witnesses for all the conditions.
This is useful for inductive reasoning about execution traces.
-/
theorem loadStateStepSpec_localYields_characterization
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (input : InstructionStepInput (F p)) (yielded : Set (NamedList (F p)))
    (localYields : Set (NamedList (F p)))
    (nl : NamedList (F p))
    (h_spec : loadStateStepSpec program memory input yielded () localYields)
    (h_mem : nl ∈ localYields) :
    -- Then we can extract:
    input.enabled = 1 ∧
    input.timestamp + 1 ≠ 0 ∧
    ⟨"execution", [input.timestamp, input.preState.pc, input.preState.ap, input.preState.fp]⟩ ∈ yielded ∧
    IsValidLoadStateExecution program memory input.preState input.timestamp nl := by
  simp only [loadStateStepSpec] at h_spec
  simp only [IsValidLoadStateExecution]
  by_cases h_enabled : input.enabled = 1
  swap -- error case first
  · aesop
  simp only [h_enabled, ↓reduceIte] at h_spec
  simp only [ne_eq, exists_and_left]
  rcases h_spec with ⟨ h_overflow, h_use, h_rest ⟩
  refine ⟨h_enabled, h_overflow, h_use, ?_⟩
  cases h_fetched : fetchInstruction program input.preState.pc
  · simp_all
  rename_i rawInstr
  use rawInstr
  simp only [true_and]
  simp only [h_fetched] at h_rest
  cases h_decoded : decodeInstruction rawInstr.rawInstrType
  · simp_all
  rename_i decoded
  rcases decoded with ⟨ typ, mode1, mode2, mode3 ⟩
  simp only [h_decoded] at h_rest
  refine ⟨mode1, mode2, mode3, ?_, ?_⟩
  · grind
  cases h_access1 : dataMemoryAccess memory rawInstr.op1 mode1 input.preState.ap input.preState.fp
  · grind
  cases h_access2 : dataMemoryAccess memory rawInstr.op2 mode2 input.preState.ap input.preState.fp
  · grind
  cases h_access3 : dataMemoryAccess memory rawInstr.op3 mode3 input.preState.ap input.preState.fp
  · grind
  grind

omit p_large_enough in
/--
Theorem: If IsValidLoadStateExecution holds, then there exists a valid femtoCairoMachineTransition.
This connects the circuit specification to the machine semantics.
-/
theorem IsValidLoadStateExecution_implies_valid_transition
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (preState : State (F p))
    (timestamp : F p)
    (nl : NamedList (F p))
    (h_valid : IsValidLoadStateExecution program memory preState timestamp nl) :
    ∃ newState : State (F p),
      Spec.femtoCairoMachineTransition program memory preState = some newState ∧
      nl = ⟨"execution", [timestamp + 1, newState.pc, newState.ap, newState.fp]⟩ := by
  simp only [IsValidLoadStateExecution] at h_valid
  rcases h_valid with ⟨rawInstr, mode1, mode2, mode3, newPc, newAp, newFp, h_fetch, h_decode, h_access1, h_access2, h_access3, h_nl⟩
  use { pc := newPc, ap := newAp, fp := newFp }
  constructor
  · simp only [Spec.femtoCairoMachineTransition, Option.bind_eq_bind, h_fetch]
    simp only [h_decode, Option.bind_some, h_access1, h_access2, h_access3, computeNextState]
  · exact h_nl

/--
Bundle of LoadState instruction step circuits.
Takes a vector of inputs with given capacity and executes LoadState instructions for each enabled input.
-/
def loadStateStepCircuitsBundle
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p)
    (inputs : Var (ProvableVector InstructionStepInput capacity) (F p)) : Circuit (F p) Unit := do
  let _ ← Circuit.mapFinRange capacity fun i =>
    subcircuitWithAssertion (loadStateStepFormalCircuit program h_programSize memory h_memorySize) inputs[i.val]
  return ()

/--
Elaborated circuit for LoadState instruction bundle.
Note: Unlike ADD/MUL/StoreState, LoadState yields depend on the offset (because they include loaded values from memory).
-/
def loadStateStepCircuitsBundleElaborated
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    ElaboratedCircuit (F p) (ProvableVector InstructionStepInput capacity) unit where
  main := loadStateStepCircuitsBundle capacity program h_programSize memory h_memorySize
  localLength _ := capacity * 29  -- Each step uses 29 locals
  localLength_eq := by
    intros input offset
    simp only [circuit_norm, loadStateStepCircuitsBundle]
    congr 1
  yields inputs env offset :=
    -- Each instruction i has its own offset: offset + i * 29
    ⋃ i : Fin capacity, loadStateStepLocalYields (eval env inputs[i]) env (offset + i * 29)
  yields_eq := by
    intros inputs env offset
    simp only [circuit_norm, loadStateStepCircuitsBundle]
    ext nl
    simp only [Set.mem_iUnion]
    constructor
    · simp only [Nat.zero_mod, Fin.eta, forall_exists_index]
      intro i
      simp only [loadStateStepFormalCircuit, loadStateStepElaboratedCircuit]
      cases iv_h : Vector.get inputs i
      rename_i enabledVar timestampVar preStateVar
      rw [Vector.get_eq_getElem] at iv_h
      rw [iv_h]
      simp only [circuit_norm]
      intro h_nl
      use i
      rw [Vector.get_eq_getElem, iv_h]
      assumption
    · simp only [Fin.eta, Nat.zero_mod, forall_exists_index]
      intro i
      simp only [loadStateStepFormalCircuit, loadStateStepElaboratedCircuit]
      cases iv_h : Vector.get inputs i
      rename_i enabledVar timestampVar preStateVar
      rw [Vector.get_eq_getElem] at iv_h
      simp only [circuit_norm]
      intro h_nl
      use i
      rw [Vector.get_eq_getElem, iv_h]
      assumption
  subcircuitsConsistent := by
    intros inputs offset
    simp only [circuit_norm, loadStateStepCircuitsBundle]

/--
Assumptions for the bundle: each input must satisfy the individual step assumptions.
-/
def loadStateStepCircuitsBundleAssumptions
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize]
    (inputs : ProvableVector InstructionStepInput capacity (F p)) (_yielded : Set (NamedList (F p))) : Prop :=
  ∀ i : Fin capacity, loadStateStepAssumptions (programSize := programSize) inputs[i] _yielded

/--
Spec for the bundle: each element satisfies its step spec with offset-dependent yields, and local yields are the union.
Note: Unlike ADD/MUL/StoreState, the spec needs to account for offset-dependent localYields.
-/
def loadStateStepCircuitsBundleSpec
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p))
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p))
    (inputs : ProvableVector InstructionStepInput capacity (F p)) (yielded : Set (NamedList (F p)))
    (_output : Unit) (localYields : Set (NamedList (F p))) : Prop :=
  -- This spec is more complex because we need an environment to evaluate the offset-dependent yields
  -- For now, we'll just require the union property
  ∃ (env : Environment (F p)) (baseOffset : ℕ),
    (∀ i : Fin capacity, loadStateStepSpec program memory inputs[i] yielded () (loadStateStepLocalYields (inputs[i]) env (baseOffset + i * 29))) ∧
    localYields = ⋃ i : Fin capacity, loadStateStepLocalYields (inputs[i]) env (baseOffset + i * 29)

/--
Bundle-level formal circuit for LoadState instructions.
-/
def loadStateStepCircuitsBundleFormalCircuit
    (capacity : ℕ) [NeZero capacity]
    {programSize : ℕ} [NeZero programSize] (program : Fin programSize → (F p)) (h_programSize : programSize < p)
    {memorySize : ℕ} [NeZero memorySize] (memory : Fin memorySize → (F p)) (h_memorySize : memorySize < p) :
    GeneralFormalCircuit (F p) (ProvableVector InstructionStepInput capacity) unit where
  elaborated := loadStateStepCircuitsBundleElaborated capacity program h_programSize memory h_memorySize
  Assumptions := loadStateStepCircuitsBundleAssumptions capacity (programSize := programSize)
  Spec := loadStateStepCircuitsBundleSpec capacity program memory
  soundness := by
    circuit_proof_start [loadStateStepCircuitsBundleElaborated, loadStateStepCircuitsBundleSpec]
    -- Need to provide env and baseOffset witnesses for the existential in the spec
    use env, i₀
    simp only [loadStateStepCircuitsBundle, circuit_norm] at h_holds
    and_intros
    · intro i
      specialize h_holds i
      simp only [loadStateStepFormalCircuit, loadStateStepElaboratedCircuit] at h_holds
      simp only [Fin.eta] at h_holds
      cases iv_h : Vector.get input_var i
      rename_i enabledVar timestampVar preStateVar
      simp only [iv_h] at h_holds
      simp only [← h_input, eval_vector, Vector.getElem_map]
      rw [Vector.get_eq_getElem] at iv_h
      conv =>
        arg 3
        simp only [iv_h]
        simp only [circuit_norm]
      assumption
    · apply Set.iUnion_congr
      intro i
      congr 1
      simp only [← h_input, eval_vector, Vector.getElem_map]
      cases iv_h : Vector.get input_var i
      rename_i enabledVar timestampVar preStateVar
      rw [Vector.get_eq_getElem] at iv_h
      simp only [iv_h]
      conv_rhs =>
        simp only [circuit_norm]
  completeness := sorry

end Examples.PicoCairo
